Disassembly Listing for CANPAN3
Generated From:
C:/Users/ianwh/github/CANPAN2/CANPAN3.X/dist/PIC18F27Q83/debug/CANPAN3.X.debug.elf
26-Nov-2024 20:42:24
C:/Users/ianwh/MPLABworkspace/CBUS_PIC_Bootloader.X/dist/PIC18F27Q83_canpan/debug/CBUS_PIC_Bootloader.X.debug.elf
23-Nov-2024 15:12:20

---  C:/Users/ianwh/github/VLCBlib_PIC/vlcb.c  ----------------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            */
35:            /**
36:             * @author Ian Hogg 
37:             * @date Dec 2022
38:             * 
39:             */ 
40:            #include <xc.h>
41:            #include "vlcb.h"
42:            #include "module.h"
43:            #include "nvm.h"
44:            #include "hardware.h"
45:            #include "ticktime.h"
46:            #include "timedResponse.h"
47:            #include "statusLeds.h"
48:            #include "mns.h"
49:            
50:            /** @mainpage VLCB
51:             * *************************************************************************
52:             * C library for VLCB. Written for XC8.
53:             * 
54:             * # The structure of the library
55:             * <!--
56:             * This is an ascii art version of the HTML table below.
57:             * <pre>
58:             * -----------
59:             * |   APP   |
60:             * |     ------------------------------------------------------------------
61:             * |     |                            VLCB                                |
62:             * |     |                                                                |
63:             * |     ----------------------- ------------------------------------------
64:             * |         |  |   Service Interface      | |    Transport Interface     |
65:             * |         |  ---------------------------- ------------------------------
66:             * |         |  | service | | service | |          Transport service      |
67:             * -----------  |         | |         | |                                 |
68:             *              ----------- ----------- -----------------------------------
69:             * </pre>
70:             * -->
71:             * 
72:             * <table style="border-collapse: collapse;">
73:                <tr>
74:                    <td colspan="2" style="border-top:2px solid; border-left:2px solid;border-right:2px solid;width:5em;background-color:lightblue;">App</td>
75:                    <td colspan="8">&nbsp;</td>
76:                </tr>
77:                <tr>
78:                    <td style="border-left:2px solid;background-color:lightblue;">&nbsp;</td>
79:                    <td colspan="9" style="border:2px solid;background-color:lightgreen;text-align: center;">VLCB</td>
80:                </tr>
81:                <tr>
82:                    <td style="border-left:2px solid;background-color:lightblue;width:5em;">&nbsp;</td>
83:                    <td style="border:1px solid;border-right:2px solid;background-color:lightblue;">APP callbacks</td>
84:                    <td style="width:2em;">&nbsp;</td>
85:                    <td colspan="4" style="border-left:2px solid;border-top:2px solid;border-bottom:2px solid;background-color:yellow;text-align: center;">Service interface</td>
86:                    <td style="border-right:2px solid;border-top:2px solid;border-bottom:2px solid;width:3em;background-color:yellow;">&nbsp;</td>
87:                    <td style="width:2em;">&nbsp;</td>
88:                    <td style="border:2px solid;background-color:bisque;">Transport interface</td>
89:                </tr>
90:                <tr>
91:                    <td style="border-left:2px solid;border-bottom:2px solid;background-color:lightblue;">&nbsp;</td>
92:                    <td style="border-right:2px solid;border-bottom:2px solid;background-color:lightblue;">&nbsp;</td>
93:                    <td>&nbsp;</td>
94:                    <td style="border:2px solid;background-color:mediumOrchid;">Service 1</td>
95:                    <td>&nbsp;</td>
96:                    <td style="border:2px solid;background-color:hotPink;">Service 2</td>
97:                    <td>&nbsp;</td>
98:                    <td colspan="3" style="border:2px solid;background-color:lightCoral;text-align:center;">Transport Service</td>
99:                </tr>
100:               <tr>
101:                   <td style="text-align:center;">&uarr;&uarr;&uarr;&uarr;</td>
102:                   <td style="text-align:center;">&darr;&darr;&darr;&darr;</td>
103:                   <td>&nbsp;</td>
104:                   <td>&nbsp;</td>
105:                   <td>&nbsp;</td>
106:                   <td>&nbsp;</td>
107:                   <td>&nbsp;</td>
108:                   <td colspan="3" style="text-align:center;">&uarr;&darr;</td>
109:               </tr>
110:               <tr>
111:                   <td colspan="2" style="text-align:center;">Module I/O</td>
112:                   <td>&nbsp;</td>
113:                   <td>&nbsp;</td>
114:                   <td>&nbsp;</td>
115:                   <td>&nbsp;</td>
116:                   <td>&nbsp;</td>
117:                   <td colspan="3" style="text-align:center;">BUS</td>
118:               </tr>
119:           </table> 
120:            * 
121:            * 
122:            * 
123:            * All services must support the Service interface.
124:            * Transport services must also support the Transport interface.
125:            * The APP makes use of VLCB functionality and also provides functionality to
126:            * VLCB. 
127:            * 
128:            * # Application
129:            * The application provides the module specific functionality. VLCB provides
130:            * much of the standard functionality of VLCB modules. Different VLCB capabilities
131:            * are enabled through the use of VLCB services. For example CAN bus support
132:            * can be enabled by including the CAN service.
133:            * 
134:            * ## Application functionality
135:            * An VLCB module using this library needs to consider the following 
136:            * application responsibilities:
137:            * 
138:            * ### Inputs
139:            *    - Monitoring input pins, 
140:            *    - Perform behaviour based upon module NV settings,
141:            *    - Save input state according to type of input in RAM
142:            *    - Send events to the transport layer according to behaviour requirements
143:            * 
144:            * ### Outputs
145:            *    - Receive messages from the transport layer or receive actions from the action queue
146:            *    - Use the NV settings to determine the behaviour
147:            *    - Save state into non volatile memory e.g. EEPROM
148:            *    - Make changes to the output pin state
149:            * 
150:            * ### On power on
151:            *    - Restore output state using the information stored in non volatile memory
152:            *    - Initialise input state based upon current input pin state
153:            * 
154:            * ### Regular poll
155:            *    - Update and perform time based behaviour
156:            * 
157:            * ## Module design
158:            * The designer of a module needs to:
159:            *  1. Determine which services the module will use.
160:            *  2. Write a modules.h which is used by the VLCBlib to control its operation.
161:            *  3. If the module will use NVs then:
162:            *      - Define the NV usage and allocation,
163:            *      - Define the memory allocation (type and address) for the NVs,
164:            *      - Define the default value (factory reset settings) of the NVs,
165:            *      - Determine whether any validation of NV settings is required.
166:            *  4. If the module has a CAN interface:
167:            *      - Decide where in NVM the CANID is to be stored,
168:            *      - Decide how much memory can be used for transmit and receive buffers.
169:            *  5. If the module is to support event teaching:
170:            *      - Decide the number of events and number of EVs per event,
171:            *      - Define the event EV usage and allocation,
172:            *      - Define the memory allocation (type and address) for the EVs,
173:            *  6. If the module also supports produced events then:
174:            *      - If the concept of Happenings is to be used then defined the size of the Happening identifier,
175:            *      - Provide a function to provide the current event state given a Happening
176:            *  7. If the module also supports consumed events then:
177:            *      - If Actions concept is to be used then the size of the Action queue should be defined.
178:            *  8. All modules also need:
179:            *      - The address and type of NVM where the module's node number is to be stored,
180:            *      - The address and type of NVM where the mode is to be stored,
181:            *      - Define the module type name, module ID and version,
182:            *      - The number of LEDs used to display module state,
183:            *      - A macro to obtain the push button state,
184:            *      - A macro to set up the ports for the LEDs and push button.
185:            * 
186:            * ## Other information
187:            *    - The module mode is available using the uint8_t mode global variable.
188:            *    - The module submodes are available using the uint8_t mode_flags global variable.
189:            *    - The module's node number is available as Word nn global variable.
190:            *    - A module should include either statusLeds1.c or statusLeds2.c depending whether it has one or two LEDs.
191:            *    - A module may define a function to process VLCB messages before being handled by the library.
192:            *    - A module may also define a function to process VLCB messages if not handled by the library. 
193:            *   
194:            * ## Application source
195:            * The application source file must provide:
196:            * 1. An array of Service definitions
197:            *      const Service * const services[]
198:            *    which must be initialised with pointers to each service definition for the
199:            *    services required by the application.
200:            *    For example
201:            * @code
202:            * const Service * const services[] = {
203:            *     &canService,
204:            *     &mnsService,
205:            *     &nvService,
206:            *     &bootService,
207:            *     &eventTeachService,
208:            *     &eventConsumerService,
209:            *     &eventProducerService,
210:            *     &eventAckService
211:            * };
212:            * @endcode
213:            * 2. A void init(void) function which sets the transport status pointer e.g.
214:            *     transport = \&canTransport;
215:            *    This function must also do any additional, application specific initialisation.
216:            * 3. A void loop(void) function to perform any regular processing required by
217:            *    the application.
218:            * 4. Callback functions required by the VLCB library depending upon the services used:
219:            *    + uint8_t APP_nvDefault(uint8_t index)
220:            * function to provide a default value for an NV.
221:            *    + void APP_nvValueChanged(uint8_t index, uint8_t value, uint8_t oldValue) 
222:            * function called when an NV has its value changed.
223:            *    + NvValidation APP_nvValidate(uint8_t index, uint8_t value) 
224:            * function to allow the application to validate a new NV value.
225:            *    + uint8_t APP_addEvent(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum, uint8_t evVal)*
226:            * function to be provided by the application and is called when an event is added. 
227:            * Typically this will just call the VLCB library addEvent(uint16_t nodeNumber, 
228:            * uint16_t eventNumber, uint8_t evNum, uint8_t evVal) function.
229:            *    + ValidTime APP_isSuitableTimeToWriteFlash(void) 
230:            * called by the library to check whether the application is currently 
231:            * performing any time critical operations or whether processing can be 
232:            * temporarily suspended to write to Flash memory.
233:            *    + Processed APP_preProcessMessage(Message * m)
234:            * called before a received message is to be processed by the VLCB library.
235:            * This allows and processing provided by the library to be replaced by 
236:            * application specific handling.
237:            *    + Processed APP_postProcessMessage(Message * m)
238:            * called after a received message to checked by the VLCB library if the library
239:            * does not handle the message.
240:            *    + void APP_factoryReset(void)
241:            * called when the module is performing a factory reset and allows the 
242:            * application to set up any non volatile memory required.
243:            *    + void APP_testMode(void)
244:            * called by the library if the button was held down at power up to allow the
245:            * application to perform special test facilities.
246:            * 
247:            * ## Module.h
248:            * The developer of an application must provide a module.h which has 
249:            * module/application specific definitions which influence the behaviour of VLCB.
250:            * 
251:            * Each service documents any requirements it may add for the module.h file.
252:            * 
253:            */
254:           
255:           /**
256:            * @file
257:            * @brief
258:            * Baseline functionality required by VLCB and entry points into the application.
259:            * @details
260:            * Provides the functionality for main() and interrupt processing. 
261:            * Also contains the functionality to handle the list of services.
262:            * Contains the PIC CONFIG settings.
263:            */
264:           
265:           #if defined(_18F66K80_FAMILY_) 
266:           // CONFIG1L
267:           #pragma config RETEN =     OFF      // VREG Sleep Enable bit (Ultra low-power regulator is Disabled (Controlled by REGSLP bit))
268:           #pragma config INTOSCSEL = HIGH // LF-INTOSC Low-power Enable bit (LF-INTOSC in High-power mode during Sleep)
269:           #pragma config SOSCSEL =   DIG    // SOSC Power Selection and mode Configuration bits (Digital (SCLKI) mode)
270:           #pragma config XINST =     OFF      // Extended Instruction Set (Disabled)
271:           
272:           // CONFIG1H
273:           #pragma config FOSC =      HS1       // Oscillator (HS oscillator (Medium power, 4 MHz - 16 MHz))
274:           #pragma config PLLCFG =    OFF      // PLL x4 Enable bit (Disabled)
275:           #pragma config FCMEN =     OFF      // Fail-Safe Clock Monitor (Disabled)
276:           #pragma config IESO =      OFF       // Internal External Oscillator Switch Over Mode (Disabled)
277:           
278:           // CONFIG2L
279:           #pragma config PWRTEN =    ON      // Power Up Timer (Enabled)
280:           #pragma config BOREN =     SBORDIS      // Brown Out Detect (Disabled in hardware, SBOREN disabled)
281:           #pragma config BORV =      0         // Brown-out Reset Voltage bits (3.0V)
282:           #pragma config BORPWR =    ZPBORMV // BORMV Power level (ZPBORMV instead of BORMV is selected)
283:           
284:           // CONFIG2H
285:           #pragma config WDTEN =     OFF      // Watchdog Timer (WDT disabled in hardware; SWDTEN bit disabled)
286:           #pragma config WDTPS =     1048576      // Watchdog Postscaler (1:1048576)
287:           
288:           // CONFIG3H
289:           #pragma config CANMX =     PORTB    // ECAN Mux bit (ECAN TX and RX pins are located on RB2 and RB3, respectively)
290:           #pragma config MSSPMSK =   MSK7   // MSSP address masking (7 Bit address masking mode)
291:           #pragma config MCLRE =     ON       // Master Clear Enable (MCLR Enabled, RE3 Disabled)
292:           
293:           // CONFIG4L
294:           #pragma config STVREN =    ON      // Stack Overflow Reset (Enabled)
295:           #pragma config BBSIZ =     BB1K     // Boot Block Size (1K word Boot Block size)
296:           
297:           // CONFIG5L
298:           #pragma config CP0 =       OFF        // Code Protect 00800-01FFF (Disabled)
299:           #pragma config CP1 =       OFF        // Code Protect 02000-03FFF (Disabled)
300:           #pragma config CP2 =       OFF        // Code Protect 04000-05FFF (Disabled)
301:           #pragma config CP3 =       OFF        // Code Protect 06000-07FFF (Disabled)
302:           
303:           // CONFIG5H
304:           #pragma config CPB =       OFF        // Code Protect Boot (Disabled)
305:           #pragma config CPD =       OFF        // Data EE Read Protect (Disabled)
306:           
307:           // CONFIG6L
308:           #pragma config WRT0 =      OFF       // Table Write Protect 00800-01FFF (Disabled)
309:           #pragma config WRT1 =      OFF       // Table Write Protect 02000-03FFF (Disabled)
310:           #pragma config WRT2 =      OFF       // Table Write Protect 04000-05FFF (Disabled)
311:           #pragma config WRT3 =      OFF       // Table Write Protect 06000-07FFF (Disabled)
312:           
313:           // CONFIG6H
314:           #pragma config WRTC =      OFF       // Config. Write Protect (Disabled)
315:           #pragma config WRTB =      OFF       // Table Write Protect Boot (Disabled)
316:           #pragma config WRTD =      OFF       // Data EE Write Protect (Disabled)
317:           
318:           // CONFIG7L
319:           #pragma config EBTR0 =     OFF      // Table Read Protect 00800-01FFF (Disabled)
320:           #pragma config EBTR1 =     OFF      // Table Read Protect 02000-03FFF (Disabled)
321:           #pragma config EBTR2 =     OFF      // Table Read Protect 04000-05FFF (Disabled)
322:           #pragma config EBTR3 =     OFF      // Table Read Protect 06000-07FFF (Disabled)
323:           
324:           // CONFIG7H
325:           #pragma config EBTRB =     OFF      // Table Read Protect Boot (Disabled)
326:           
327:           #endif
328:           #if defined(_18FXXQ83_FAMILY_)
329:           // Configuration bits: selected in the GUI
330:           
331:           //CONFIG1
332:           #pragma config FEXTOSC = HS     // External Oscillator Selection->HS (crystal oscillator) above 8 MHz
333:           //#pragma config RSTOSC = HFINTOSC_64MHZ     // Reset Oscillator Selection->HFINTOSC with HFFRQ = 64 MHz and CDIV = 1:1
334:           #pragma config RSTOSC = EXTOSC     // External oscillator as per FEXTOSC
335:           
336:           //CONFIG2
337:           #pragma config CLKOUTEN = OFF     // Clock out Enable bit->CLKOUT function is disabled
338:           #pragma config PR1WAY =  ON     // PRLOCKED One-Way Set Enable bit->PRLOCKED bit can be cleared and set only once
339:           #pragma config CSWEN =   ON     // Clock Switch Enable bit->Writing to NOSC and NDIV is allowed
340:           #pragma config JTAGEN =  OFF     // JTAG Enable bit->Disable JTAG Boundary Scan mode, JTAG pins revert to user functions
341:           #pragma config FCMEN =   ON     // Fail-Safe Clock Monitor Enable bit->Fail-Safe Clock Monitor enabled
342:           #pragma config FCMENP =  ON     // Fail-Safe Clock Monitor -Primary XTAL Enable bit->FSCM timer will set FSCMP bit and OSFIF interrupt on Primary XTAL failure
343:           #pragma config FCMENS =  ON     // Fail-Safe Clock Monitor -Secondary XTAL Enable bit->FSCM timer will set FSCMS bit and OSFIF interrupt on Secondary XTAL failure
344:           
345:           //CONFIG3
346:           #pragma config MCLRE =   EXTMCLR     // MCLR Enable bit->If LVP = 0, MCLR pin is MCLR; If LVP = 1, RE3 pin function is MCLR 
347:           #pragma config PWRTS =   PWRT_OFF     // Power-up timer selection bits->PWRT is disabled
348:           #pragma config MVECEN =  ON     // Multi-vector enable bit->Interrupt contoller uses vector table to prioritze interrupts
349:           #pragma config IVT1WAY = ON     // IVTLOCK bit One-way set enable bit->IVTLOCKED bit can be cleared and set only once
350:           #pragma config LPBOREN = OFF     // Low Power BOR Enable bit->Low-Power BOR disabled
351:           #pragma config BOREN =   SBORDIS     // Brown-out Reset Enable bits->Brown-out Reset enabled , SBOREN bit is ignored
352:           
353:           //CONFIG4
354:           #pragma config BORV =    VBOR_2P7     // Brown-out Reset Voltage Selection bits->Brown-out Reset Voltage (VBOR) set to 2.7V
355:           #pragma config ZCD =     OFF     // ZCD Disable bit->ZCD module is disabled. ZCD can be enabled by setting the ZCDSEN bit of ZCDCON
356:           #pragma config PPS1WAY = ON     // PPSLOCK bit One-Way Set Enable bit->PPSLOCKED bit can be cleared and set only once; PPS registers remain locked after one clear/set cycle
357:           #pragma config STVREN =  ON     // Stack Full/Underflow Reset Enable bit->Stack full/underflow will cause Reset
358:           #pragma config LVP =     ON     // Low Voltage Programming Enable bit->Low voltage programming enabled. MCLR/VPP pin function is MCLR. MCLRE configuration bit is ignored
359:           #pragma config XINST =   OFF     // Extended Instruction Set Enable bit->Extended Instruction Set and Indexed Addressing Mode disabled
360:           
361:           //CONFIG5
362:           #pragma config WDTCPS =  WDTCPS_31     // WDT Period selection bits->Divider ratio 1:65536; software control of WDTPS
363:           #pragma config WDTE =    OFF     // WDT operating mode->WDT Disabled; SWDTEN is ignored
364:           
365:           //CONFIG6
366:           #pragma config WDTCWS =  WDTCWS_7     // WDT Window Select bits->window always open (100%); software control; keyed access not required
367:           #pragma config WDTCCS =  SC     // WDT input clock selector->Software Control
368:           
369:           //CONFIG7
370:           #pragma config BBSIZE =  BBSIZE_512     // Boot Block Size selection bits->Boot Block size is 512 words
371:           #pragma config BBEN =    ON     // Boot Block enable bit->Boot block enabled
372:           #pragma config SAFEN =   OFF     // Storage Area Flash enable bit->SAF disabled
373:           
374:           //CONFIG8
375:           #pragma config WRTB =    ON     // Boot Block Write Protection bit->Boot Block Write protected
376:           #pragma config WRTC =    ON     // Configuration Register Write Protection bit->Configuration registers Write protected
377:           #pragma config WRTD =    OFF     // Data EEPROM Write Protection bit->Data EEPROM not Write protected
378:           #pragma config WRTSAF =  OFF     // SAF Write protection bit->SAF not Write Protected
379:           #pragma config WRTAPP =  OFF     // Application Block write protection bit->Application Block not write protected
380:           
381:           //CONFIG9
382:           #pragma config BOOTPINSEL = RC5     // CRC on boot output pin selection->CRC on boot output pin is RC5
383:           #pragma config BPEN =    OFF     // CRC on boot output pin enable bit->CRC on boot output pin disabled
384:           #pragma config ODCON =   OFF     // CRC on boot output pin open drain bit->Pin drives both high-going and low-going signals
385:           
386:           //CONFIG10
387:           #pragma config CP =      OFF     // PFM and Data EEPROM Code Protection bit->PFM and Data EEPROM code protection disabled
388:           
389:           //CONFIG11
390:           #pragma config BOOTSCEN = OFF     // CRC on boot scan enable for boot area->CRC on boot will not include the boot area of program memory in its calculation
391:           #pragma config BOOTCOE = HALT     // CRC on boot Continue on Error for boot areas bit->CRC on boot will stop device if error is detected in boot areas
392:           #pragma config APPSCEN = OFF     // CRC on boot application code scan enable->CRC on boot will not include the application area of program memory in its calculation
393:           #pragma config SAFSCEN = OFF     // CRC on boot SAF area scan enable->CRC on boot will not include the SAF area of program memory in its calculation
394:           #pragma config DATASCEN = OFF     // CRC on boot Data EEPROM scan enable->CRC on boot will not include data EEPROM in its calculation
395:           #pragma config CFGSCEN = OFF     // CRC on boot Config fuses scan enable->CRC on boot will not include the configuration fuses in its calculation
396:           #pragma config COE = HALT     // CRC on boot Continue on Error for non-boot areas bit->CRC on boot will stop device if error is detected in non-boot areas
397:           #pragma config BOOTPOR = OFF     // Boot on CRC Enable bit->CRC on boot will not run
398:           
399:           //CONFIG12
400:           #pragma config BCRCPOLT = hFF     // Boot Sector Polynomial for CRC on boot bits 31-24->Bits 31:24 of BCRCPOL are 0xFF
401:           
402:           //CONFIG13
403:           #pragma config BCRCPOLU = hFF     // Boot Sector Polynomial for CRC on boot bits 23-16->Bits 23:16 of BCRCPOL are 0xFF
404:           
405:           //CONFIG14
406:           #pragma config BCRCPOLH = hFF     // Boot Sector Polynomial for CRC on boot bits 15-8->Bits 15:8 of BCRCPOL are 0xFF
407:           
408:           //CONFIG15
409:           #pragma config BCRCPOLL = hFF     // Boot Sector Polynomial for CRC on boot bits 7-0->Bits 7:0 of BCRCPOL are 0xFF
410:           
411:           //CONFIG16
412:           #pragma config BCRCSEEDT = hFF     // Boot Sector Seed for CRC on boot bits 31-24->Bits 31:24 of BCRCSEED are 0xFF
413:           
414:           //CONFIG17
415:           #pragma config BCRCSEEDU = hFF     // Boot Sector Seed for CRC on boot bits 23-16->Bits 23:16 of BCRCSEED are 0xFF
416:           
417:           //CONFIG18
418:           #pragma config BCRCSEEDH = hFF     // Boot Sector Seed for CRC on boot bits 15-8->Bits 15:8 of BCRCSEED are 0xFF
419:           
420:           //CONFIG19
421:           #pragma config BCRCSEEDL = hFF     // Boot Sector Seed for CRC on boot bits 7-0->Bits 7:0 of BCRCSEED are 0xFF
422:           
423:           //CONFIG20
424:           #pragma config BCRCEREST = hFF     // Boot Sector Expected Result for CRC on boot bits 31-24->Bits 31:24 of BCRCERES are 0xFF
425:           
426:           //CONFIG21
427:           #pragma config BCRCERESU = hFF     // Boot Sector Expected Result for CRC on boot bits 23-16->Bits 23:16 of BCRCERES are 0xFF
428:           
429:           //CONFIG22
430:           #pragma config BCRCERESH = hFF     // Boot Sector Expected Result for CRC on boot bits 15-8->Bits 15:8 of BCRCERES are 0xFF
431:           
432:           //CONFIG23
433:           #pragma config BCRCERESL = hFF     // Boot Sector Expected Result for CRC on boot bits 7-0->Bits 7:0 of BCRCERES are 0xFF
434:           
435:           //CONFIG24
436:           #pragma config CRCPOLT = hFF     // Non-Boot Sector Polynomial for CRC on boot bits 31-24->Bits 31:24 of CRCPOL are 0xFF
437:           
438:           //CONFIG25
439:           #pragma config CRCPOLU = hFF     // Non-Boot Sector Polynomial for CRC on boot bits 23-16->Bits 23:16 of CRCPOL are 0xFF
440:           
441:           //CONFIG26
442:           #pragma config CRCPOLH = hFF     // Non-Boot Sector Polynomial for CRC on boot bits 15-8->Bits 15:8 of CRCPOL are 0xFF
443:           
444:           //CONFIG27
445:           #pragma config CRCPOLL = hFF     // Non-Boot Sector Polynomial for CRC on boot bits 7-0->Bits 7:0 of CRCPOL are 0xFF
446:           
447:           //CONFIG28
448:           #pragma config CRCSEEDT = hFF     // Non-Boot Sector Seed for CRC on boot bits 31-24->Bits 31:24 of CRCSEED are 0xFF
449:           
450:           //CONFIG29
451:           #pragma config CRCSEEDU = hFF     // Non-Boot Sector Seed for CRC on boot bits 23-16->Bits 23:16 of CRCSEED are 0xFF
452:           
453:           //CONFIG30
454:           #pragma config CRCSEEDH = hFF     // Non-Boot Sector Seed for CRC on boot bits 15-8->Bits 15:8 of CRCSEED are 0xFF
455:           
456:           //CONFIG31
457:           #pragma config CRCSEEDL = hFF     // Non-Boot Sector Seed for CRC on boot bits 7-0->Bits 7:0 of CRCSEED are 0xFF
458:           
459:           //CONFIG32
460:           #pragma config CRCEREST = hFF     // Non-Boot Sector Expected Result for CRC on boot bits 31-24->Bits 31:24 of CRCERES are 0xFF
461:           
462:           //CONFIG33
463:           #pragma config CRCERESU = hFF     // Non-Boot Sector Expected Result for CRC on boot bits 23-16->Bits 23:16 of CRCERES are 0xFF
464:           
465:           //CONFIG34
466:           #pragma config CRCERESH = hFF     // Non-Boot Sector Expected Result for CRC on boot bits 15-8->Bits 15:8 of CRCERES are 0xFF
467:           
468:           //CONFIG35
469:           #pragma config CRCERESL = hFF     // Non-Boot Sector Expected Result for CRC on boot bits 7-0->Bits 7:0 of CRCERES are 0xFF
470:           
471:           #endif
472:           
473:           /**
474:            * The list of the priorities for each opcode.
475:            */
476:           const Priority priorities[256] = {
477:               pNORMAL,   // OPC_ACK=0x00,
478:               pNORMAL,   // OPC_NAK=0x01,
479:               pHIGH,   // OPC_HLT=0x02,
480:               pABOVE,   // OPC_BON=0x03,
481:               pABOVE,   // OPC_TOF=0x04,
482:               pABOVE,   // OPC_TON=0x05,
483:               pABOVE,   // OPC_ESTOP=0x06,
484:               pHIGH,   // OPC_ARST=0x07,
485:               pABOVE,   // OPC_RTOF=0x08,
486:               pABOVE,   // OPC_RTON=0x09,
487:               pHIGH,   // OPC_RESTP=0x0A,
488:               pNORMAL,   // OPC_RSTAT=0x0C,
489:               pLOW,   // OPC_QNN=0x0D,
490:               pLOW,   // OPC_RQNP=0x10,
491:               pNORMAL,   // OPC_RQMN=0x11,
492:                       pNORMAL,    // 0x12
493:                       pNORMAL,    // 0x13
494:                       pNORMAL,    // 0x14
495:                       pNORMAL,    // 0x15
496:                       pNORMAL,    // 0x16
497:                       pNORMAL,    // 0x17
498:                       pNORMAL,    // 0x18
499:                       pNORMAL,    // 0x19
500:                       pNORMAL,    // 0x1A
501:                       pNORMAL,    // 0x1B
502:                       pNORMAL,    // 0x1C
503:                       pNORMAL,    // 0x1D
504:                       pNORMAL,    // 0x1E
505:                       pNORMAL,    // 0x1F
506:                       pNORMAL,    // 0x20
507:               pNORMAL,   // OPC_KLOC=0x21,
508:               pNORMAL,   // OPC_QLOC=0x22,
509:               pNORMAL,   // OPC_DKEEP=0x23,
510:                       pNORMAL,    // 0x24
511:                       pNORMAL,    // 0x25
512:                       pNORMAL,    // 0x26
513:                       pNORMAL,    // 0x27
514:                       pNORMAL,    // 0x28
515:                       pNORMAL,    // 0x29
516:                       pNORMAL,    // 0x2A
517:                       pNORMAL,    // 0x2B
518:                       pNORMAL,    // 0x2C
519:                       pNORMAL,    // 0x2D
520:                       pNORMAL,    // 0x2E
521:                       pNORMAL,    // 0x2F
522:               pNORMAL,   // OPC_DBG1=0x30,
523:                       pNORMAL,    // 0x31
524:                       pNORMAL,    // 0x32
525:                       pNORMAL,    // 0x33
526:                       pNORMAL,    // 0x34
527:                       pNORMAL,    // 0x35
528:                       pNORMAL,    // 0x36
529:                       pNORMAL,    // 0x37
530:                       pNORMAL,    // 0x38
531:                       pNORMAL,    // 0x39
532:                       pNORMAL,    // 0x3A
533:                       pNORMAL,    // 0x3B
534:                       pNORMAL,    // 0x3C
535:                       pNORMAL,    // 0x3D
536:                       pNORMAL,    // 0x3E
537:               pNORMAL,    // OPC_EXTC=0x3F
538:               pNORMAL,   // OPC_RLOC=0x40,
539:               pNORMAL,   // OPC_QCON=0x41,
540:               pLOW,   // OPC_SNN=0x42,
541:               pNORMAL,   // OPC_ALOC=0x43,
542:               pNORMAL,   // OPC_STMOD=0x44,
543:               pNORMAL,   // OPC_PCON=0x45,
544:               pNORMAL,   // OPC_KCON=0x46,
545:               pNORMAL,   // OPC_DSPD=0x47,
546:               pNORMAL,   // OPC_DFLG=0x48,
547:               pNORMAL,   // OPC_DFNON=0x49,
548:               pNORMAL,   // OPC_DFNOF=0x4A,
549:                       pNORMAL,    // 0x4B
550:               pLOW,   // OPC_SSTAT=0x4C,
551:                       pNORMAL,    // 0x4D
552:                       pNORMAL,    // 0x4E
553:               pLOW,   // OPC_NNRSM=0x4F,
554:               pLOW,   // OPC_RQNN=0x50,
555:               pLOW,   // OPC_NNREL=0x51,
556:               pLOW,   // OPC_NNACK=0x52,
557:               pLOW,   // OPC_NNLRN=0x53,
558:               pLOW,   // OPC_NNULN=0x54,
559:               pLOW,   // OPC_NNCLR=0x55,
560:               pLOW,   // OPC_NNEVN=0x56,
561:               pLOW,   // OPC_NERD=0x57,
562:               pLOW,   // OPC_RQEVN=0x58,
563:               pLOW,   // OPC_WRACK=0x59,
564:               pLOW,   // OPC_RQDAT=0x5A,
565:               pLOW,   // OPC_RQDDS=0x5B,
566:               pLOW,   // OPC_BOOT=0x5C,
567:               pLOW,   // OPC_ENUM=0x5D,
568:               pLOW,   // OPC_NNRST=0x5E,
569:               pLOW,   // OPC_EXTC1=0x5F,
570:               pNORMAL,   // OPC_DFUN=0x60,
571:               pNORMAL,   // OPC_GLOC=0x61,
572:               pNORMAL,   // OPC_ERR=0x63,
573:                       pNORMAL,    // 0x64
574:                       pNORMAL,    // 0x65
575:               pHIGH,   // OPC_SQU=0x66,
576:                       pNORMAL,    // 0x67
577:                       pNORMAL,    // 0x68
578:                       pNORMAL,    // 0x69
579:                       pNORMAL,    // 0x6A
580:                       pNORMAL,    // 0x6B
581:                       pNORMAL,    // 0x6C
582:                       pNORMAL,    // 0x6D
583:                       pNORMAL,    // 0x6E
584:               pLOW,   // OPC_CMDERR=0x6F,
585:               pLOW,   // OPC_EVNLF=0x70,
586:               pLOW,   // OPC_NVRD=0x71,
587:               pLOW,   // OPC_NENRD=0x72,
588:               pLOW,   // OPC_RQNPN=0x73,
589:               pLOW,   // OPC_NUMEV=0x74,
590:               pLOW,   // OPC_CANID=0x75,
591:               pLOW,   // OPC_MODE=0x76,
592:                       pNORMAL,    // 0x77
593:               pLOW,   // OPC_RQSD=0x78,
594:                       pNORMAL,    // 0x79
595:                       pNORMAL,    // 0x7A
596:                       pNORMAL,    // 0x7B
597:                       pNORMAL,    // 0x7C
598:                       pNORMAL,    // 0x7D
599:                       pNORMAL,    // 0x7E
600:               pLOW,   // OPC_EXTC2=0x7F,
601:               pNORMAL,   // OPC_RDCC3=0x80,
602:                       pNORMAL,    // 0x81
603:               pNORMAL,   // OPC_WCVO=0x82,
604:               pNORMAL,   // OPC_WCVB=0x83,
605:               pNORMAL,   // OPC_QCVS=0x84,
606:               pNORMAL,   // OPC_PCVS=0x85,
607:                       pNORMAL,    // 0x86
608:               pLOW,   // OPC_RDGN=0x87,
609:                       pNORMAL,    // 0x88
610:                       pNORMAL,    // 0x89
611:                       pNORMAL,    // 0x8A
612:                       pNORMAL,    // 0x8B
613:                       pNORMAL,    // 0x8C
614:                       pNORMAL,    // 0x8D
615:               pLOW,   // OPC_NVSETRD=0x8E,
616:                       pNORMAL,    // 0x8F
617:               pLOW,   // OPC_ACON=0x90,
618:               pLOW,   // OPC_ACOF=0x91,
619:               pLOW,   // OPC_AREQ=0x92,
620:               pLOW,   // OPC_ARON=0x93,
621:               pLOW,   // OPC_AROF=0x94,
622:               pLOW,   // OPC_EVULN=0x95,
623:               pLOW,   // OPC_NVSET=0x96,
624:               pLOW,   // OPC_NVANS=0x97,
625:               pLOW,   // OPC_ASON=0x98,
626:               pLOW,   // OPC_ASOF=0x99,
627:               pLOW,   // OPC_ASRQ=0x9A,
628:               pLOW,   // OPC_PARAN=0x9B,
629:               pLOW,   // OPC_REVAL=0x9C,
630:               pLOW,   // OPC_ARSON=0x9D,
631:               pLOW,   // OPC_ARSOF=0x9E,
632:               pLOW,   // OPC_EXTC3=0x9F
633:               pNORMAL,   // OPC_RDCC4=0xA0,
634:                       pNORMAL,    // 0xA1
635:               pNORMAL,   // OPC_WCVS=0xA2,
636:                       pNORMAL,    // 0xA3
637:                       pNORMAL,    // 0xA4
638:                       pNORMAL,    // 0xA5
639:                       pNORMAL,    // 0xA6
640:                       pNORMAL,    // 0xA7
641:                       pNORMAL,    // 0xA8
642:                       pNORMAL,    // 0xA9
643:                       pNORMAL,    // 0xAA
644:               pLOW,   // OPC_HEARTB=0xAB,
645:               pLOW,   // OPC_SD=0xAC,
646:                       pNORMAL,    // 0xAD
647:                       pNORMAL,    // 0xAE
648:               pLOW,   // OPC_GRSP=0xAF,
649:               pLOW,   // OPC_ACON1=0xB0,
650:               pLOW,   // OPC_ACOF1=0xB1,
651:               pLOW,   // OPC_REQEV=0xB2,
652:               pLOW,   // OPC_ARON1=0xB3,
653:               pLOW,   // OPC_AROF1=0xB4,
654:               pLOW,   // OPC_NEVAL=0xB5,
655:               pLOW,   // OPC_PNN=0xB6,
656:                      pNORMAL,    // 0xB7
657:               pLOW,   // OPC_ASON1=0xB8,
658:               pLOW,   // OPC_ASOF1=0xB9,
659:                      pNORMAL,    // 0xBA
660:                      pNORMAL,    // 0xBB
661:                      pNORMAL,    // 0xBC
662:               pLOW,   // OPC_ARSON1=0xBD,
663:               pLOW,   // OPC_ARSOF1=0xBE,
664:               pLOW,   // OPC_EXTC4=0xBF,
665:               pNORMAL,   // OPC_RDCC5=0xC0,
666:               pNORMAL,   // OPC_WCVOA=0xC1,
667:               pNORMAL,   // OPC_CABDAT=0xC2,
668:                      pNORMAL,    // 0xC3
669:                      pNORMAL,    // 0xC4
670:                      pNORMAL,    // 0xC5
671:                      pNORMAL,    // 0xC6
672:               pLOW,   // OPC_DGN=0xC7,
673:                      pNORMAL,    // 0xC8
674:                      pNORMAL,    // 0xC9
675:                      pNORMAL,    // 0xCA
676:                      pNORMAL,    // 0xCB
677:                      pNORMAL,    // 0xCC
678:                      pNORMAL,    // 0xCD
679:                      pNORMAL,    // 0xCE
680:               pNORMAL,   // OPC_FCLK=0xCF,
681:               pLOW,   // OPC_ACON2=0xD0,
682:               pLOW,   // OPC_ACOF2=0xD1,
683:               pLOW,   // OPC_EVLRN=0xD2,
684:               pLOW,   // OPC_EVANS=0xD3,
685:               pLOW,   // OPC_ARON2=0xD4,
686:               pLOW,   // OPC_AROF2=0xD5,
687:                      pNORMAL,    // 0xD6
688:                      pNORMAL,    // 0xD7
689:               pLOW,   // OPC_ASON2=0xD8,
690:               pLOW,   // OPC_ASOF2=0xD9,
691:                      pNORMAL,    // 0xDA
692:                      pNORMAL,    // 0xDB
693:                      pNORMAL,    // 0xDC
694:               pLOW,   // OPC_ARSON2=0xDD,
695:               pLOW,   // OPC_ARSOF2=0xDE,
696:               pLOW,   // OPC_EXTC5=0xDF,
697:               pNORMAL,   // OPC_RDCC6=0xE0,
698:               pNORMAL,   // OPC_PLOC=0xE1,
699:               pLOW,   // OPC_NAME=0xE2,
700:               pNORMAL,   // OPC_STAT=0xE3,
701:                      pNORMAL,    // 0xE4
702:                      pNORMAL,    // 0xE5
703:               pLOW,   // OPC_ENACK=0xE6,
704:               pLOW,   // OPC_ESD=0xE7,
705:                      pNORMAL,    // 0xE8
706:               pLOW,   // OPC_DTXC=0xE9,
707:                      pNORMAL,    // 0xEA
708:                      pNORMAL,    // 0xEB
709:                      pNORMAL,    // 0xEC
710:                      pNORMAL,    // 0xED
711:                      pNORMAL,    // 0xEE
712:               pLOW,   // OPC_PARAMS=0xEF,
713:               pLOW,   // OPC_ACON3=0xF0,
714:               pLOW,   // OPC_ACOF3=0xF1,
715:               pLOW,   // OPC_ENRSP=0xF2,
716:               pLOW,   // OPC_ARON3=0xF3,
717:               pLOW,   // OPC_AROF3=0xF4,
718:               pLOW,   // OPC_EVLRNI=0xF5,
719:               pLOW,   // OPC_ACDAT=0xF6,
720:               pLOW,   // OPC_ARDAT=0xF7,
721:               pLOW,   // OPC_ASON3=0xF8,
722:               pLOW,   // OPC_ASOF3=0xF9,
723:               pLOW,   // OPC_DDES=0xFA,
724:               pLOW,   // OPC_DDRS=0xFB,
725:               pLOW,   // OPC_ARSON3=0xFD,
726:               pLOW,   // OPC_ARSOF3=0xFE
727:                      pNORMAL,    // 0xFF
728:           };
729:           
730:           #ifdef BOOTLOADER_PRESENT
731:           // ensure that the bootflag is zeroed
732:           #pragma romdata BOOTFLAG
733:           uint8_t eeBootFlag = 0;
734:           #endif
735:           
736:           
737:           /**
738:            * The module's transport interface.
739:            */
740:           const Transport * transport;            // pointer to the Transport interface
741:           static Message tmpMessage;
742:           
743:           /**
744:            * Used to control the rate at which timedResponse messages are sent.
745:            */
746:           static TickValue timedResponseTime;
747:           static uint8_t timedResponseDelay;
748:           
749:           
750:           /**
751:            * Used to control how often it is checked whether any of the flash buffer
752:            * needs to be flushed out to permanent storage.
753:            */
754:           static TickValue flashFlushTime;
755:           
756:           /** 
757:            * Function that must be provided by the application. 
758:            * Called when a message is received and before the message is processed 
759:            * by the VLCB library. 
760:            * Allows the application to override VLCB functionality.
761:            */
762:           extern Processed APP_preProcessMessage(Message * m);
763:           /** 
764:            * Function that must be provided by the application. 
765:            * Called when a message is received and after the message has been checked 
766:            * by the VLCB library. Called only if the message is not processed by the 
767:            * VLCB library.
768:            * Allows the application to handle messages, including events.
769:            */
770:           extern Processed APP_postProcessMessage(Message * m);
771:           /** 
772:            * Function that must be provided by the application. 
773:            * Called when the module is being reset back to manufacturer defaults.
774:            * Allows the application to initialise its non volatile memory.
775:            */
776:           extern void APP_factoryReset(void);
777:           /**
778:            * Function that must be provided by the application.
779:            * Called if the push button is held down during power up. 
780:            * Allows the application to provide test functionality during construction or setup.
781:            */
782:           extern void APP_testMode(void);
783:           
784:           // forward declarations
785:           /**
786:            * Function that must be provided by the application.
787:            * Called by the VLCB library upon power up after the library has initialised itself.
788:            * Allows the application to perform its own initialisation.
789:            */
790:           void setup(void);
791:           /**
792:            * Function that must be provided by the application.
793:            * Called by the VLCB library repeatedly to allow the application to perform 
794:            * processing during normal operation.
795:            */
796:           void loop(void);
797:           
798:           
799:           /////////////////////////////////////////////
800:           // SERVICE CHECKING FUNCTIONS
801:           /////////////////////////////////////////////
802:           /**
803:            * Find a service and obtain its service descriptor if it has been used by the
804:            * module.
805:            * @param id the service type id
806:            * @return the service descriptor or NULL if the service is not used by the module.
807:            */
808:           const Service * findService(uint8_t id) {
14288  6E06     MOVWF 0x6, ACCESS
809:               uint8_t i;
810:               for (i=0; i<NUM_SERVICES; i++) {
1428A  0E00     MOVLW 0x0
1428C  6E07     MOVWF 0x7, ACCESS
811:                   if ((services[i] != NULL) && (services[i]->serviceNo == id)) {
1428E  5007     MOVF 0x7, W, ACCESS
14290  0D02     MULLW 0x2
14292  0E23     MOVLW 0x23
14294  24F3     ADDWF 0xFF3, W, ACCESS
14296  6EF6     MOVWF 0xFF6, ACCESS
14298  0EFF     MOVLW 0xFF
1429A  20F4     ADDWFC 0xFF4, W, ACCESS
1429C  6EF7     MOVWF 0xFF7, ACCESS
1429E  6AF8     CLRF 0xFF8, ACCESS
142A0  0E00     MOVLW 0x0
142A2  22F8     ADDWFC 0xFF8, F, ACCESS
142A4  0009     TBLRD*+
142A6  50F5     MOVF 0xFF5, W, ACCESS
142A8  0009     TBLRD*+
142AA  10F5     IORWF 0xFF5, W, ACCESS
142AC  B4D8     BTFSC 0xFD8, 2, ACCESS
142AE  D02E     BRA 0x430C
142B0  5007     MOVF 0x7, W, ACCESS
142B2  0D02     MULLW 0x2
142B4  0E23     MOVLW 0x23
142B6  24F3     ADDWF 0xFF3, W, ACCESS
142B8  6EF6     MOVWF 0xFF6, ACCESS
142BA  0EFF     MOVLW 0xFF
142BC  20F4     ADDWFC 0xFF4, W, ACCESS
142BE  6EF7     MOVWF 0xFF7, ACCESS
142C0  6AF8     CLRF 0xFF8, ACCESS
142C2  0E00     MOVLW 0x0
142C4  22F8     ADDWFC 0xFF8, F, ACCESS
142C6  0009     TBLRD*+
142C8  C4F5     MOVFF TABLAT, s
142CA  F504     NOP
142CC  0009     TBLRD*+
142CE  C4F5     MOVFF TABLAT, i
142D0  F505     NOP
142D2  C504     MOVFF s, TBLPTR
142D4  F4F6     NOP
142D6  C505     MOVFF i, TBLPTRH
142D8  F4F7     NOP
142DA  0E00     MOVLW 0x0
142DC  6EF8     MOVWF 0xFF8, ACCESS
142DE  0008     TBLRD*
142E0  50F5     MOVF 0xFF5, W, ACCESS
142E2  1806     XORWF 0x6, W, ACCESS
142E4  A4D8     BTFSS 0xFD8, 2, ACCESS
142E6  D012     BRA 0x430C
812:                       return services[i];
142E8  5007     MOVF 0x7, W, ACCESS
142EA  0D02     MULLW 0x2
142EC  0E23     MOVLW 0x23
142EE  24F3     ADDWF 0xFF3, W, ACCESS
142F0  6EF6     MOVWF 0xFF6, ACCESS
142F2  0EFF     MOVLW 0xFF
142F4  20F4     ADDWFC 0xFF4, W, ACCESS
142F6  6EF7     MOVWF 0xFF7, ACCESS
142F8  6AF8     CLRF 0xFF8, ACCESS
142FA  0E00     MOVLW 0x0
142FC  22F8     ADDWFC 0xFF8, F, ACCESS
142FE  0009     TBLRD*+
14300  C4F5     MOVFF TABLAT, i
14302  F502     NOP
14304  000A     TBLRD*-
14306  C4F5     MOVFF TABLAT, opc
14308  F503     NOP
1430A  0012     RETURN 0
813:                   }
814:               }
1430C  2A07     INCF 0x7, F, ACCESS
1430E  0E08     MOVLW 0x8
14310  6407     CPFSGT 0x7, ACCESS
14312  D7BD     BRA 0x428E
815:               return NULL;
14314  0E00     MOVLW 0x0
14316  6E02     MOVWF ___rparam_used, ACCESS
14318  0E00     MOVLW 0x0
1431A  6E03     MOVWF __activetblptr, ACCESS
816:           }
1431C  0012     RETURN 0
817:           
818:           /**
819:            * Obtain the index int the services array of the specified service.
820:            * @param serviceType the service type id
821:            * @return the index into the services array or -1 if the service is not used by the module.
822:            */
823:           uint8_t findServiceIndex(uint8_t serviceType) {
14C30  6E04     MOVWF __activetblptr, ACCESS
824:               uint8_t i;
825:               for (i=0; i<NUM_SERVICES; i++) {
14C32  0E00     MOVLW 0x0
14C34  6E05     MOVWF 0x5, ACCESS
826:                   if ((services[i] != NULL) && (services[i]->serviceNo == serviceType)) {
14C36  5005     MOVF 0x5, W, ACCESS
14C38  0D02     MULLW 0x2
14C3A  0E23     MOVLW 0x23
14C3C  24F3     ADDWF 0xFF3, W, ACCESS
14C3E  6EF6     MOVWF 0xFF6, ACCESS
14C40  0EFF     MOVLW 0xFF
14C42  20F4     ADDWFC 0xFF4, W, ACCESS
14C44  6EF7     MOVWF 0xFF7, ACCESS
14C46  6AF8     CLRF 0xFF8, ACCESS
14C48  0E00     MOVLW 0x0
14C4A  22F8     ADDWFC 0xFF8, F, ACCESS
14C4C  0009     TBLRD*+
14C4E  50F5     MOVF 0xFF5, W, ACCESS
14C50  0009     TBLRD*+
14C52  10F5     IORWF 0xFF5, W, ACCESS
14C54  B4D8     BTFSC 0xFD8, 2, ACCESS
14C56  D01E     BRA 0x4C94
14C58  5005     MOVF 0x5, W, ACCESS
14C5A  0D02     MULLW 0x2
14C5C  0E23     MOVLW 0x23
14C5E  24F3     ADDWF 0xFF3, W, ACCESS
14C60  6EF6     MOVWF 0xFF6, ACCESS
14C62  0EFF     MOVLW 0xFF
14C64  20F4     ADDWFC 0xFF4, W, ACCESS
14C66  6EF7     MOVWF 0xFF7, ACCESS
14C68  6AF8     CLRF 0xFF8, ACCESS
14C6A  0E00     MOVLW 0x0
14C6C  22F8     ADDWFC 0xFF8, F, ACCESS
14C6E  0009     TBLRD*+
14C70  C4F5     MOVFF TABLAT, i
14C72  F502     NOP
14C74  0009     TBLRD*+
14C76  C4F5     MOVFF TABLAT, opc
14C78  F503     NOP
14C7A  C502     MOVFF i, TBLPTR
14C7C  F4F6     NOP
14C7E  C503     MOVFF opc, TBLPTRH
14C80  F4F7     NOP
14C82  0E00     MOVLW 0x0
14C84  6EF8     MOVWF 0xFF8, ACCESS
14C86  0008     TBLRD*
14C88  50F5     MOVF 0xFF5, W, ACCESS
14C8A  1804     XORWF __activetblptr, W, ACCESS
14C8C  A4D8     BTFSS 0xFD8, 2, ACCESS
14C8E  D002     BRA 0x4C94
827:                       return i;
14C90  5005     MOVF 0x5, W, ACCESS
14C92  0012     RETURN 0
828:                   }
829:               }
14C94  2A05     INCF 0x5, F, ACCESS
14C96  0E08     MOVLW 0x8
14C98  6405     CPFSGT 0x5, ACCESS
14C9A  D7CD     BRA 0x4C36
830:               return SERVICE_ID_NOT_FOUND;
14C9C  0EFF     MOVLW 0xFF
831:           }
14C9E  0012     RETURN 0
832:           
833:           /**
834:            * Tests whether the module used the specified service.
835:            * @param id the service type id
836:            * @return PRESENT if the service is present NOT_PRESENT otherwise
837:            */
838:           ServicePresent have(uint8_t id) {
14CA0  6E04     MOVWF __activetblptr, ACCESS
839:               uint8_t i;
840:               for (i=0; i<NUM_SERVICES; i++) {
14CA2  0E00     MOVLW 0x0
14CA4  6E05     MOVWF 0x5, ACCESS
841:                   if ((services[i] != NULL) && (services[i]->serviceNo == id)) {
14CA6  5005     MOVF 0x5, W, ACCESS
14CA8  0D02     MULLW 0x2
14CAA  0E23     MOVLW 0x23
14CAC  24F3     ADDWF 0xFF3, W, ACCESS
14CAE  6EF6     MOVWF 0xFF6, ACCESS
14CB0  0EFF     MOVLW 0xFF
14CB2  20F4     ADDWFC 0xFF4, W, ACCESS
14CB4  6EF7     MOVWF 0xFF7, ACCESS
14CB6  6AF8     CLRF 0xFF8, ACCESS
14CB8  0E00     MOVLW 0x0
14CBA  22F8     ADDWFC 0xFF8, F, ACCESS
14CBC  0009     TBLRD*+
14CBE  50F5     MOVF 0xFF5, W, ACCESS
14CC0  0009     TBLRD*+
14CC2  10F5     IORWF 0xFF5, W, ACCESS
14CC4  B4D8     BTFSC 0xFD8, 2, ACCESS
14CC6  D01E     BRA 0x4D04
14CC8  5005     MOVF 0x5, W, ACCESS
14CCA  0D02     MULLW 0x2
14CCC  0E23     MOVLW 0x23
14CCE  24F3     ADDWF 0xFF3, W, ACCESS
14CD0  6EF6     MOVWF 0xFF6, ACCESS
14CD2  0EFF     MOVLW 0xFF
14CD4  20F4     ADDWFC 0xFF4, W, ACCESS
14CD6  6EF7     MOVWF 0xFF7, ACCESS
14CD8  6AF8     CLRF 0xFF8, ACCESS
14CDA  0E00     MOVLW 0x0
14CDC  22F8     ADDWFC 0xFF8, F, ACCESS
14CDE  0009     TBLRD*+
14CE0  C4F5     MOVFF TABLAT, i
14CE2  F502     NOP
14CE4  0009     TBLRD*+
14CE6  C4F5     MOVFF TABLAT, opc
14CE8  F503     NOP
14CEA  C502     MOVFF i, TBLPTR
14CEC  F4F6     NOP
14CEE  C503     MOVFF opc, TBLPTRH
14CF0  F4F7     NOP
14CF2  0E00     MOVLW 0x0
14CF4  6EF8     MOVWF 0xFF8, ACCESS
14CF6  0008     TBLRD*
14CF8  50F5     MOVF 0xFF5, W, ACCESS
14CFA  1804     XORWF __activetblptr, W, ACCESS
14CFC  A4D8     BTFSS 0xFD8, 2, ACCESS
14CFE  D002     BRA 0x4D04
842:                       return PRESENT;
14D00  0E01     MOVLW 0x1
14D02  0012     RETURN 0
843:                   }
844:               }
14D04  2A05     INCF 0x5, F, ACCESS
14D06  0E08     MOVLW 0x8
14D08  6405     CPFSGT 0x5, ACCESS
14D0A  D7CD     BRA 0x4CA6
845:               return NOT_PRESENT;
14D0C  0E00     MOVLW 0x0
846:           }
14D0E  0012     RETURN 0
847:           
848:           /////////////////////////////////////////////
849:           //FUNCTIONS TO CALL SERVICES
850:           /////////////////////////////////////////////
851:           /**
852:            * Perform the factory reset for all services and VLCB base.
853:            * VLCB function to perform necessary factory reset functionality and also
854:            * call the factoryReset function for each service followed by the Application
855:            * factory reset APP_factoryReset().
856:            */
857:           void factoryReset(void) {
858:               uint8_t i;
859:            
860:               for (i=0; i<NUM_SERVICES; i++) {
1388A  0E00     MOVLW 0x0
1388C  6E3D     MOVWF 0x3D, ACCESS
861:                   if ((services[i] != NULL) && (services[i]->factoryReset != NULL)) {
1388E  503D     MOVF 0x3D, W, ACCESS
13890  0D02     MULLW 0x2
13892  0E23     MOVLW 0x23
13894  24F3     ADDWF 0xFF3, W, ACCESS
13896  6EF6     MOVWF 0xFF6, ACCESS
13898  0EFF     MOVLW 0xFF
1389A  20F4     ADDWFC 0xFF4, W, ACCESS
1389C  6EF7     MOVWF 0xFF7, ACCESS
1389E  6AF8     CLRF 0xFF8, ACCESS
138A0  0E00     MOVLW 0x0
138A2  22F8     ADDWFC 0xFF8, F, ACCESS
138A4  0009     TBLRD*+
138A6  50F5     MOVF 0xFF5, W, ACCESS
138A8  0009     TBLRD*+
138AA  10F5     IORWF 0xFF5, W, ACCESS
138AC  B4D8     BTFSC 0xFD8, 2, ACCESS
138AE  D04D     BRA 0x394A
138B0  503D     MOVF 0x3D, W, ACCESS
138B2  0D02     MULLW 0x2
138B4  0E23     MOVLW 0x23
138B6  24F3     ADDWF 0xFF3, W, ACCESS
138B8  6EF6     MOVWF 0xFF6, ACCESS
138BA  0EFF     MOVLW 0xFF
138BC  20F4     ADDWFC 0xFF4, W, ACCESS
138BE  6EF7     MOVWF 0xFF7, ACCESS
138C0  6AF8     CLRF 0xFF8, ACCESS
138C2  0E00     MOVLW 0x0
138C4  22F8     ADDWFC 0xFF8, F, ACCESS
138C6  0009     TBLRD*+
138C8  C4F5     MOVFF TABLAT, buttonNo
138CA  F53B     NOP
138CC  0009     TBLRD*+
138CE  C4F5     MOVFF TABLAT, nodeNumber
138D0  F53C     NOP
138D2  0E02     MOVLW 0x2
138D4  263B     ADDWF 0x3B, F, ACCESS
138D6  0E00     MOVLW 0x0
138D8  223C     ADDWFC 0x3C, F, ACCESS
138DA  C53B     MOVFF buttonNo, TBLPTR
138DC  F4F6     NOP
138DE  C53C     MOVFF nodeNumber, TBLPTRH
138E0  F4F7     NOP
138E2  0E00     MOVLW 0x0
138E4  6EF8     MOVWF 0xFF8, ACCESS
138E6  0009     TBLRD*+
138E8  50F5     MOVF 0xFF5, W, ACCESS
138EA  0009     TBLRD*+
138EC  10F5     IORWF 0xFF5, W, ACCESS
138EE  0009     TBLRD*+
138F0  10F5     IORWF 0xFF5, W, ACCESS
138F2  B4D8     BTFSC 0xFD8, 2, ACCESS
138F4  D02A     BRA 0x394A
862:                       services[i]->factoryReset();
138F6  503D     MOVF 0x3D, W, ACCESS
138F8  0D02     MULLW 0x2
138FA  0E23     MOVLW 0x23
138FC  24F3     ADDWF 0xFF3, W, ACCESS
138FE  6EF6     MOVWF 0xFF6, ACCESS
13900  0EFF     MOVLW 0xFF
13902  20F4     ADDWFC 0xFF4, W, ACCESS
13904  6EF7     MOVWF 0xFF7, ACCESS
13906  6AF8     CLRF 0xFF8, ACCESS
13908  0E00     MOVLW 0x0
1390A  22F8     ADDWFC 0xFF8, F, ACCESS
1390C  0009     TBLRD*+
1390E  C4F5     MOVFF TABLAT, buttonNo
13910  F53B     NOP
13912  0009     TBLRD*+
13914  C4F5     MOVFF TABLAT, nodeNumber
13916  F53C     NOP
13918  0E02     MOVLW 0x2
1391A  263B     ADDWF 0x3B, F, ACCESS
1391C  0E00     MOVLW 0x0
1391E  223C     ADDWFC 0x3C, F, ACCESS
13920  C53B     MOVFF buttonNo, TBLPTR
13922  F4F6     NOP
13924  C53C     MOVFF nodeNumber, TBLPTRH
13926  F4F7     NOP
13928  0E00     MOVLW 0x0
1392A  6EF8     MOVWF 0xFF8, ACCESS
1392C  D801     RCALL 0x3930
1392E  D00D     BRA 0x394A
13930  0005     PUSH
13932  6EFA     MOVWF 0xFFA, ACCESS
13934  0009     TBLRD*+
13936  50F5     MOVF 0xFF5, W, ACCESS
13938  6EFD     MOVWF 0xFFD, ACCESS
1393A  0009     TBLRD*+
1393C  50F5     MOVF 0xFF5, W, ACCESS
1393E  6EFE     MOVWF 0xFFE, ACCESS
13940  0009     TBLRD*+
13942  50F5     MOVF 0xFF5, W, ACCESS
13944  6EFF     MOVWF 0xFFF, ACCESS
13946  50FA     MOVF 0xFFA, W, ACCESS
13948  0012     RETURN 0
863:                   }
864:               }
1394A  2A3D     INCF 0x3D, F, ACCESS
1394C  0E08     MOVLW 0x8
1394E  643D     CPFSGT 0x3D, ACCESS
13950  D79E     BRA 0x388E
865:               // now write the version number
866:               writeNVM(VERSION_NVM_TYPE, VERSION_ADDRESS, APP_NVM_VERSION);
13952  0EFA     MOVLW 0xFA
13954  6E10     MOVWF 0x10, ACCESS
13956  0E03     MOVLW 0x3
13958  6E11     MOVWF 0x11, ACCESS
1395A  0E00     MOVLW 0x0
1395C  6E12     MOVWF 0x12, ACCESS
1395E  0E01     MOVLW 0x1
13960  6E13     MOVWF 0x13, ACCESS
13962  0E00     MOVLW 0x0
13964  EC7E     CALL 0x156FC, 0
13966  F0AB     NOP
867:               
868:               APP_factoryReset();
13968  EC33     CALL 0x16266, 0
1396A  F0B1     NOP
869:           }
1396C  0012     RETURN 0
870:           
871:           /**
872:            * Perform power up for all services and VLCB base.
873:            * VLCB function to perform necessary power up functionality and also
874:            * call the powerUp function for each service.
875:            */
876:           static void powerUp(void) {
877:               uint8_t i;
878:               uint8_t divider;
879:               
880:               // Initialise the Tick timer. Uses low priority interrupts
881:               initTicker(0);
13B30  0E00     MOVLW 0x0
13B32  EC7E     CALL 0x152FC, 0
13B34  F0A9     NOP
882:               initTimedResponse();
13B36  EC3C     CALL 0x16278, 0
13B38  F0B1     NOP
883:               leds_powerUp();
13B3A  EC27     CALL 0x15C4E, 0
13B3C  F0AE     NOP
884:               timedResponseDelay = 5;
13B3E  0E05     MOVLW 0x5
13B40  0105     MOVLB 0x5
13B42  6F9E     MOVWF 0x9E, BANKED
885:               
886:               for (i=0; i<NUM_SERVICES; i++) {
13B44  0E00     MOVLW 0x0
13B46  6E16     MOVWF 0x16, ACCESS
887:                   if ((services[i] != NULL) && (services[i]->powerUp != NULL)) {
13B48  5016     MOVF 0x16, W, ACCESS
13B4A  0D02     MULLW 0x2
13B4C  0E23     MOVLW 0x23
13B4E  24F3     ADDWF 0xFF3, W, ACCESS
13B50  6EF6     MOVWF 0xFF6, ACCESS
13B52  0EFF     MOVLW 0xFF
13B54  20F4     ADDWFC 0xFF4, W, ACCESS
13B56  6EF7     MOVWF 0xFF7, ACCESS
13B58  6AF8     CLRF 0xFF8, ACCESS
13B5A  0E00     MOVLW 0x0
13B5C  22F8     ADDWFC 0xFF8, F, ACCESS
13B5E  0009     TBLRD*+
13B60  50F5     MOVF 0xFF5, W, ACCESS
13B62  0009     TBLRD*+
13B64  10F5     IORWF 0xFF5, W, ACCESS
13B66  B4D8     BTFSC 0xFD8, 2, ACCESS
13B68  D04D     BRA 0x3C04
13B6A  5016     MOVF 0x16, W, ACCESS
13B6C  0D02     MULLW 0x2
13B6E  0E23     MOVLW 0x23
13B70  24F3     ADDWF 0xFF3, W, ACCESS
13B72  6EF6     MOVWF 0xFF6, ACCESS
13B74  0EFF     MOVLW 0xFF
13B76  20F4     ADDWFC 0xFF4, W, ACCESS
13B78  6EF7     MOVWF 0xFF7, ACCESS
13B7A  6AF8     CLRF 0xFF8, ACCESS
13B7C  0E00     MOVLW 0x0
13B7E  22F8     ADDWFC 0xFF8, F, ACCESS
13B80  0009     TBLRD*+
13B82  C4F5     MOVFF TABLAT, incomingCanId
13B84  F514     NOP
13B86  0009     TBLRD*+
13B88  C4F5     MOVFF TABLAT, lo
13B8A  F515     NOP
13B8C  0E05     MOVLW 0x5
13B8E  2614     ADDWF 0x14, F, ACCESS
13B90  0E00     MOVLW 0x0
13B92  2215     ADDWFC 0x15, F, ACCESS
13B94  C514     MOVFF incomingCanId, TBLPTR
13B96  F4F6     NOP
13B98  C515     MOVFF lo, TBLPTRH
13B9A  F4F7     NOP
13B9C  0E00     MOVLW 0x0
13B9E  6EF8     MOVWF 0xFF8, ACCESS
13BA0  0009     TBLRD*+
13BA2  50F5     MOVF 0xFF5, W, ACCESS
13BA4  0009     TBLRD*+
13BA6  10F5     IORWF 0xFF5, W, ACCESS
13BA8  0009     TBLRD*+
13BAA  10F5     IORWF 0xFF5, W, ACCESS
13BAC  B4D8     BTFSC 0xFD8, 2, ACCESS
13BAE  D02A     BRA 0x3C04
888:                       services[i]->powerUp();
13BB0  5016     MOVF 0x16, W, ACCESS
13BB2  0D02     MULLW 0x2
13BB4  0E23     MOVLW 0x23
13BB6  24F3     ADDWF 0xFF3, W, ACCESS
13BB8  6EF6     MOVWF 0xFF6, ACCESS
13BBA  0EFF     MOVLW 0xFF
13BBC  20F4     ADDWFC 0xFF4, W, ACCESS
13BBE  6EF7     MOVWF 0xFF7, ACCESS
13BC0  6AF8     CLRF 0xFF8, ACCESS
13BC2  0E00     MOVLW 0x0
13BC4  22F8     ADDWFC 0xFF8, F, ACCESS
13BC6  0009     TBLRD*+
13BC8  C4F5     MOVFF TABLAT, incomingCanId
13BCA  F514     NOP
13BCC  0009     TBLRD*+
13BCE  C4F5     MOVFF TABLAT, lo
13BD0  F515     NOP
13BD2  0E05     MOVLW 0x5
13BD4  2614     ADDWF 0x14, F, ACCESS
13BD6  0E00     MOVLW 0x0
13BD8  2215     ADDWFC 0x15, F, ACCESS
13BDA  C514     MOVFF incomingCanId, TBLPTR
13BDC  F4F6     NOP
13BDE  C515     MOVFF lo, TBLPTRH
13BE0  F4F7     NOP
13BE2  0E00     MOVLW 0x0
13BE4  6EF8     MOVWF 0xFF8, ACCESS
13BE6  D801     RCALL 0x3BEA
13BE8  D00D     BRA 0x3C04
13BEA  0005     PUSH
13BEC  6EFA     MOVWF 0xFFA, ACCESS
13BEE  0009     TBLRD*+
13BF0  50F5     MOVF 0xFF5, W, ACCESS
13BF2  6EFD     MOVWF 0xFFD, ACCESS
13BF4  0009     TBLRD*+
13BF6  50F5     MOVF 0xFF5, W, ACCESS
13BF8  6EFE     MOVWF 0xFFE, ACCESS
13BFA  0009     TBLRD*+
13BFC  50F5     MOVF 0xFF5, W, ACCESS
13BFE  6EFF     MOVWF 0xFFF, ACCESS
13C00  50FA     MOVF 0xFFA, W, ACCESS
13C02  0012     RETURN 0
889:                   }
890:               }
13C04  2A16     INCF 0x16, F, ACCESS
13C04  2A16     INCF 0x16, F, ACCESS
13C04  2A16     INCF 0x16, F, ACCESS
13C04  2A16     INCF 0x16, F, ACCESS
13C04  2A16     INCF 0x16, F, ACCESS
891:           }
892:           
893:           /*
894:            * Update the delay between each timedResponse transmission. By default a value 
895:            * of 5 is used for a delay of 5ms.
896:            * Typically the application would allocate an NV to hold the delay value. The 
897:            * Application can use its callback when the NV value is changed to call this 
898:            * function.
899:            * @param delay the delay in millisec
900:            */
901:           void setTimedResponseDelay(uint8_t delay) {
902:               timedResponseDelay = delay;
903:           }
904:           
905:           
906:           /**
907:            * Time how long the pb is held down for, with a timeout.
908:            * 
909:            * @param timeout number of seconds to wait
910:            * @return seconds pb held down or 0 for a timeout
911:            */
912:           uint8_t pbDownTimer(uint8_t timeout) {
14094  6E1D     MOVWF 0x1D, ACCESS
913:               // determine how long the button is held for
914:               pbTimer.val = tickGet();
14096  ECD8     CALL 0x153B0, 0
14098  F0A9     NOP
1409A  C502     MOVFF i, pbTimer
1409C  F574     NOP
1409E  C503     MOVFF opc, 0x575
140A0  F575     NOP
140A2  C504     MOVFF s, 0x576
140A4  F576     NOP
140A6  C505     MOVFF i, 0x577
140A8  F577     NOP
915:               while (APP_pbPressed()) {
140AA  D02C     BRA 0x4104
916:                   leds_poll();
140AC  ECE1     CALL 0x11DC2, 0
140AE  F08E     NOP
917:                   if (tickTimeSince(pbTimer) > timeout*ONE_SECOND) {
140B0  ECD8     CALL 0x153B0, 0
140B2  F0A9     NOP
140B4  0105     MOVLB 0x5
140B6  5174     MOVF CM2CON0, W, BANKED
140B8  5C02     SUBWF ___rparam_used, W, ACCESS
140BA  6E19     MOVWF 0x19, ACCESS
140BC  5175     MOVF CM2CON1, W, BANKED
140BE  5803     SUBWFB __activetblptr, W, ACCESS
140C0  6E1A     MOVWF 0x1A, ACCESS
140C2  5176     MOVF CM2NCH, W, BANKED
140C4  5804     SUBWFB __activetblptr, W, ACCESS
140C6  6E1B     MOVWF 0x1B, ACCESS
140C8  5177     MOVF CM2PCH, W, BANKED
140CA  5805     SUBWFB 0x5, W, ACCESS
140CC  6E1C     MOVWF 0x1C, ACCESS
140CE  501D     MOVF 0x1D, W, ACCESS
140D0  6E02     MOVWF ___rparam_used, ACCESS
140D2  6A03     CLRF __activetblptr, ACCESS
140D4  6A04     CLRF __activetblptr, ACCESS
140D6  6A05     CLRF 0x5, ACCESS
140D8  0E24     MOVLW 0x24
140DA  6E06     MOVWF 0x6, ACCESS
140DC  0EF4     MOVLW 0xF4
140DE  6E07     MOVWF 0x7, ACCESS
140E0  0E00     MOVLW 0x0
140E2  6E08     MOVWF 0x8, ACCESS
140E4  0E00     MOVLW 0x0
140E6  6E09     MOVWF 0x9, ACCESS
140E8  ECB4     CALL 0x15568, 0
140EA  F0AA     NOP
140EC  5019     MOVF 0x19, W, ACCESS
140EE  5C02     SUBWF ___rparam_used, W, ACCESS
140F0  501A     MOVF 0x1A, W, ACCESS
140F2  5803     SUBWFB __activetblptr, W, ACCESS
140F4  501B     MOVF 0x1B, W, ACCESS
140F6  5804     SUBWFB __activetblptr, W, ACCESS
140F8  501C     MOVF 0x1C, W, ACCESS
140FA  5805     SUBWFB 0x5, W, ACCESS
140FC  B0D8     BTFSC 0xFD8, 0, ACCESS
140FE  D002     BRA 0x4104
918:                       return 0;   // timeout
14100  0E00     MOVLW 0x0
14102  0012     RETURN 0
919:                   }
920:               }
14104  A6CE     BTFSS 0xFCE, 3, ACCESS
14106  D7D2     BRA 0x40AC
921:               // no longer pressed
922:               return (uint8_t)(tickTimeSince(pbTimer)/ONE_SECOND);
14108  ECD8     CALL 0x153B0, 0
1410A  F0A9     NOP
1410C  0105     MOVLB 0x5
1410E  5174     MOVF CM2CON0, W, BANKED
14110  5C02     SUBWF ___rparam_used, W, ACCESS
14112  6E0C     MOVWF 0xC, ACCESS
14114  5175     MOVF CM2CON1, W, BANKED
14116  5803     SUBWFB __activetblptr, W, ACCESS
14118  6E0D     MOVWF 0xD, ACCESS
1411A  5176     MOVF CM2NCH, W, BANKED
1411C  5804     SUBWFB __activetblptr, W, ACCESS
1411E  6E0E     MOVWF 0xE, ACCESS
14120  5177     MOVF CM2PCH, W, BANKED
14122  5805     SUBWFB 0x5, W, ACCESS
14124  6E0F     MOVWF 0xF, ACCESS
14126  0E24     MOVLW 0x24
14128  6E10     MOVWF 0x10, ACCESS
1412A  0EF4     MOVLW 0xF4
1412C  6E11     MOVWF 0x11, ACCESS
1412E  0E00     MOVLW 0x0
14130  6E12     MOVWF 0x12, ACCESS
14132  0E00     MOVLW 0x0
14134  6E13     MOVWF 0x13, ACCESS
14136  ECFA     CALL 0x147F4, 0
14138  F0A3     NOP
1413A  500C     MOVF 0xC, W, ACCESS
923:           }
1413C  0012     RETURN 0
924:           
925:           /**
926:            * Time how long the pb is released down for, with a timeout.
927:            * 
928:            * @param timeout number of seconds to wait
929:            * @return seconds pb released or 0 for a timeout
930:            */
931:           uint8_t pbUpTimer(uint8_t timeout) {
13FEA  6E1D     MOVWF 0x1D, ACCESS
932:               // determine how long the button is released for
933:               pbTimer.val = tickGet();
13FEC  ECD8     CALL 0x153B0, 0
13FEE  F0A9     NOP
13FF0  C502     MOVFF i, pbTimer
13FF2  F574     NOP
13FF4  C503     MOVFF opc, 0x575
13FF6  F575     NOP
13FF8  C504     MOVFF s, 0x576
13FFA  F576     NOP
13FFC  C505     MOVFF i, 0x577
13FFE  F577     NOP
934:               while (! (APP_pbPressed())) {
14000  D02C     BRA 0x405A
935:                   leds_poll();
14002  ECE1     CALL 0x11DC2, 0
14004  F08E     NOP
936:                   if (tickTimeSince(pbTimer) > timeout*ONE_SECOND) {
14006  ECD8     CALL 0x153B0, 0
14008  F0A9     NOP
1400A  0105     MOVLB 0x5
1400C  5174     MOVF CM2CON0, W, BANKED
1400E  5C02     SUBWF ___rparam_used, W, ACCESS
14010  6E19     MOVWF 0x19, ACCESS
14012  5175     MOVF CM2CON1, W, BANKED
14014  5803     SUBWFB __activetblptr, W, ACCESS
14016  6E1A     MOVWF 0x1A, ACCESS
14018  5176     MOVF CM2NCH, W, BANKED
1401A  5804     SUBWFB __activetblptr, W, ACCESS
1401C  6E1B     MOVWF 0x1B, ACCESS
1401E  5177     MOVF CM2PCH, W, BANKED
14020  5805     SUBWFB 0x5, W, ACCESS
14022  6E1C     MOVWF 0x1C, ACCESS
14024  501D     MOVF 0x1D, W, ACCESS
14026  6E02     MOVWF ___rparam_used, ACCESS
14028  6A03     CLRF __activetblptr, ACCESS
1402A  6A04     CLRF __activetblptr, ACCESS
1402C  6A05     CLRF 0x5, ACCESS
1402E  0E24     MOVLW 0x24
14030  6E06     MOVWF 0x6, ACCESS
14032  0EF4     MOVLW 0xF4
14034  6E07     MOVWF 0x7, ACCESS
14036  0E00     MOVLW 0x0
14038  6E08     MOVWF 0x8, ACCESS
1403A  0E00     MOVLW 0x0
1403C  6E09     MOVWF 0x9, ACCESS
1403E  ECB4     CALL 0x15568, 0
14040  F0AA     NOP
14042  5019     MOVF 0x19, W, ACCESS
14044  5C02     SUBWF ___rparam_used, W, ACCESS
14046  501A     MOVF 0x1A, W, ACCESS
14048  5803     SUBWFB __activetblptr, W, ACCESS
1404A  501B     MOVF 0x1B, W, ACCESS
1404C  5804     SUBWFB __activetblptr, W, ACCESS
1404E  501C     MOVF 0x1C, W, ACCESS
14050  5805     SUBWFB 0x5, W, ACCESS
14052  B0D8     BTFSC 0xFD8, 0, ACCESS
14054  D002     BRA 0x405A
937:                       return 0;   // timeout
14056  0E00     MOVLW 0x0
14058  0012     RETURN 0
938:                   }
939:               }
1405A  B6CE     BTFSC 0xFCE, 3, ACCESS
1405C  D7D2     BRA 0x4002
940:               // now pressed
941:               return (uint8_t)(tickTimeSince(pbTimer)/ONE_SECOND);
1405E  ECD8     CALL 0x153B0, 0
14060  F0A9     NOP
14062  0105     MOVLB 0x5
14064  5174     MOVF CM2CON0, W, BANKED
14066  5C02     SUBWF ___rparam_used, W, ACCESS
14068  6E0C     MOVWF 0xC, ACCESS
1406A  5175     MOVF CM2CON1, W, BANKED
1406C  5803     SUBWFB __activetblptr, W, ACCESS
1406E  6E0D     MOVWF 0xD, ACCESS
14070  5176     MOVF CM2NCH, W, BANKED
14072  5804     SUBWFB __activetblptr, W, ACCESS
14074  6E0E     MOVWF 0xE, ACCESS
14076  5177     MOVF CM2PCH, W, BANKED
14078  5805     SUBWFB 0x5, W, ACCESS
1407A  6E0F     MOVWF 0xF, ACCESS
1407C  0E24     MOVLW 0x24
1407E  6E10     MOVWF 0x10, ACCESS
14080  0EF4     MOVLW 0xF4
14082  6E11     MOVWF 0x11, ACCESS
14084  0E00     MOVLW 0x0
14086  6E12     MOVWF 0x12, ACCESS
14088  0E00     MOVLW 0x0
1408A  6E13     MOVWF 0x13, ACCESS
1408C  ECFA     CALL 0x147F4, 0
1408E  F0A3     NOP
14090  500C     MOVF 0xC, W, ACCESS
942:           }
14092  0012     RETURN 0
943:           
944:           /**
945:            * Do checks to see if the push button was held down during power up. 
946:            * Then call back into the application to do the relevant work.
947:            * Test Mode
948:            *   The push button is held down at power up for between 2 and 6 seconds then released.
949:            *   If held down for more than 30 seconds then the module shall continue normal operation.
950:            * Factory reset
951:            *   The push button is held down at power up for between 10 and 30 seconds
952:            *   then released and then pressed again for between 2 and 4 seconds.
953:            */
954:           static void checkPowerOnPb(void) {
955:               uint8_t i;
956:               
957:               // check for the push button being pressed at power up
958:               if (APP_pbPressed()) {
154BA  B6CE     BTFSC 0xFCE, 3, ACCESS
154BC  0012     RETURN 0
959:                   // determine how long the button is held for
960:                   i = pbDownTimer(30);
154BE  0E1E     MOVLW 0x1E
154C0  EC4A     CALL 0x14094, 0
154C2  F0A0     NOP
154C4  6E3E     MOVWF 0x3E, ACCESS
961:                   if (i == 0) {
154C6  503E     MOVF 0x3E, W, ACCESS
154C8  B4D8     BTFSC 0xFD8, 2, ACCESS
154CA  0012     RETURN 0
962:                       //Timeout
963:                       return;
964:                   } else if ((i>=2) && (i < 6)) {
154CC  0E01     MOVLW 0x1
154CE  643E     CPFSGT 0x3E, ACCESS
154D0  D006     BRA 0x54DE
154D2  0E06     MOVLW 0x6
154D4  603E     CPFSLT 0x3E, ACCESS
154D6  D003     BRA 0x54DE
965:                       APP_testMode();
154D8  EC53     CALL 0x162A6, 0
154DA  F0B1     NOP
966:                   } else if (i >= 10) {
154DC  0012     RETURN 0
154DE  0E09     MOVLW 0x9
154E0  643E     CPFSGT 0x3E, ACCESS
154E2  0012     RETURN 0
967:                       showStatus(STATUS_RESET_WARNING);
154E4  0E04     MOVLW 0x4
154E6  ECCD     CALL 0x1379A, 0
154E8  F09B     NOP
968:                       // wait for pb down max 5 seconds
969:                       i = pbUpTimer(5);
154EA  0E05     MOVLW 0x5
154EC  ECF5     CALL 0x13FEA, 0
154EE  F09F     NOP
154F0  6E3E     MOVWF 0x3E, ACCESS
970:                       if (i == 0) {
154F2  503E     MOVF 0x3E, W, ACCESS
154F4  B4D8     BTFSC 0xFD8, 2, ACCESS
154F6  0012     RETURN 0
971:                           // Timeout
972:                           return;
973:                       }
974:                       i = pbDownTimer(5);
154F8  0E05     MOVLW 0x5
154FA  EC4A     CALL 0x14094, 0
154FC  F0A0     NOP
154FE  6E3E     MOVWF 0x3E, ACCESS
975:                       if ((i>=2) && (i < 4)) {
15500  0E01     MOVLW 0x1
15502  643E     CPFSGT 0x3E, ACCESS
15504  0012     RETURN 0
15506  0E04     MOVLW 0x4
15508  603E     CPFSLT 0x3E, ACCESS
1550A  0012     RETURN 0
976:                           factoryReset();
1550C  EC45     CALL 0x1388A, 0
1550E  F09C     NOP
977:                       }
978:                   }
979:               }
980:           }
15510  0012     RETURN 0
981:           
982:           /**
983:            * Poll each service.
984:            * VLCB function to perform necessary poll functionality and regularly 
985:            * poll each service.
986:            * 
987:            * Polling occurs as frequently as possible. It is the responsibility of the
988:            * service's poll function to ensure that any actions are performed at the 
989:            * correct rate, for example by using tickTimeSince(lastTime).
990:            * This also attempts to obtain a message from transport and call the services
991:            * to process the message. Will also call back into APP to process message.
992:            */
993:           static void poll(void) {
994:               uint8_t i;
995:               Message m;
996:               Processed handled;
997:               
998:               /* handle any timed responses */
999:               if (tickTimeSince(timedResponseTime) > (long)timedResponseDelay*ONE_MILI_SECOND) {
11796  ECD8     CALL 0x153B0, 0
11798  F0A9     NOP
1179A  0105     MOVLB 0x5
1179C  5164     MOVF PMD4, W, BANKED
1179E  5C02     SUBWF ___rparam_used, W, ACCESS
117A0  6E4F     MOVWF 0x4F, ACCESS
117A2  5165     MOVF PMD5, W, BANKED
117A4  5803     SUBWFB __activetblptr, W, ACCESS
117A6  6E50     MOVWF 0x50, ACCESS
117A8  5166     MOVF PMD6, W, BANKED
117AA  5804     SUBWFB __activetblptr, W, ACCESS
117AC  6E51     MOVWF 0x51, ACCESS
117AE  5167     MOVF PMD7, W, BANKED
117B0  5805     SUBWFB 0x5, W, ACCESS
117B2  6E52     MOVWF 0x52, ACCESS
117B4  519E     MOVF 0x9E, W, BANKED
117B6  6E02     MOVWF ___rparam_used, ACCESS
117B8  6A03     CLRF __activetblptr, ACCESS
117BA  6A04     CLRF __activetblptr, ACCESS
117BC  6A05     CLRF 0x5, ACCESS
117BE  0E3E     MOVLW 0x3E
117C0  6E06     MOVWF 0x6, ACCESS
117C2  0E00     MOVLW 0x0
117C4  6E07     MOVWF 0x7, ACCESS
117C6  0E00     MOVLW 0x0
117C8  6E08     MOVWF 0x8, ACCESS
117CA  0E00     MOVLW 0x0
117CC  6E09     MOVWF 0x9, ACCESS
117CE  ECB4     CALL 0x15568, 0
117D0  F0AA     NOP
117D2  504F     MOVF 0x4F, W, ACCESS
117D4  5C02     SUBWF ___rparam_used, W, ACCESS
117D6  5050     MOVF 0x50, W, ACCESS
117D8  5803     SUBWFB __activetblptr, W, ACCESS
117DA  5051     MOVF 0x51, W, ACCESS
117DC  5804     SUBWFB __activetblptr, W, ACCESS
117DE  5052     MOVF 0x52, W, ACCESS
117E0  5805     SUBWFB 0x5, W, ACCESS
117E2  B0D8     BTFSC 0xFD8, 0, ACCESS
117E4  D00C     BRA 0x17FE
1000:                  pollTimedResponse();
117E6  EC3B     CALL 0x14876, 0
117E8  F0A4     NOP
1001:                  timedResponseTime.val = tickGet();
117EA  ECD8     CALL 0x153B0, 0
117EC  F0A9     NOP
117EE  C502     MOVFF i, timedResponseTime
117F0  F564     NOP
117F2  C503     MOVFF opc, 0x565
117F4  F565     NOP
117F6  C504     MOVFF s, 0x566
117F8  F566     NOP
117FA  C505     MOVFF i, 0x567
117FC  F567     NOP
1002:              }
1003:              if (tickTimeSince(flashFlushTime) > ONE_SECOND) {
117FE  ECD8     CALL 0x153B0, 0
11800  F0A9     NOP
11802  0105     MOVLB 0x5
11804  5160     MOVF PMD0, W, BANKED
11806  5C02     SUBWF ___rparam_used, W, ACCESS
11808  6E4F     MOVWF 0x4F, ACCESS
1180A  5161     MOVF PMD1, W, BANKED
1180C  5803     SUBWFB __activetblptr, W, ACCESS
1180E  6E50     MOVWF 0x50, ACCESS
11810  5162     MOVF PMD2, W, BANKED
11812  5804     SUBWFB __activetblptr, W, ACCESS
11814  6E51     MOVWF 0x51, ACCESS
11816  5163     MOVF PMD3, W, BANKED
11818  5805     SUBWFB 0x5, W, ACCESS
1181A  6E52     MOVWF 0x52, ACCESS
1181C  5052     MOVF 0x52, W, ACCESS
1181E  1051     IORWF 0x51, W, ACCESS
11820  E106     BNZ 0x182E
11822  0E25     MOVLW 0x25
11824  5C4F     SUBWF 0x4F, W, ACCESS
11826  0EF4     MOVLW 0xF4
11828  5850     SUBWFB 0x50, W, ACCESS
1182A  A0D8     BTFSS 0xFD8, 0, ACCESS
1182C  D00C     BRA 0x1846
1004:                  flushFlashBlock();
1182E  EC22     CALL 0x15244, 0
11830  F0A9     NOP
1005:                  flashFlushTime.val = tickGet();
11832  ECD8     CALL 0x153B0, 0
11834  F0A9     NOP
11836  C502     MOVFF i, flashFlushTime
11838  F560     NOP
1183A  C503     MOVFF opc, __accesstop
1183C  F561     NOP
1183E  C504     MOVFF s, 0x562
11840  F562     NOP
11842  C505     MOVFF i, 0x563
11844  F563     NOP
1006:              }
1007:              /* call any service polls */
1008:              for (i=0; i<NUM_SERVICES; i++) {
11846  0E00     MOVLW 0x0
11848  0106     MOVLB 0x6
1184A  6FE1     MOVWF 0xE1, BANKED
1009:                  if ((services[i] != NULL) && (services[i]->poll != NULL)) {
1184C  51E1     MOVF 0xE1, W, BANKED
1184E  0D02     MULLW 0x2
11850  0E23     MOVLW 0x23
11852  24F3     ADDWF 0xFF3, W, ACCESS
11854  6EF6     MOVWF 0xFF6, ACCESS
11856  0EFF     MOVLW 0xFF
11858  20F4     ADDWFC 0xFF4, W, ACCESS
1185A  6EF7     MOVWF 0xFF7, ACCESS
1185C  6AF8     CLRF 0xFF8, ACCESS
1185E  0E00     MOVLW 0x0
11860  22F8     ADDWFC 0xFF8, F, ACCESS
11862  0009     TBLRD*+
11864  50F5     MOVF 0xFF5, W, ACCESS
11866  0009     TBLRD*+
11868  10F5     IORWF 0xFF5, W, ACCESS
1186A  B4D8     BTFSC 0xFD8, 2, ACCESS
1186C  D04D     BRA 0x1908
1186E  51E1     MOVF 0xE1, W, BANKED
11870  0D02     MULLW 0x2
11872  0E23     MOVLW 0x23
11874  24F3     ADDWF 0xFF3, W, ACCESS
11876  6EF6     MOVWF 0xFF6, ACCESS
11878  0EFF     MOVLW 0xFF
1187A  20F4     ADDWFC 0xFF4, W, ACCESS
1187C  6EF7     MOVWF 0xFF7, ACCESS
1187E  6AF8     CLRF 0xFF8, ACCESS
11880  0E00     MOVLW 0x0
11882  22F8     ADDWFC 0xFF8, F, ACCESS
11884  0009     TBLRD*+
11886  C4F5     MOVFF TABLAT, 0x54F
11888  F54F     NOP
1188A  0009     TBLRD*+
1188C  C4F5     MOVFF TABLAT, 0x550
1188E  F550     NOP
11890  0E0B     MOVLW 0xB
11892  264F     ADDWF 0x4F, F, ACCESS
11894  0E00     MOVLW 0x0
11896  2250     ADDWFC 0x50, F, ACCESS
11898  C54F     MOVFF 0x54F, TBLPTR
1189A  F4F6     NOP
1189C  C550     MOVFF 0x550, TBLPTRH
1189E  F4F7     NOP
118A0  0E00     MOVLW 0x0
118A2  6EF8     MOVWF 0xFF8, ACCESS
118A4  0009     TBLRD*+
118A6  50F5     MOVF 0xFF5, W, ACCESS
118A8  0009     TBLRD*+
118AA  10F5     IORWF 0xFF5, W, ACCESS
118AC  0009     TBLRD*+
118AE  10F5     IORWF 0xFF5, W, ACCESS
118B0  B4D8     BTFSC 0xFD8, 2, ACCESS
118B2  D02A     BRA 0x1908
1010:                      services[i]->poll();
118B4  51E1     MOVF 0xE1, W, BANKED
118B6  0D02     MULLW 0x2
118B8  0E23     MOVLW 0x23
118BA  24F3     ADDWF 0xFF3, W, ACCESS
118BC  6EF6     MOVWF 0xFF6, ACCESS
118BE  0EFF     MOVLW 0xFF
118C0  20F4     ADDWFC 0xFF4, W, ACCESS
118C2  6EF7     MOVWF 0xFF7, ACCESS
118C4  6AF8     CLRF 0xFF8, ACCESS
118C6  0E00     MOVLW 0x0
118C8  22F8     ADDWFC 0xFF8, F, ACCESS
118CA  0009     TBLRD*+
118CC  C4F5     MOVFF TABLAT, 0x54F
118CE  F54F     NOP
118D0  0009     TBLRD*+
118D2  C4F5     MOVFF TABLAT, 0x550
118D4  F550     NOP
118D6  0E0B     MOVLW 0xB
118D8  264F     ADDWF 0x4F, F, ACCESS
118DA  0E00     MOVLW 0x0
118DC  2250     ADDWFC 0x50, F, ACCESS
118DE  C54F     MOVFF 0x54F, TBLPTR
118E0  F4F6     NOP
118E2  C550     MOVFF 0x550, TBLPTRH
118E4  F4F7     NOP
118E6  0E00     MOVLW 0x0
118E8  6EF8     MOVWF 0xFF8, ACCESS
118EA  D801     RCALL 0x18EE
118EC  D00D     BRA 0x1908
118EE  0005     PUSH
118F0  6EFA     MOVWF 0xFFA, ACCESS
118F2  0009     TBLRD*+
118F4  50F5     MOVF 0xFF5, W, ACCESS
118F6  6EFD     MOVWF 0xFFD, ACCESS
118F8  0009     TBLRD*+
118FA  50F5     MOVF 0xFF5, W, ACCESS
118FC  6EFE     MOVWF 0xFFE, ACCESS
118FE  0009     TBLRD*+
11900  50F5     MOVF 0xFF5, W, ACCESS
11902  6EFF     MOVWF 0xFFF, ACCESS
11904  50FA     MOVF 0xFFA, W, ACCESS
11906  0012     RETURN 0
1011:                  }
1012:              }
11908  0106     MOVLB 0x6
1190A  2BE1     INCF 0xE1, F, BANKED
1190C  0E08     MOVLW 0x8
1190E  65E1     CPFSGT 0xE1, BANKED
11910  D79D     BRA 0x184C
1013:              
1014:              leds_poll();
11912  ECE1     CALL 0x11DC2, 0
11914  F08E     NOP
1015:              
1016:              // Handle any incoming messages from the transport
1017:              handled = NOT_PROCESSED;
11916  0E00     MOVLW 0x0
11918  0106     MOVLB 0x6
1191A  6FE0     MOVWF 0xE0, BANKED
1018:              if (transport != NULL) {
1191C  0105     MOVLB 0x5
1191E  519B     MOVF 0x9B, W, BANKED
11920  119C     IORWF 0x9C, W, BANKED
11922  B4D8     BTFSC 0xFD8, 2, ACCESS
11924  D0C3     BRA 0x1AAC
1019:                  if (transport->receiveMessage != NULL) {
11926  0E03     MOVLW 0x3
11928  259B     ADDWF 0x9B, W, BANKED
1192A  6E4F     MOVWF 0x4F, ACCESS
1192C  0E00     MOVLW 0x0
1192E  219C     ADDWFC 0x9C, W, BANKED
11930  6E50     MOVWF 0x50, ACCESS
11932  C54F     MOVFF 0x54F, TBLPTR
11934  F4F6     NOP
11936  C550     MOVFF 0x550, TBLPTRH
11938  F4F7     NOP
1193A  0E00     MOVLW 0x0
1193C  6EF8     MOVWF 0xFF8, ACCESS
1193E  0009     TBLRD*+
11940  50F5     MOVF 0xFF5, W, ACCESS
11942  0009     TBLRD*+
11944  10F5     IORWF 0xFF5, W, ACCESS
11946  0009     TBLRD*+
11948  10F5     IORWF 0xFF5, W, ACCESS
1194A  B4D8     BTFSC 0xFD8, 2, ACCESS
1194C  D0AF     BRA 0x1AAC
1020:                      if (transport->receiveMessage(&m)) {
1194E  0EE2     MOVLW 0xE2
11950  6E11     MOVWF 0x11, ACCESS
11952  0E06     MOVLW 0x6
11954  6E12     MOVWF 0x12, ACCESS
11956  0E03     MOVLW 0x3
11958  259B     ADDWF 0x9B, W, BANKED
1195A  6E4F     MOVWF 0x4F, ACCESS
1195C  0E00     MOVLW 0x0
1195E  219C     ADDWFC 0x9C, W, BANKED
11960  6E50     MOVWF 0x50, ACCESS
11962  C54F     MOVFF 0x54F, TBLPTR
11964  F4F6     NOP
11966  C550     MOVFF 0x550, TBLPTRH
11968  F4F7     NOP
1196A  0E00     MOVLW 0x0
1196C  6EF8     MOVWF 0xFF8, ACCESS
1196E  D801     RCALL 0x1972
11970  D00D     BRA 0x198C
11972  0005     PUSH
11974  6EFA     MOVWF 0xFFA, ACCESS
11976  0009     TBLRD*+
11978  50F5     MOVF 0xFF5, W, ACCESS
1197A  6EFD     MOVWF 0xFFD, ACCESS
1197C  0009     TBLRD*+
1197E  50F5     MOVF 0xFF5, W, ACCESS
11980  6EFE     MOVWF 0xFFE, ACCESS
11982  0009     TBLRD*+
11984  50F5     MOVF 0xFF5, W, ACCESS
11986  6EFF     MOVWF 0xFFF, ACCESS
11988  50FA     MOVF 0xFFA, W, ACCESS
1198A  0012     RETURN 0
1198C  0900     IORLW 0x0
1198E  B4D8     BTFSC 0xFD8, 2, ACCESS
11990  D08D     BRA 0x1AAC
1021:                          if (m.len > 0) {
11992  0106     MOVLB 0x6
11994  51E2     MOVF 0xE2, W, BANKED
11996  B4D8     BTFSC 0xFD8, 2, ACCESS
11998  D089     BRA 0x1AAC
1022:                              showStatus(STATUS_MESSAGE_RECEIVED);
1199A  0E07     MOVLW 0x7
1199C  ECCD     CALL 0x1379A, 0
1199E  F09B     NOP
1023:                              handled = APP_preProcessMessage(&m); // Call App to check for any opcodes to be handled. 
119A0  0EE2     MOVLW 0xE2
119A2  6E20     MOVWF 0x20, ACCESS
119A4  0E06     MOVLW 0x6
119A6  6E21     MOVWF 0x21, ACCESS
119A8  EC26     CALL 0x12E4C, 0
119AA  F097     NOP
119AC  0106     MOVLB 0x6
119AE  6FE0     MOVWF 0xE0, BANKED
1024:                              if (handled == NOT_PROCESSED) {
119B0  51E0     MOVF 0xE0, W, BANKED
119B2  A4D8     BTFSS 0xFD8, 2, ACCESS
119B4  D07B     BRA 0x1AAC
1025:                                  for (i=0; i<NUM_SERVICES; i++) {
119B6  0E00     MOVLW 0x0
119B8  6FE1     MOVWF 0xE1, BANKED
1026:                                      if ((services[i] != NULL) && (services[i]->processMessage != NULL)) {
119BA  51E1     MOVF 0xE1, W, BANKED
119BC  0D02     MULLW 0x2
119BE  0E23     MOVLW 0x23
119C0  24F3     ADDWF 0xFF3, W, ACCESS
119C2  6EF6     MOVWF 0xFF6, ACCESS
119C4  0EFF     MOVLW 0xFF
119C6  20F4     ADDWFC 0xFF4, W, ACCESS
119C8  6EF7     MOVWF 0xFF7, ACCESS
119CA  6AF8     CLRF 0xFF8, ACCESS
119CC  0E00     MOVLW 0x0
119CE  22F8     ADDWFC 0xFF8, F, ACCESS
119D0  0009     TBLRD*+
119D2  50F5     MOVF 0xFF5, W, ACCESS
119D4  0009     TBLRD*+
119D6  10F5     IORWF 0xFF5, W, ACCESS
119D8  B4D8     BTFSC 0xFD8, 2, ACCESS
119DA  D058     BRA 0x1A8C
119DC  51E1     MOVF 0xE1, W, BANKED
119DE  0D02     MULLW 0x2
119E0  0E23     MOVLW 0x23
119E2  24F3     ADDWF 0xFF3, W, ACCESS
119E4  6EF6     MOVWF 0xFF6, ACCESS
119E6  0EFF     MOVLW 0xFF
119E8  20F4     ADDWFC 0xFF4, W, ACCESS
119EA  6EF7     MOVWF 0xFF7, ACCESS
119EC  6AF8     CLRF 0xFF8, ACCESS
119EE  0E00     MOVLW 0x0
119F0  22F8     ADDWFC 0xFF8, F, ACCESS
119F2  0009     TBLRD*+
119F4  C4F5     MOVFF TABLAT, 0x54F
119F6  F54F     NOP
119F8  0009     TBLRD*+
119FA  C4F5     MOVFF TABLAT, 0x550
119FC  F550     NOP
119FE  0E08     MOVLW 0x8
11A00  264F     ADDWF 0x4F, F, ACCESS
11A02  0E00     MOVLW 0x0
11A04  2250     ADDWFC 0x50, F, ACCESS
11A06  C54F     MOVFF 0x54F, TBLPTR
11A08  F4F6     NOP
11A0A  C550     MOVFF 0x550, TBLPTRH
11A0C  F4F7     NOP
11A0E  0E00     MOVLW 0x0
11A10  6EF8     MOVWF 0xFF8, ACCESS
11A12  0009     TBLRD*+
11A14  50F5     MOVF 0xFF5, W, ACCESS
11A16  0009     TBLRD*+
11A18  10F5     IORWF 0xFF5, W, ACCESS
11A1A  0009     TBLRD*+
11A1C  10F5     IORWF 0xFF5, W, ACCESS
11A1E  B4D8     BTFSC 0xFD8, 2, ACCESS
11A20  D035     BRA 0x1A8C
1027:                                          if (services[i]->processMessage(&m) == PROCESSED) {
11A22  0EE2     MOVLW 0xE2
11A24  6E46     MOVWF NVMDAT, ACCESS
11A26  0E06     MOVLW 0x6
11A28  6E47     MOVWF NVMDATH, ACCESS
11A2A  51E1     MOVF 0xE1, W, BANKED
11A2C  0D02     MULLW 0x2
11A2E  0E23     MOVLW 0x23
11A30  24F3     ADDWF 0xFF3, W, ACCESS
11A32  6EF6     MOVWF 0xFF6, ACCESS
11A34  0EFF     MOVLW 0xFF
11A36  20F4     ADDWFC 0xFF4, W, ACCESS
11A38  6EF7     MOVWF 0xFF7, ACCESS
11A3A  6AF8     CLRF 0xFF8, ACCESS
11A3C  0E00     MOVLW 0x0
11A3E  22F8     ADDWFC 0xFF8, F, ACCESS
11A40  0009     TBLRD*+
11A42  C4F5     MOVFF TABLAT, 0x54F
11A44  F54F     NOP
11A46  0009     TBLRD*+
11A48  C4F5     MOVFF TABLAT, 0x550
11A4A  F550     NOP
11A4C  0E08     MOVLW 0x8
11A4E  264F     ADDWF 0x4F, F, ACCESS
11A50  0E00     MOVLW 0x0
11A52  2250     ADDWFC 0x50, F, ACCESS
11A54  C54F     MOVFF 0x54F, TBLPTR
11A56  F4F6     NOP
11A58  C550     MOVFF 0x550, TBLPTRH
11A5A  F4F7     NOP
11A5C  0E00     MOVLW 0x0
11A5E  6EF8     MOVWF 0xFF8, ACCESS
11A60  D801     RCALL 0x1A64
11A62  D00D     BRA 0x1A7E
11A64  0005     PUSH
11A66  6EFA     MOVWF 0xFFA, ACCESS
11A68  0009     TBLRD*+
11A6A  50F5     MOVF 0xFF5, W, ACCESS
11A6C  6EFD     MOVWF 0xFFD, ACCESS
11A6E  0009     TBLRD*+
11A70  50F5     MOVF 0xFF5, W, ACCESS
11A72  6EFE     MOVWF 0xFFE, ACCESS
11A74  0009     TBLRD*+
11A76  50F5     MOVF 0xFF5, W, ACCESS
11A78  6EFF     MOVWF 0xFFF, ACCESS
11A7A  50FA     MOVF 0xFFA, W, ACCESS
11A7C  0012     RETURN 0
11A7E  06E8     DECF 0xFE8, F, ACCESS
11A80  A4D8     BTFSS 0xFD8, 2, ACCESS
11A82  D004     BRA 0x1A8C
1028:                                              handled = PROCESSED;
11A84  0E01     MOVLW 0x1
11A86  0106     MOVLB 0x6
11A88  6FE0     MOVWF 0xE0, BANKED
1029:                                              break;
11A8A  D005     BRA 0x1A96
1030:                                          }
1031:                                      }
1032:                                  }
11A8C  0106     MOVLB 0x6
11A8E  2BE1     INCF 0xE1, F, BANKED
11A90  0E08     MOVLW 0x8
11A92  65E1     CPFSGT 0xE1, BANKED
11A94  D792     BRA 0x19BA
1033:                                  if (handled == NOT_PROCESSED) {     // Call App to check for any opcodes to be handled. 
11A96  51E0     MOVF 0xE0, W, BANKED
11A98  A4D8     BTFSS 0xFD8, 2, ACCESS
11A9A  D008     BRA 0x1AAC
1034:                                      handled = APP_postProcessMessage(&m);
11A9C  0EE2     MOVLW 0xE2
11A9E  6E02     MOVWF ___rparam_used, ACCESS
11AA0  0E06     MOVLW 0x6
11AA2  6E03     MOVWF __activetblptr, ACCESS
11AA4  EC4D     CALL 0x1629A, 0
11AA6  F0B1     NOP
11AA8  0106     MOVLB 0x6
11AAA  6FE0     MOVWF 0xE0, BANKED
1035:                                  }
1036:                              }
1037:                          }
1038:                      }
1039:                  }
1040:              }
1041:              if (handled) {
11AAC  0106     MOVLB 0x6
11AAE  51E0     MOVF 0xE0, W, BANKED
11AB0  B4D8     BTFSC 0xFD8, 2, ACCESS
11AB2  0012     RETURN 0
1042:                  mnsDiagnostics[MNS_DIAGNOSTICS_RXMESS].asUint++;
11AB4  0105     MOVLB 0x5
11AB6  4BC3     INFSNZ 0xC3, F, BANKED
11AB8  2BC4     INCF 0xC4, F, BANKED
1043:                  showStatus(STATUS_MESSAGE_ACTED);
11ABA  0E08     MOVLW 0x8
11ABC  ECCD     CALL 0x1379A, 0
11ABE  F09B     NOP
1044:              }
1045:          }
11AC0  0012     RETURN 0
1046:          
1047:          #if defined(_18F66K80_FAMILY_)
1048:          /**
1049:           * Call each service's high priority interrupt service routine.
1050:           * VLCB function to handle high priority interrupts. A service wanting 
1051:           * to use interrupts should enable the interrupts in hardware and then provide 
1052:           * a lowIsr function. Care must to taken to ensure that the cause of the 
1053:           * interrupt is cleared within the ISR and that minimum time is spent in the 
1054:           * ISR. It is preferable to set a flag within the ISR and then perform longer
1055:           * processing within poll().
1056:           */
1057:          static void highIsr(void) {
1058:              uint8_t i;
1059:              
1060:              for (i=0; i<NUM_SERVICES; i++) {
1061:                  if ((services[i] != NULL) && (services[i]->highIsr != NULL)) {
1062:                      services[i]->highIsr();
1063:                  }
1064:              }
1065:              APP_highIsr();
1066:          }
1067:          
1068:          /**
1069:           * Call each service's low priority interrupt service routine.
1070:           * VLCB function to handle low priority interrupts. A service wanting 
1071:           * to use interrupts should enable the interrupts in hardware and then provide 
1072:           * a lowIsr function. Care must to taken to ensure that the cause of the 
1073:           * interrupt is cleared within the ISR and that minimum time is spent in the 
1074:           * ISR. It is preferable to set a flag within the ISR and then perform longer
1075:           * processing within poll().
1076:           */
1077:          static void lowIsr(void) {
1078:              uint8_t i;
1079:              
1080:              for (i=0; i<NUM_SERVICES; i++) {
1081:                  if ((services[i] != NULL) && (services[i]->lowIsr != NULL)) {
1082:                      services[i]->lowIsr();
1083:                  }
1084:              }
1085:              APP_lowIsr();
1086:          }
1087:          #endif
1088:          
1089:          /*
1090:           * Checks that the required number of message bytes are present.
1091:           * @param m the message to be checked
1092:           * @param needed the number of bytes within the message needed including the opc
1093:           * @param service he service making the test
1094:           * @return PROCESSED if it is an invalid message and should not be processed further
1095:           */
1096:          Processed checkLen(Message * m, uint8_t needed, uint8_t service) {
1097:              if (m->len < needed) {
14B4A  C52B     MOVFF opc, FSR2
14B4C  F4D9     NOP
14B4E  C52C     MOVFF opc, FSR2H
14B50  F4DA     NOP
14B52  502D     MOVF 0x2D, W, ACCESS
14B54  5CDE     SUBWF 0xFDE, W, ACCESS
14B56  B0D8     BTFSC 0xFD8, 0, ACCESS
14B58  D030     BRA 0x4BBA
1098:          #ifdef VLCB_GRSP
1099:                  if (m->len > 2) {
14B5A  C52B     MOVFF opc, FSR2
14B5C  F4D9     NOP
14B5E  C52C     MOVFF opc, FSR2H
14B60  F4DA     NOP
14B62  0E02     MOVLW 0x2
14B64  64DF     CPFSGT 0xFDF, ACCESS
14B66  D027     BRA 0x4BB6
1100:                      if ((m->bytes[0] == nn.bytes.hi) && (m->bytes[1] == nn.bytes.lo)) {
14B68  EE20     LFSR 2, 0x2
14B6A  F002     NOP
14B6C  502B     MOVF 0x2B, W, ACCESS
14B6E  26D9     ADDWF 0xFD9, F, ACCESS
14B70  502C     MOVF 0x2C, W, ACCESS
14B72  22DA     ADDWFC 0xFDA, F, ACCESS
14B74  50DE     MOVF 0xFDE, W, ACCESS
14B76  1854     XORWF 0x54, W, ACCESS
14B78  A4D8     BTFSS 0xFD8, 2, ACCESS
14B7A  D01D     BRA 0x4BB6
14B7C  EE20     LFSR 2, 0x3
14B7E  F003     NOP
14B80  502B     MOVF 0x2B, W, ACCESS
14B82  26D9     ADDWF 0xFD9, F, ACCESS
14B84  502C     MOVF 0x2C, W, ACCESS
14B86  22DA     ADDWFC 0xFDA, F, ACCESS
14B88  5053     MOVF 0x53, W, ACCESS
14B8A  18DE     XORWF 0xFDE, W, ACCESS
14B8C  A4D8     BTFSS 0xFD8, 2, ACCESS
14B8E  D013     BRA 0x4BB6
1101:                          sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, m->opc, service, CMDERR_INV_CMD);
14B90  C554     MOVFF 0x554, data1
14B92  F525     NOP
14B94  C553     MOVFF nn, data2
14B96  F526     NOP
14B98  EE20     LFSR 2, 0x1
14B9A  F001     NOP
14B9C  502B     MOVF 0x2B, W, ACCESS
14B9E  26D9     ADDWF 0xFD9, F, ACCESS
14BA0  502C     MOVF 0x2C, W, ACCESS
14BA2  22DA     ADDWFC 0xFDA, F, ACCESS
14BA4  50DF     MOVF 0xFDF, W, ACCESS
14BA6  6E27     MOVWF 0x27, ACCESS
14BA8  C52E     MOVFF service, data4
14BAA  F528     NOP
14BAC  0E01     MOVLW 0x1
14BAE  6E29     MOVWF 0x29, ACCESS
14BB0  0EAF     MOVLW 0xAF
14BB2  EC7D     CALL 0x15EFA, 0
14BB4  F0AF     NOP
1102:                      }
1103:                  }
1104:          #endif
1105:                  return PROCESSED;
14BB6  0E01     MOVLW 0x1
14BB8  0012     RETURN 0
1106:              }
1107:              return NOT_PROCESSED;
14BBA  0E00     MOVLW 0x0
1108:          }
14BBC  0012     RETURN 0
1109:          
1110:          /////////////////////////////////////////////
1111:          // Message handling functions
1112:          /////////////////////////////////////////////
1113:          
1114:          /*
1115:           * Test whether the given opc relates to an event.
1116:           * @param opc the opcode
1117:           */
1118:          Boolean isEvent(uint8_t opc) {
1609A  6E03     MOVWF __activetblptr, ACCESS
1119:              return (((opc & EVENT_SET_MASK) == EVENT_SET_MASK) && ((~opc & EVENT_CLR_MASK)== EVENT_CLR_MASK)) ? TRUE : FALSE;
1609C  0E00     MOVLW 0x0
1609E  6E02     MOVWF ___rparam_used, ACCESS
160A0  5003     MOVF __activetblptr, W, ACCESS
160A2  0B90     ANDLW 0x90
160A4  0A90     XORLW 0x90
160A6  A4D8     BTFSS 0xFD8, 2, ACCESS
160A8  D008     BRA 0x60BA
160AA  5003     MOVF __activetblptr, W, ACCESS
160AC  0AFF     XORLW 0xFF
160AE  0B06     ANDLW 0x6
160B0  0A06     XORLW 0x6
160B2  A4D8     BTFSS 0xFD8, 2, ACCESS
160B4  D002     BRA 0x60BA
160B6  0E01     MOVLW 0x1
160B8  6E02     MOVWF ___rparam_used, ACCESS
160BA  5002     MOVF ___rparam_used, W, ACCESS
1120:          }
160BC  0012     RETURN 0
1121:          
1122:          /*
1123:           * Send a message with just OPC.
1124:           * @param opc opcode
1125:           */
1126:          void sendMessage0(VlcbOpCodes opc){
1127:              sendMessage(opc, 1, 0,0,0,0,0,0,0);
1128:          }
1129:          
1130:          /*
1131:           * Send a message with OPC and 1 data byte.
1132:           * @param opc opcode
1133:           * @param data1 data byte
1134:           */
1135:          void sendMessage1(VlcbOpCodes opc, uint8_t data1){
1136:              sendMessage(opc, 2, data1, 0,0,0,0,0,0);
1137:          }
1138:          
1139:          /*
1140:           * Send a message with OPC and 2 data bytes.
1141:           * @param opc opcode
1142:           * @param data1 data byte 1
1143:           * @param data2 data byte 2
1144:           */
1145:          void sendMessage2(VlcbOpCodes opc, uint8_t data1, uint8_t data2){
15EA6  6E27     MOVWF 0x27, ACCESS
1146:              sendMessage(opc, 3, data1, data2, 0,0,0,0,0);
15EA8  0E03     MOVLW 0x3
15EAA  6E1C     MOVWF 0x1C, ACCESS
15EAC  C525     MOVFF data1, data1
15EAE  F51D     NOP
15EB0  C526     MOVFF data2, data2
15EB2  F51E     NOP
15EB4  0E00     MOVLW 0x0
15EB6  6E1F     MOVWF 0x1F, ACCESS
15EB8  0E00     MOVLW 0x0
15EBA  6E20     MOVWF 0x20, ACCESS
15EBC  0E00     MOVLW 0x0
15EBE  6E21     MOVWF 0x21, ACCESS
15EC0  0E00     MOVLW 0x0
15EC2  6E22     MOVWF 0x22, ACCESS
15EC4  0E00     MOVLW 0x0
15EC6  6E23     MOVWF 0x23, ACCESS
15EC8  5027     MOVF 0x27, W, ACCESS
15ECA  EC7A     CALL 0x148F4, 0
15ECC  F0A4     NOP
1147:          }
15ECE  0012     RETURN 0
1148:          
1149:          /*
1150:           * Send a message with OPC and 3 data bytes.
1151:           * @param opc opcode
1152:           * @param data1 data byte 1
1153:           * @param data2 data byte 2
1154:           * @param data3 data byte 3
1155:           */
1156:          void sendMessage3(VlcbOpCodes opc, uint8_t data1, uint8_t data2, uint8_t data3) {
15E7C  6E28     MOVWF 0x28, ACCESS
1157:              sendMessage(opc, 4, data1, data2, data3, 0,0,0,0);
15E7E  0E04     MOVLW 0x4
15E80  6E1C     MOVWF 0x1C, ACCESS
15E82  C525     MOVFF data1, data1
15E84  F51D     NOP
15E86  C526     MOVFF data2, data2
15E88  F51E     NOP
15E8A  C527     MOVFF data3, data3
15E8C  F51F     NOP
15E8E  0E00     MOVLW 0x0
15E90  6E20     MOVWF 0x20, ACCESS
15E92  0E00     MOVLW 0x0
15E94  6E21     MOVWF 0x21, ACCESS
15E96  0E00     MOVLW 0x0
15E98  6E22     MOVWF 0x22, ACCESS
15E9A  0E00     MOVLW 0x0
15E9C  6E23     MOVWF 0x23, ACCESS
15E9E  5028     MOVF 0x28, W, ACCESS
15EA0  EC7A     CALL 0x148F4, 0
15EA2  F0A4     NOP
1158:          }
15EA4  0012     RETURN 0
1159:          
1160:          /*
1161:           * Send a message with OPC and 4 data bytes.
1162:           * @param opc opcode
1163:           * @param data1 data byte 1
1164:           * @param data2 data byte 2
1165:           * @param data3 data byte 3
1166:           * @param data4 data byte 4
1167:           */
1168:          void sendMessage4(VlcbOpCodes opc, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4){
15F24  6E29     MOVWF 0x29, ACCESS
1169:              sendMessage(opc, 5, data1, data2, data3, data4, 0,0,0);
15F26  0E05     MOVLW 0x5
15F28  6E1C     MOVWF 0x1C, ACCESS
15F2A  C525     MOVFF data1, data1
15F2C  F51D     NOP
15F2E  C526     MOVFF data2, data2
15F30  F51E     NOP
15F32  C527     MOVFF data3, data3
15F34  F51F     NOP
15F36  C528     MOVFF data4, data4
15F38  F520     NOP
15F3A  0E00     MOVLW 0x0
15F3C  6E21     MOVWF 0x21, ACCESS
15F3E  0E00     MOVLW 0x0
15F40  6E22     MOVWF 0x22, ACCESS
15F42  0E00     MOVLW 0x0
15F44  6E23     MOVWF 0x23, ACCESS
15F46  5029     MOVF 0x29, W, ACCESS
15F48  EC7A     CALL 0x148F4, 0
15F4A  F0A4     NOP
1170:          }
15F4C  0012     RETURN 0
1171:          
1172:          /*
1173:           * Send a message with OPC and 5 data bytes.
1174:           * @param opc opcode
1175:           * @param data1 data byte 1
1176:           * @param data2 data byte 2
1177:           * @param data3 data byte 3
1178:           * @param data4 data byte 4
1179:           * @param data5 data byte 5
1180:           */
1181:          void sendMessage5(VlcbOpCodes opc, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4, uint8_t data5) {
15EFA  6E2A     MOVWF 0x2A, ACCESS
1182:              sendMessage(opc, 6, data1, data2, data3, data4, data5, 0,0);
15EFC  0E06     MOVLW 0x6
15EFE  6E1C     MOVWF 0x1C, ACCESS
15F00  C525     MOVFF data1, data1
15F02  F51D     NOP
15F04  C526     MOVFF data2, data2
15F06  F51E     NOP
15F08  C527     MOVFF data3, data3
15F0A  F51F     NOP
15F0C  C528     MOVFF data4, data4
15F0E  F520     NOP
15F10  C529     MOVFF data5, data5
15F12  F521     NOP
15F14  0E00     MOVLW 0x0
15F16  6E22     MOVWF 0x22, ACCESS
15F18  0E00     MOVLW 0x0
15F1A  6E23     MOVWF 0x23, ACCESS
15F1C  502A     MOVF 0x2A, W, ACCESS
15F1E  EC7A     CALL 0x148F4, 0
15F20  F0A4     NOP
1183:          }
15F22  0012     RETURN 0
1184:          
1185:          /*
1186:           * Send a message with OPC and 6 data bytes.
1187:           * @param opc opcode
1188:           * @param data1 data byte 1
1189:           * @param data2 data byte 2
1190:           * @param data3 data byte 3
1191:           * @param data4 data byte 4
1192:           * @param data5 data byte 5
1193:           * @param data6 data byte 6
1194:           */
1195:          void sendMessage6(VlcbOpCodes opc, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint8_t data6) {
15E52  6E2B     MOVWF 0x2B, ACCESS
1196:              sendMessage(opc, 7, data1, data2, data3, data4, data5, data6,0);
15E54  0E07     MOVLW 0x7
15E56  6E1C     MOVWF 0x1C, ACCESS
15E58  C525     MOVFF data1, data1
15E5A  F51D     NOP
15E5C  C526     MOVFF data2, data2
15E5E  F51E     NOP
15E60  C527     MOVFF data3, data3
15E62  F51F     NOP
15E64  C528     MOVFF data4, data4
15E66  F520     NOP
15E68  C529     MOVFF data5, data5
15E6A  F521     NOP
15E6C  C52A     MOVFF data6, data6
15E6E  F522     NOP
15E70  0E00     MOVLW 0x0
15E72  6E23     MOVWF 0x23, ACCESS
15E74  502B     MOVF 0x2B, W, ACCESS
15E76  EC7A     CALL 0x148F4, 0
15E78  F0A4     NOP
1197:          }
15E7A  0012     RETURN 0
1198:          
1199:          /*
1200:           * Send a message with OPC and 7 data bytes.
1201:           * @param opc opcode
1202:           * @param data1 data byte 1
1203:           * @param data2 data byte 2
1204:           * @param data3 data byte 3
1205:           * @param data4 data byte 4
1206:           * @param data5 data byte 5
1207:           * @param data6 data byte 6
1208:           * @param data7 data byte 7
1209:           */
1210:          void sendMessage7(VlcbOpCodes opc, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint8_t data6, uint8_t data7) {
15ED0  6E2C     MOVWF 0x2C, ACCESS
1211:              sendMessage(opc, 8, data1, data2, data3, data4, data5, data6, data7);
15ED2  0E08     MOVLW 0x8
15ED4  6E1C     MOVWF 0x1C, ACCESS
15ED6  C525     MOVFF data1, data1
15ED8  F51D     NOP
15EDA  C526     MOVFF data2, data2
15EDC  F51E     NOP
15EDE  C527     MOVFF data3, data3
15EE0  F51F     NOP
15EE2  C528     MOVFF data4, data4
15EE4  F520     NOP
15EE6  C529     MOVFF data5, data5
15EE8  F521     NOP
15EEA  C52A     MOVFF data6, data6
15EEC  F522     NOP
15EEE  C52B     MOVFF opc, data7
15EF0  F523     NOP
15EF2  502C     MOVF 0x2C, W, ACCESS
15EF4  EC7A     CALL 0x148F4, 0
15EF6  F0A4     NOP
1212:          }
15EF8  0012     RETURN 0
1213:          
1214:          /*
1215:           * Send a message of variable length with OPC and up to 7 data bytes.
1216:           * @param opc
1217:           * @param len
1218:           * @param data1
1219:           * @param data2
1220:           * @param data3
1221:           * @param data4
1222:           * @param data5
1223:           * @param data6
1224:           * @param data7
1225:           */
1226:          void sendMessage(VlcbOpCodes opc, uint8_t len, uint8_t data1, uint8_t data2, uint8_t data3, uint8_t data4, uint8_t data5, uint8_t data6, uint8_t data7) {
148F4  6E24     MOVWF 0x24, ACCESS
1227:              tmpMessage.opc = opc;
148F6  C524     MOVFF opc, 0x6D8
148F8  F6D8     NOP
1228:              tmpMessage.len = len;
148FA  C51C     MOVFF len, tmpMessage
148FC  F6D7     NOP
1229:              tmpMessage.bytes[0] = data1;
148FE  C51D     MOVFF data1, 0x6D9
14900  F6D9     NOP
1230:              tmpMessage.bytes[1] = data2;
14902  C51E     MOVFF data2, 0x6DA
14904  F6DA     NOP
1231:              tmpMessage.bytes[2] = data3;
14906  C51F     MOVFF data3, 0x6DB
14908  F6DB     NOP
1232:              tmpMessage.bytes[3] = data4;
1490A  C520     MOVFF data4, 0x6DC
1490C  F6DC     NOP
1233:              tmpMessage.bytes[4] = data5;
1490E  C521     MOVFF data5, 0x6DD
14910  F6DD     NOP
1234:              tmpMessage.bytes[5] = data6;
14912  C522     MOVFF data6, 0x6DE
14914  F6DE     NOP
1235:              tmpMessage.bytes[6] = data7;
14916  C523     MOVFF data7, 0x6DF
14918  F6DF     NOP
1236:              if (transport != NULL) {
1491A  0105     MOVLB 0x5
1491C  519B     MOVF 0x9B, W, BANKED
1491E  119C     IORWF 0x9C, W, BANKED
14920  B4D8     BTFSC 0xFD8, 2, ACCESS
14922  0012     RETURN 0
1237:                  if (transport->sendMessage != NULL) {
14924  C59B     MOVFF transport, TBLPTR
14926  F4F6     NOP
14928  C59C     MOVFF 0x59C, TBLPTRH
1492A  F4F7     NOP
1492C  0E00     MOVLW 0x0
1492E  6EF8     MOVWF 0xFF8, ACCESS
14930  0009     TBLRD*+
14932  50F5     MOVF 0xFF5, W, ACCESS
14934  0009     TBLRD*+
14936  10F5     IORWF 0xFF5, W, ACCESS
14938  0009     TBLRD*+
1493A  10F5     IORWF 0xFF5, W, ACCESS
1493C  B4D8     BTFSC 0xFD8, 2, ACCESS
1493E  0012     RETURN 0
1238:                      transport->sendMessage(&tmpMessage);
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
14940  0ED7     MOVLW 0xD7
1239:                  }
1240:              }
1241:          }
1242:          
1243:          /**
1244:           * This is the VLCB application start.
1245:           * Do some initialisation, call the factoryReset() if necessary, call the powerUp()
1246:           * service routines. Then call the Application's setup() before entering the main loop
1247:           * which calls the Application's loop() and each service poll().
1248:           */
1249:          void main(void) {
1250:              uint8_t i;
1251:              
1252:              /*
1253:               * Set up the processor clock
1254:               */
1255:          #if defined(_18F66K80_FAMILY_)
1256:              OSCTUNEbits.PLLEN = 1;      // enable the Phase Locked Loop x4
1257:          #endif
1258:          #if defined(_18FXXQ83_FAMILY_)
1259:              OSCCON1bits.NOSC = 2;   // EXTOSC and 4 x PLL
15008  0100     MOVLB 0x0
1500A  51AD     MOVF OSCCON1, W, BANKED
1500C  0B8F     ANDLW 0x8F
1500E  0920     IORLW 0x20
15010  6FAD     MOVWF OSCCON1, BANKED
1260:              OSCCON1bits.NDIV = 0;   // Divider = 1 (no divide)
15012  0EF0     MOVLW 0xF0
15014  17AD     ANDWF OSCCON1, F, BANKED
1261:                  /* Note PLLEN is used by the PIC18F27Q83 to control whether peripherals
1262:                   * Use the Ext clock or the 4 x PLL.
1263:                   * Here we leave PLLEN=0 so peripherals do NOT use the PLL.
1264:                   */
1265:          #endif
1266:              
1267:              /*
1268:               * Set up the interrupts
1269:               */
1270:          #if defined(_18F66K80_FAMILY_)
1271:              RCONbits.IPEN = 1;  // enable interrupt priority
1272:          #endif
1273:          #if defined(_18FXXQ83_FAMILY_)
1274:              // Set up the interrupt vector table
1275:              IVTBASEU = IVT_BASE_U;
15016  0E00     MOVLW 0x0
15018  0104     MOVLB 0x4
1501A  6F5F     MOVWF 0x5F, BANKED
1276:              IVTBASEH = IVT_BASE_H;
1501C  0E09     MOVLW 0x9
1501E  6F5E     MOVWF 0x5E, BANKED
1277:              IVTBASEL = IVT_BASE_L;
15020  0E00     MOVLW 0x0
15022  6F5D     MOVWF 0x5D, BANKED
1278:              
1279:              IVTLOCK = 0x55;
15024  0E55     MOVLW 0x55
15026  6F59     MOVWF 0x59, BANKED
1280:              IVTLOCK = 0xAA;
15028  0EAA     MOVLW 0xAA
1502A  6F59     MOVWF 0x59, BANKED
1281:              IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
1502C  8159     BSF 0x59, 0, BANKED
1282:          #endif
1283:              
1284:          #if defined(_18FXXQ83_FAMILY_)
1285:              /*
1286:               * Set up the PPS
1287:               */
1288:              // defaults are fine but PPS is left unlocked to allow Services and App to change if necessary.
1289:          #endif
1290:          
1291:               
1292:              // init the romops ready for flash writes
1293:              initRomOps();
1502E  ECC9     CALL 0x16192, 0
15030  F0B0     NOP
1294:              
1295:              if (readNVM(VERSION_NVM_TYPE, VERSION_ADDRESS) != APP_NVM_VERSION) {
15032  0EFA     MOVLW 0xFA
15034  6E08     MOVWF 0x8, ACCESS
15036  0E03     MOVLW 0x3
15038  6E09     MOVWF 0x9, ACCESS
1503A  0E00     MOVLW 0x0
1503C  6E0A     MOVWF 0xA, ACCESS
1503E  0E00     MOVLW 0x0
15040  ECF3     CALL 0x151E6, 0
15042  F0A8     NOP
15044  0408     DECF 0x8, W, ACCESS
15046  1009     IORWF 0x9, W, ACCESS
15048  A4D8     BTFSS 0xFD8, 2, ACCESS
1296:                  factoryReset();
1504A  EC45     CALL 0x1388A, 0
1504C  F09C     NOP
1297:              }
1298:              
1299:              // initialise the services
1300:              powerUp();
1504E  EC98     CALL 0x13B30, 0
15050  F09D     NOP
1301:              
1302:              // Check for PB held down at power up
1303:              bothEi();
15052  8ED6     BSF 0xFD6, 7, ACCESS
1304:              checkPowerOnPb();
15054  EC5D     CALL 0x154BA, 0
15056  F0AA     NOP
1305:              
1306:              // call the application's init 
1307:              bothDi();
15058  9ED6     BCF 0xFD6, 7, ACCESS
1308:              setup();
1505A  EC71     CALL 0x13CE2, 0
1505C  F09E     NOP
1309:              
1310:              // enable the interrupts and ready to go
1311:              bothEi();
1505E  8ED6     BSF 0xFD6, 7, ACCESS
1312:              while(1) {
1313:                  // poll the services as quickly as possible.
1314:                  // up to service to ignore the polls it doesn't need.
1315:                  poll();
15060  ECCB     CALL 0x11796, 0
15062  F08B     NOP
1316:                  loop();
15064  EC07     CALL 0x13C0E, 0
15064  EC07     CALL 0x13C0E, 0
15064  EC07     CALL 0x13C0E, 0
1317:              }
1318:          }
1319:          
1320:          
1321:          #if defined(_18F66K80_FAMILY_)
1322:          /*
1323:           * High priority Interrupt Service Routine.
1324:           */ 
1325:          void __interrupt(high_priority) __section("mainSec") isrHigh() {
1326:              highIsr();
1327:          }
1328:          
1329:          /*
1330:           * Low priority Interrupt Service Routine handler.
1331:           */
1332:          void __interrupt(low_priority) __section("mainSec") isrLow() {
1333:              lowIsr();
1334:          }
1335:          #endif
1336:          
1337:          #if defined(_18FXXQ83_FAMILY_)
1338:          void __interrupt(irq(default), base(IVT_BASE)) DEFAULT_ISR(void)
1339:          {
1340:          // Unhandled interrupts go here
1341:          }
162A8  0011     RETFIE 1
1342:          #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/timedResponse.c  -------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:               License summary:
11:                You are free to:
12:                  Share, copy and redistribute the material in any medium or format
13:                  Adapt, remix, transform, and build upon the material
14:                The licensor cannot revoke these freedoms as long as you follow the license terms.
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
19:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
20:                              your contributions under the same license as the original.
21:                No additional restrictions : You may not apply legal terms or technological measures that
22:                                              legally restrict others from doing anything the license permits.
23:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
24:            **************************************************************************************************************
25:            	
26:            */ 
27:            
28:            #include <xc.h>
29:            #include "vlcb.h"
30:            #include "module.h"
31:            #include "timedResponse.h"
32:            #include "nvm.h"
33:            
34:            /**
35:             * @author Ian Hogg  Created 8 December 2021
36:             * @author Ian Hogg significant updates for VLCB and XC8 Dec 2022
37:             * @date Dec 2022
38:             * 
39:             */ 
40:            /**
41:             * @file
42:             * @brief
43:             * TimedResponse records that a sequence of VLCB messages are to be sent at
44:             * a slow rate to allow receivers of these messages to process them.
45:             * 
46:             * @details
47:             * startTimedResponse() is to be called to start the transmission. A callback
48:             * function is provided and that function is called with an incrementing step 
49:             * value. The function must return a result to indicate that it has finished or 
50:             * that it still has more work to do.
51:             * 
52:             * Only one set of timedResponse can be running at a time. If a second 
53:             * timedResponse is started then the first will be abandoned and replaced
54:             * by the new one.
55:             * 
56:             * Call initTimedResponse() before other TimedResponse processing. 
57:             * This will set the current response set to be None.
58:             * Call pollTimedResponse() on a regular basis which will do the work needed for 
59:             * the next step and increments the step counter.
60:             * 
61:             * To start send a set of timed responses call startTimedResponse specifying
62:             * the callback.
63:             */
64:            static uint8_t timedResponseServiceIndex;
65:            static uint8_t timedResponseAllServicesFlag;
66:            static uint8_t timedResponseType;
67:            static uint8_t timedResponseStep;
68:            static TimedResponseResult (*timedResponseCallback)(uint8_t type, uint8_t serviceIndex, uint8_t step);
69:            
70:            
71:            /**
72:             * Initialise the timedResponse functionality.
73:             */
74:            void initTimedResponse(void) {
75:                timedResponseType = TIMED_RESPONSE_NONE;
16278  0105     MOVLB 0x5
1627A  69A1     SETF 0xA1, BANKED
76:            }
1627C  0012     RETURN 0
77:            
78:            /*
79:             * Request callbacks at a regular rate.
80:             * 
81:             * @param type  indicate to the callback function the type of the callback.
82:             * @param serviceIndex passed to the user's callback function. 1..NUM_SERVICES. If SERVICE_ID_ALL is passed then the callback is repeatedly for each service.
83:             * @param callback the user specific callback function
84:             */
85:            void startTimedResponse(uint8_t type, uint8_t serviceIndex, TimedResponseResult (*callback)(uint8_t type, uint8_t si, uint8_t step)) {
159C4  6E0A     MOVWF 0xA, ACCESS
86:                timedResponseType = type;
159C6  C50A     MOVFF index, timedResponseType
159C8  F5A1     NOP
87:                if (serviceIndex == SERVICE_ID_ALL) { 
159CA  5006     MOVF 0x6, W, ACCESS
159CC  A4D8     BTFSS 0xFD8, 2, ACCESS
159CE  D005     BRA 0x59DA
88:                    // go through all the services
89:                    timedResponseAllServicesFlag = 1;
159D0  0E01     MOVLW 0x1
159D2  0105     MOVLB 0x5
159D4  6FA2     MOVWF 0xA2, BANKED
90:                    timedResponseServiceIndex = 0;
159D6  0E00     MOVLW 0x0
159D8  D00C     BRA 0x59F2
91:                } else {
92:                    timedResponseAllServicesFlag = 0;
159DA  0E00     MOVLW 0x0
159DC  0105     MOVLB 0x5
159DE  6FA2     MOVWF 0xA2, BANKED
93:                    if ((serviceIndex < 1) || (serviceIndex > NUM_SERVICES)) {
159E0  5006     MOVF 0x6, W, ACCESS
159E2  B4D8     BTFSC 0xFD8, 2, ACCESS
159E4  D003     BRA 0x59EC
159E6  0E09     MOVLW 0x9
159E8  6406     CPFSGT 0x6, ACCESS
159EA  D002     BRA 0x59F0
94:                        // if we don't have the requested service then don't do anything
95:                        timedResponseType = TIMED_RESPONSE_NONE;
159EC  69A1     SETF 0xA1, BANKED
96:                        return;
159EE  0012     RETURN 0
97:                    }
98:                    timedResponseServiceIndex = (uint8_t)serviceIndex-1;
159F0  0406     DECF 0x6, W, ACCESS
159F2  6FA3     MOVWF 0xA3, BANKED
99:                }
100:               timedResponseStep = 0;
159F4  0E00     MOVLW 0x0
159F6  6FA0     MOVWF 0xA0, BANKED
101:               timedResponseCallback = callback;
159F8  C507     MOVFF i, timedResponseCallback
159FA  F590     NOP
159FC  C508     MOVFF index, 0x591
159FE  F591     NOP
15A00  C509     MOVFF d, 0x592
15A02  F592     NOP
102:           }
15A04  0012     RETURN 0
103:           
104:           /**
105:            * Call regularly to call the user's callback function. Handles the call back 
106:            * function's results to increment the step value and cycle through the services.
107:            */
108:           void pollTimedResponse() {
109:               TimedResponseResult result;
110:               
111:               if (timedResponseType == TIMED_RESPONSE_NONE) {
14876  0105     MOVLB 0x5
14878  29A1     INCF 0xA1, W, BANKED
1487A  B4D8     BTFSC 0xFD8, 2, ACCESS
1487C  0012     RETURN 0
112:                   // no timed responses in progress
113:                   return;
114:               }
115:               if (timedResponseCallback == NULL) {
1487E  5190     MOVF SPI2TCNTH, W, BANKED
14880  1191     IORWF SPI2CON0, W, BANKED
14882  1192     IORWF SPI2CON1, W, BANKED
14884  A4D8     BTFSS 0xFD8, 2, ACCESS
14886  D002     BRA 0x488C
116:                   // no callback defined so finish
117:                   timedResponseType = TIMED_RESPONSE_NONE;
14888  69A1     SETF 0xA1, BANKED
118:                   return;
1488A  0012     RETURN 0
119:               }
120:           
121:               // Now call the callback function
122:               result = (*timedResponseCallback)(timedResponseType, timedResponseServiceIndex, timedResponseStep);
1488C  D801     RCALL 0x4890
1488E  D00F     BRA 0x48AE
14890  0005     PUSH
14892  6EFA     MOVWF 0xFFA, ACCESS
14894  5190     MOVF SPI2TCNTH, W, BANKED
14896  6EFD     MOVWF 0xFFD, ACCESS
14898  5191     MOVF SPI2CON0, W, BANKED
1489A  6EFE     MOVWF 0xFFE, ACCESS
1489C  5192     MOVF SPI2CON1, W, BANKED
1489E  6EFF     MOVWF 0xFFF, ACCESS
148A0  50FA     MOVF 0xFFA, W, ACCESS
148A2  C5A3     MOVFF timedResponseServiceIndex, needed
148A4  F532     NOP
148A6  C5A0     MOVFF timedResponseStep, learn
148A8  F533     NOP
148AA  51A1     MOVF 0xA1, W, BANKED
148AC  0012     RETURN 0
148AE  6E43     MOVWF NVMADR, ACCESS
123:               switch (result) {
148B0  D00F     BRA 0x48D0
124:                   case TIMED_RESPONSE_RESULT_FINISHED:
125:                       // the callback tells us it has finished but lets check if there are other
126:                       // services still to do
127:                       if (timedResponseAllServicesFlag) {
148B2  0105     MOVLB 0x5
148B4  51A2     MOVF 0xA2, W, BANKED
148B6  B4D8     BTFSC 0xFD8, 2, ACCESS
148B8  D7E7     BRA 0x4888
128:                           // move on to next service
129:                           timedResponseServiceIndex++;
148BA  2BA3     INCF 0xA3, F, BANKED
130:                           if (timedResponseServiceIndex >= NUM_SERVICES) {
148BC  0E08     MOVLW 0x8
148BE  65A3     CPFSGT 0xA3, BANKED
148C0  D001     BRA 0x48C4
148C2  D7E2     BRA 0x4888
131:                               // finished all the services
132:                               timedResponseType = TIMED_RESPONSE_NONE;
133:                           } else {
134:                               timedResponseStep = 0;
148C4  0E00     MOVLW 0x0
148C6  6FA0     MOVWF 0xA0, BANKED
148C8  0012     RETURN 0
135:                           }
136:                       } else {
137:                           timedResponseType = TIMED_RESPONSE_NONE;
138:                       }
139:                       break;
140:                   case TIMED_RESPONSE_RESULT_RETRY:
141:                       break;
142:                   case TIMED_RESPONSE_RESULT_NEXT:
143:                       timedResponseStep++;
148CA  0105     MOVLB 0x5
148CC  2BA0     INCF 0xA0, F, BANKED
144:                       break;
148CE  0012     RETURN 0
145:               }
148D0  5043     MOVF NVMADR, W, ACCESS
148D2  6E41     MOVWF NVMCON1, ACCESS
148D4  6A42     CLRF NVMLOCK, ACCESS
148D6  5042     MOVF NVMLOCK, W, ACCESS
148D8  0A00     XORLW 0x0
148DA  A4D8     BTFSS 0xFD8, 2, ACCESS
148DC  0012     RETURN 0
148DE  5041     MOVF NVMCON1, W, ACCESS
148E0  0A00     XORLW 0x0
148E2  B4D8     BTFSC 0xFD8, 2, ACCESS
148E4  D7E6     BRA 0x48B2
148E6  0A01     XORLW 0x1
148E8  B4D8     BTFSC 0xFD8, 2, ACCESS
148EA  0012     RETURN 0
148EC  0A03     XORLW 0x3
148EE  A4D8     BTFSS 0xFD8, 2, ACCESS
148EE  A4D8     BTFSS 0xFD8, 2, ACCESS
148EE  A4D8     BTFSS 0xFD8, 2, ACCESS
146:           }
---  C:/Users/ianwh/github/VLCBlib_PIC/ticktime.c  ------------------------------------------------------
1:             /**
2:              * @copyright Copyright  2007-2010 Microchip Technology Inc.  All rights reserved.
3:              */
4:             /*
5:             * FileName:		TickTime.c
6:             * Dependencies: TickTime.h
7:             * Processor:	PIC18, PIC24, PIC32, dsPIC30, dsPIC33
8:             *               tested with 18F4620, dsPIC33FJ256GP710
9:             * Complier:     Microchip C18 v3.04 or higher
10:            *				Microchip C30 v2.03 or higher	
11:            *               Microchip C32 v1.02 or higher
12:            * Company:	Microchip Technology, Inc.
13:            *
14:            * Copyright and Disclaimer Notice
15:            *
16:            * This module has been derived from the Microchip MLA Symboltime module,
17:            * therefore the Microchip licensing terms apply.
18:            *
19:            * Copyright  2007-2010 Microchip Technology Inc.  All rights reserved.
20:            * Copyright  2015 Pete Brownlow for changes Jan 2015
21:            * Ported to XC8 by Ian Hogg 23/5/2017
22:            *
23:            * Microchip licenses to you the right to use, modify, copy and distribute 
24:            * Software only when embedded on a Microchip microcontroller or digital 
25:            * signal controller and used with a Microchip radio frequency transceiver, 
26:            * which are integrated into your product or third party product (pursuant 
27:            * to the terms in the accompanying license agreement).  
28:            *
29:            * You should refer to the license agreement accompanying this Software for 
30:            * additional information regarding your rights and obligations.
31:            *
32:            * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY 
33:            * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY 
34:            * WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A 
35:            * PARTICULAR PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE 
36:            * LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, 
37:            * CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY 
38:            * DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO 
39:            * ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, 
40:            * LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, 
41:            * TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT 
42:            * NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:            *
44:            *********************************************************************
45:            * File Description:
46:            *   This file implements functions used for smybol timer.
47:            *
48:            * Change History:
49:            *  Rev   Date         Author    Description
50:            *  0.1   11/09/2006   yfy       Initial revision
51:            *  1.0   01/09/2007   yfy       Initial release
52:            *  2.0   4/15/2009    yfy       MiMAC and MiApp revision
53:            *  2.1   6/20/2009    yfy       Add LCD support
54:            *  3.1   5/28/2010    yfy       MiWi DE 3.1
55:            *  4.1   6/3/2011     yfy       MAL v2011-06
56:            *  4.2   15/1/15      pnb       Extracted from MLA as a standalone utility (C18 only at present)
57:             * 4.3   Nov 2022     ih        Ported to XC8 and modified for use by VLCB
58:            ********************************************************************/
59:            /**
60:             * @author Copyright  2007-2010 Microchip Technology Inc.  All rights reserved.
61:             * @author Copyright  2015 Pete Brownlow for changes Jan 2015
62:             * @author Ported to XC8 by Ian Hogg 23/5/2017
63:             * @author Updated for VLCB Ian Hogg Nov 2022
64:             * @date Nov 2022
65:             */
66:            
67:            /**
68:             * @file
69:             * @brief
70:             * Functions to provide timing.
71:             * 
72:             * @details
73:             * Uses 16bit PIC Timer0. Extends this to 32bit using timerExtension which is 
74:             * incremented on timer0 overflow.
75:             * Times are stored as TickValue.
76:             * Functions are provided to measure time since a time value was recorded.
77:             * 
78:             */
79:            
80:            #include <xc.h>
81:            #include "ticktime.h"
82:            #include "module.h"
83:            
84:            /** 
85:             * Variable used to hold the upper bytes of the timeVal. 
86:             * Extends the hardware counter from 16bits to 32bits.
87:             */
88:            volatile uint8_t timerExtension1,timerExtension2;
89:            
90:            /************************ FUNCTIONS ********************************/
91:            
92:            /**
93:             * Initialise the tick timer using the specified interrupt priority.
94:             * Function:         void InitTicker()
95:             *
96:             * TMR0 for PIC18 is configured for calculating the correct symbol times.  
97:             * The timer interrupt is enabled causing the timer roll over calculations.  
98:             * Interrupts are required to be enabled in order to extend the timer to
99:             * 4 bytes in PIC18.  PIC24/dsPIC version do not enable or require interrupts.
100:            */
101:           void initTicker(uint8_t priority) {
152FC  6E03     MOVWF __activetblptr, ACCESS
102:               uint8_t divider, i;
103:           
104:               divider = 0;
152FE  0E00     MOVLW 0x0
15300  6E04     MOVWF __activetblptr, ACCESS
105:               for (i=clkMHz;i>0;i>>=1) // Work out timer prescaler value from clock MHz
15302  0E40     MOVLW 0x40
15304  6E05     MOVWF 0x5, ACCESS
106:                   divider++;
15306  2A04     INCF __activetblptr, F, ACCESS
15308  90D8     BCF 0xFD8, 0, ACCESS
1530A  3205     RRCF 0x5, F, ACCESS
1530C  5005     MOVF 0x5, W, ACCESS
1530E  A4D8     BTFSS 0xFD8, 2, ACCESS
15310  D7FA     BRA 0x5306
107:           
108:           #if defined(_18F66K80_FAMILY_)
109:               TMR_PS = (uint8_t)(0b00000000 | divider);     // Enable clock prescaler on and set prescaler value
110:               TMR_MODE = 0;       // 16 bit mode
111:               TMR_CS = 0;         // Fosc clock source
112:               TMR_H = 0;          // clear the H buffer
113:               TMR_L = 0;          // write the L counter and load the H counter from buffer
114:               TMR_IP = priority;  // set interrupt priority
115:               TMR_IF = 0;         // clear the flag
116:               TMR_IE = 1;         // enable interrupts
117:               TMR_ON = 1;         // start it running
118:           
119:               timerExtension1 = 0;
120:               timerExtension2 = 0;
121:           #elif defined(_18FXXQ83_FAMILY_)
122:               TMR_PS = (uint8_t)(0b00000000 | (divider+1));     // Enable internal clock, prescaler on and set prescaler value
15312  C504     MOVFF s, i
15314  F502     NOP
15316  0E01     MOVLW 0x1
15318  2602     ADDWF ___rparam_used, F, ACCESS
1531A  0103     MOVLB 0x3
1531C  511B     MOVF 0x1B, W, BANKED
1531E  1802     XORWF ___rparam_used, W, ACCESS
15320  0BF0     ANDLW 0xF0
15322  1802     XORWF ___rparam_used, W, ACCESS
15324  6F1B     MOVWF 0x1B, BANKED
123:               TMR_MODE = 1;       // 16 bit mode
15326  891A     BSF 0x1A, 4, BANKED
124:               TMR_CS = 2;         // Fosc/4 clock source
15328  511B     MOVF 0x1B, W, BANKED
1532A  0B1F     ANDLW 0x1F
1532C  0940     IORLW 0x40
1532E  6F1B     MOVWF 0x1B, BANKED
125:               TMR_H = 0;          // clear the H buffer
15330  0E00     MOVLW 0x0
15332  6F19     MOVWF 0x19, BANKED
126:               TMR_L = 0;          // write the L counter and load the H counter from buffer
15334  0E00     MOVLW 0x0
15336  6F18     MOVWF 0x18, BANKED
127:               TMR_IP = (__bit)priority;  // set interrupt priority
15338  A003     BTFSS __activetblptr, 0, ACCESS
1533A  D002     BRA 0x5340
1533C  8F65     BSF PMD5, 7, BANKED
1533E  D002     BRA 0x5344
15340  0103     MOVLB 0x3
15342  9F65     BCF PMD5, 7, BANKED
128:               TMR_IF = 0;         // clear the flag
15344  9EB1     BCF 0xFB1, 7, ACCESS
129:               TMR_IE = 1;         // enable interrupts
15346  8EA1     BSF 0xFA1, 7, ACCESS
130:               TMR_ON = 1;         // start it running
15348  8F1A     BSF 0x1A, 7, BANKED
131:           
132:               timerExtension1 = 0;
1534A  0E00     MOVLW 0x0
1534C  0105     MOVLB 0x5
1534E  6FA5     MOVWF 0xA5, BANKED
133:               timerExtension2 = 0;
15350  0E00     MOVLW 0x0
15352  6FA4     MOVWF 0xA4, BANKED
134:           
135:           #elif defined(__dsPIC30F__) || defined(__dsPIC33F__) || defined(__PIC24F__) || defined(__PIC24FK__) || defined(__PIC24H__)
136:               T2CON = 0b0000000000001000 | CLOCK_DIVIDER_SETTING;
137:               T2CONbits.TON = 1;
138:           #elif defined(__PIC32MX__)
139:               CloseTimer2();
140:               WriteTimer2(0x00);
141:               WriteTimer3(0x00);
142:               WritePeriod3(0xFFFF);
143:               OpenTimer2((T2_ON|T2_32BIT_MODE_ON|CLOCK_DIVIDER_SETTING),0xFFFFFFFF);     
144:           #else
145:               #error "Invalid Processor defines in ticktime.c"
146:           #endif
147:           }
15354  0012     RETURN 0
148:           
149:           
150:           /**
151:            * Return the current tick time.
152:            * PIC18 only: the timer interrupt is disabled for several instruction cycles 
153:            * while the timer value is grabbed.  This is to prevent a rollover from 
154:            * incrementing the timer extenders during the read of their values.
155:            *
156:            * @return the 32bit timer value
157:            */
158:           uint32_t tickGet(void) {
159:               TickValue currentTime;
160:               
161:               //uint8_t failureCounter;
162:               uint8_t IntFlag1;
163:               uint8_t IntFlag2;
164:               
165:               /* zero the byte extension for now*/
166:               currentTime.byte.b2 = 0;
153B0  0E00     MOVLW 0x0
153B2  6E0A     MOVWF 0xA, ACCESS
167:               currentTime.byte.b3 = 0;
153B4  0E00     MOVLW 0x0
153B6  6E0B     MOVWF 0xB, ACCESS
168:               /* disable the timer interrupt to prevent roll over of the lower 16 bits while before/after reading of the extension */
169:               TMR_IE = 0;
153B8  9EA1     BCF 0xFA1, 7, ACCESS
170:               do {
171:                   IntFlag1 = TMR_IF;
153BA  0E00     MOVLW 0x0
153BC  BEB1     BTFSC 0xFB1, 7, ACCESS
153BE  0E01     MOVLW 0x1
153C0  6E07     MOVWF 0x7, ACCESS
172:                   currentTime.byte.b0 = TMR_L;
153C2  C318     MOVFF TMR0L, index
153C4  F508     NOP
173:                   currentTime.byte.b1 = TMR_H;    // PIC latched the H register whist reading the L register. Safe 2 byte read.
153C6  C319     MOVFF TMR0H, d
153C8  F509     NOP
174:                   IntFlag2 = TMR_IF;
153CA  0E00     MOVLW 0x0
153CC  BEB1     BTFSC 0xFB1, 7, ACCESS
153CE  0E01     MOVLW 0x1
153D0  6E06     MOVWF 0x6, ACCESS
175:               } while(IntFlag1 != IntFlag2);  // verify that a rollover didn't happen during getting the counter
153D2  5006     MOVF 0x6, W, ACCESS
153D4  1807     XORWF 0x7, W, ACCESS
153D6  A4D8     BTFSS 0xFD8, 2, ACCESS
153D8  D7F0     BRA 0x53BA
176:           
177:               if( IntFlag1 > 0 ) {         // if a rollover did happen then handle it here instead of in ISR
153DA  5007     MOVF 0x7, W, ACCESS
153DC  B4D8     BTFSC 0xFD8, 2, ACCESS
153DE  D006     BRA 0x53EC
178:                   TMR_IF = 0;
153E0  9EB1     BCF 0xFB1, 7, ACCESS
179:                   timerExtension1++;
153E2  0105     MOVLB 0x5
153E4  2BA5     INCF 0xA5, F, BANKED
180:                   if(timerExtension1 == 0)
153E6  51A5     MOVF 0xA5, W, BANKED
153E8  B4D8     BTFSC 0xFD8, 2, ACCESS
181:                   {
182:                       timerExtension2++;
153EA  2BA4     INCF 0xA4, F, BANKED
183:                   }
184:               }
185:           
186:               /* copy the byte extension */
187:               currentTime.byte.b2 += timerExtension1;
153EC  0105     MOVLB 0x5
153EE  51A5     MOVF 0xA5, W, BANKED
153F0  260A     ADDWF 0xA, F, ACCESS
188:               currentTime.byte.b3 += timerExtension2;
153F2  51A4     MOVF 0xA4, W, BANKED
153F4  260B     ADDWF 0xB, F, ACCESS
189:               
190:               /* re-enable the timer interrupt */
191:               TMR_IE = 1;
153F6  8EA1     BSF 0xFA1, 7, ACCESS
192:               
193:               return currentTime.val;
153F8  C508     MOVFF index, i
153FA  F502     NOP
153FC  C509     MOVFF d, opc
153FE  F503     NOP
15400  C50A     MOVFF index, s
15402  F504     NOP
15404  C50B     MOVFF index, i
15406  F505     NOP
194:           } // tickGet
15408  0012     RETURN 0
195:           
196:           #if defined(_18FXXQ83_FAMILY_)
197:           /**
198:            * The ticktime interrupt service routine. Handles the tickTime overflow to update
199:            * the extension bytes.
200:            */
201:           void __interrupt(irq(TMR0), base(IVT_BASE)) TMR0_ISR(void)
202:           {
203:               // Tick Timer interrupt
204:               //check to see if the symbol timer overflowed
205:               if(TMR_IF) {
16204  AEB1     BTFSS 0xFB1, 7, ACCESS
206:                   /* there was a timer overflow */
207:                   TMR_IF = 0;
16208  9EB1     BCF 0xFB1, 7, ACCESS
208:                   timerExtension1++;
1620A  0105     MOVLB 0x5
1620C  2BA5     INCF 0xA5, F, BANKED
209:                   if(timerExtension1 == 0) {
1620E  51A5     MOVF 0xA5, W, BANKED
16210  A4D8     BTFSS 0xFD8, 2, ACCESS
16212  0011     RETFIE 1
210:                       timerExtension2++;
16214  2BA4     INCF 0xA4, F, BANKED
211:                   }
212:               }
213:               return;
214:           }
16216  0011     RETFIE 1
162A8  0011     RETFIE 1
215:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/statusLeds2.c  ---------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            */
35:            /**
36:             * @author Ian Hogg 
37:             * @date Mar 2024
38:             * 
39:             */ 
40:            #include "statusLeds.h"
41:            #include "statusDisplay.h"
42:            
43:            /**
44:             * @file
45:             * @brief
46:             * LED handling for 2 LEDs.
47:             * 
48:             * @details
49:             * This file supports modules with two status LEDs. These are normally green and yellow.
50:             * The green LED may be labelled SLiM and the yellow LED labelled FLiM.
51:             * Each LED has a state here to indicate if it is on/off/flashing etc.
52:             * 
53:             * This looks a bit like a service but not exposed externally.
54:             * 
55:             */
56:            extern uint8_t mode_state;
57:            /**
58:             * The state of the two LEDs.
59:             */
60:            LedState    ledState[2];     // the requested state
61:            // LED identifiers
62:            /** Index for the Green LED.*/
63:            #define GREEN_LED   0
64:            /** Index for the Yellow LED.*/
65:            #define YELLOW_LED  1
66:            
67:            /**
68:             * Counters to control on/off period.
69:             */
70:            static uint8_t flashCounter[2];     // update every 10ms
71:            static TickValue ledTimer;
72:            
73:            /**
74:             * The LED initialisation function.
75:             * Turn the LEDs off.
76:             */
77:            void leds_powerUp(void) {
78:                    // Set up the LEDs
79:                APP_setPortDirections();
15C4E  0E00     MOVLW 0x0
15C50  0104     MOVLB 0x4
15C52  6F08     MOVWF 0x8, BANKED
15C54  C408     MOVFF ANSELB, ANSELA
15C56  F400     NOP
15C58  0E28     MOVLW 0x28
15C5A  6F01     MOVWF ___rparam_used, BANKED
15C5C  9EC7     BCF 0xFC7, 7, ACCESS
15C5E  9CC7     BCF 0xFC7, 6, ACCESS
15C60  86C6     BSF 0xFC6, 3, ACCESS
80:                flashCounter[GREEN_LED] = 0;
15C62  0E00     MOVLW 0x0
15C64  0105     MOVLB 0x5
15C66  6F93     MOVWF SPI2CON2, BANKED
81:                flashCounter[YELLOW_LED] = 0; 
15C68  0E00     MOVLW 0x0
15C6A  6F94     MOVWF SPI2STATUS, BANKED
82:                ledTimer.val = tickGet();
15C6C  ECD8     CALL 0x153B0, 0
15C6E  F0A9     NOP
15C70  C502     MOVFF i, ledTimer
15C72  F568     NOP
15C74  C503     MOVFF opc, 0x569
15C76  F569     NOP
15C78  C504     MOVFF s, 0x56A
15C7A  F56A     NOP
15C7C  C505     MOVFF i, 0x56B
15C7E  F56B     NOP
83:            }
15C80  0012     RETURN 0
84:            
85:            /**
86:             * Call regularly to ensure the LEDs are showing the correct state.
87:             * Controls the flashing and flicker of the LEDs.
88:             */
89:            void leds_poll(void) {
90:                if (tickTimeSince(ledTimer) > TEN_MILI_SECOND) {
11DC2  ECD8     CALL 0x153B0, 0
11DC4  F0A9     NOP
11DC6  0105     MOVLB 0x5
11DC8  5168     MOVF PMD8, W, BANKED
11DCA  5C02     SUBWF ___rparam_used, W, ACCESS
11DCC  6E0C     MOVWF 0xC, ACCESS
11DCE  5169     MOVF 0x69, W, BANKED
11DD0  5803     SUBWFB __activetblptr, W, ACCESS
11DD2  6E0D     MOVWF 0xD, ACCESS
11DD4  516A     MOVF MD1CON0, W, BANKED
11DD6  5804     SUBWFB __activetblptr, W, ACCESS
11DD8  6E0E     MOVWF 0xE, ACCESS
11DDA  516B     MOVF MD1CON1, W, BANKED
11DDC  5805     SUBWFB 0x5, W, ACCESS
11DDE  6E0F     MOVWF 0xF, ACCESS
11DE0  500F     MOVF 0xF, W, ACCESS
11DE2  100E     IORWF 0xE, W, ACCESS
11DE4  E106     BNZ 0x1DF2
11DE6  0E72     MOVLW 0x72
11DE8  5C0C     SUBWF 0xC, W, ACCESS
11DEA  0E02     MOVLW 0x2
11DEC  580D     SUBWFB 0xD, W, ACCESS
11DEE  A0D8     BTFSS 0xFD8, 0, ACCESS
11DF0  D069     BRA 0x1EC4
91:                    flashCounter[GREEN_LED]++;
11DF2  2B93     INCF SPI2CON2, F, BANKED
92:                    flashCounter[YELLOW_LED]++;
11DF4  2B94     INCF SPI2STATUS, F, BANKED
93:                    ledTimer.val = tickGet();
11DF6  ECD8     CALL 0x153B0, 0
11DF8  F0A9     NOP
11DFA  C502     MOVFF i, ledTimer
11DFC  F568     NOP
11DFE  C503     MOVFF opc, 0x569
11E00  F569     NOP
11E02  C504     MOVFF s, 0x56A
11E04  F56A     NOP
11E06  C505     MOVFF i, 0x56B
11E08  F56B     NOP
11E0A  D05C     BRA 0x1EC4
94:                }
95:                // update the actual LEDs based upon their state
96:                switch (ledState[YELLOW_LED]) {
97:                    case LED_ON:
98:                        APP_writeLED2(1);
11E0C  8CBF     BSF 0xFBF, 6, ACCESS
99:                        flashCounter[YELLOW_LED] = 0;
11E0E  0E00     MOVLW 0x0
11E10  6F94     MOVWF SPI2STATUS, BANKED
100:                       break;
11E12  D0DC     BRA 0x1FCC
101:                   case LED_OFF:
102:                       APP_writeLED2(0);
11E14  9CBF     BCF 0xFBF, 6, ACCESS
11E16  D7FB     BRA 0x1E0E
103:                       flashCounter[YELLOW_LED] = 0;
104:                       break;
105:                   case LED_FLASH_50_2HZ:
106:                       // 1Hz (500ms per on or off is a count of 25 
107:                       APP_writeLED2(flashCounter[YELLOW_LED]/25); 
11E18  C594     MOVFF 0x594, i
11E1A  F502     NOP
11E1C  6A03     CLRF __activetblptr, ACCESS
11E1E  0E00     MOVLW 0x0
11E20  6E05     MOVWF 0x5, ACCESS
11E22  0E19     MOVLW 0x19
11E24  6E04     MOVWF __activetblptr, ACCESS
11E26  EC77     CALL 0x146EE, 0
11E28  F0A3     NOP
11E2A  3A02     SWAPF ___rparam_used, F, ACCESS
11E2C  4602     RLNCF ___rparam_used, F, ACCESS
11E2E  4602     RLNCF ___rparam_used, F, ACCESS
11E30  50BF     MOVF 0xFBF, W, ACCESS
11E32  1802     XORWF ___rparam_used, W, ACCESS
11E34  0BBF     ANDLW 0xBF
11E36  1802     XORWF ___rparam_used, W, ACCESS
11E38  6EBF     MOVWF 0xFBF, ACCESS
108:                       if (flashCounter[YELLOW_LED] >= 50) {
11E3A  0E31     MOVLW 0x31
11E3C  0105     MOVLB 0x5
11E3E  6594     CPFSGT SPI2STATUS, BANKED
11E40  D0C5     BRA 0x1FCC
11E42  D7E5     BRA 0x1E0E
109:                           flashCounter[YELLOW_LED] = 0;
110:                       }
111:                       break;
112:                   case LED_FLASH_50_1HZ:
113:                       // 1Hz (500ms per on or off is a count of 50 
114:                       APP_writeLED2(flashCounter[YELLOW_LED]/50); 
11E44  C594     MOVFF 0x594, i
11E46  F502     NOP
11E48  6A03     CLRF __activetblptr, ACCESS
11E4A  0E00     MOVLW 0x0
11E4C  6E05     MOVWF 0x5, ACCESS
11E4E  0E32     MOVLW 0x32
11E50  6E04     MOVWF __activetblptr, ACCESS
11E52  EC77     CALL 0x146EE, 0
11E54  F0A3     NOP
11E56  3A02     SWAPF ___rparam_used, F, ACCESS
11E58  4602     RLNCF ___rparam_used, F, ACCESS
11E5A  4602     RLNCF ___rparam_used, F, ACCESS
11E5C  50BF     MOVF 0xFBF, W, ACCESS
11E5E  1802     XORWF ___rparam_used, W, ACCESS
11E60  0BBF     ANDLW 0xBF
11E62  1802     XORWF ___rparam_used, W, ACCESS
11E64  6EBF     MOVWF 0xFBF, ACCESS
115:                       if (flashCounter[YELLOW_LED] >= 100) {
11E66  0E63     MOVLW 0x63
11E68  D7E9     BRA 0x1E3C
116:                           flashCounter[YELLOW_LED] = 0;
117:                       }
118:                       break;
119:                   case LED_FLASH_50_HALF_HZ:
120:                       APP_writeLED2(flashCounter[YELLOW_LED]/100);
11E6A  C594     MOVFF 0x594, i
11E6C  F502     NOP
11E6E  6A03     CLRF __activetblptr, ACCESS
11E70  0E00     MOVLW 0x0
11E72  6E05     MOVWF 0x5, ACCESS
11E74  0E64     MOVLW 0x64
11E76  6E04     MOVWF __activetblptr, ACCESS
11E78  EC77     CALL 0x146EE, 0
11E7A  F0A3     NOP
11E7C  3A02     SWAPF ___rparam_used, F, ACCESS
11E7E  4602     RLNCF ___rparam_used, F, ACCESS
11E80  4602     RLNCF ___rparam_used, F, ACCESS
11E82  50BF     MOVF 0xFBF, W, ACCESS
11E84  1802     XORWF ___rparam_used, W, ACCESS
11E86  0BBF     ANDLW 0xBF
11E88  1802     XORWF ___rparam_used, W, ACCESS
11E8A  6EBF     MOVWF 0xFBF, ACCESS
121:                       if (flashCounter[YELLOW_LED] >= 200) {
11E8C  0EC7     MOVLW 0xC7
11E8E  D7D6     BRA 0x1E3C
122:                           flashCounter[YELLOW_LED] = 0;
123:                       }
124:                       break;
125:                   case LED_SINGLE_FLICKER_ON:
126:                       APP_writeLED2(1);
11E90  8CBF     BSF 0xFBF, 6, ACCESS
127:                       if (flashCounter[YELLOW_LED] >= 25) {     // 250ms
11E92  0E18     MOVLW 0x18
11E94  6594     CPFSGT SPI2STATUS, BANKED
11E96  D09A     BRA 0x1FCC
128:                           flashCounter[YELLOW_LED] = 0;
11E98  0E00     MOVLW 0x0
11E9A  6F94     MOVWF SPI2STATUS, BANKED
129:                           ledState[YELLOW_LED] = LED_OFF;
11E9C  0E00     MOVLW 0x0
11E9E  D007     BRA 0x1EAE
130:                       }
131:                       break;
132:                   case LED_SINGLE_FLICKER_OFF:
133:                       APP_writeLED2(0);
11EA0  9CBF     BCF 0xFBF, 6, ACCESS
134:                       if (flashCounter[YELLOW_LED] >= 25) {     // 250ms
11EA2  0E18     MOVLW 0x18
11EA4  6594     CPFSGT SPI2STATUS, BANKED
11EA6  D092     BRA 0x1FCC
135:                           flashCounter[YELLOW_LED] = 0;
11EA8  0E00     MOVLW 0x0
11EAA  6F94     MOVWF SPI2STATUS, BANKED
136:                           ledState[YELLOW_LED] = LED_ON;
11EAC  0E01     MOVLW 0x1
11EAE  6F96     MOVWF SPI2BAUD, BANKED
11EB0  D08D     BRA 0x1FCC
137:                       }
138:                       break;
139:                   case LED_LONG_FLICKER_ON:
140:                       APP_writeLED2(1);
11EB2  8CBF     BSF 0xFBF, 6, ACCESS
141:                       if (flashCounter[YELLOW_LED] >= 50) {     // 500ms
11EB4  0E31     MOVLW 0x31
11EB6  D7EE     BRA 0x1E94
142:                           flashCounter[YELLOW_LED] = 0;
143:                           ledState[YELLOW_LED] = LED_OFF;
144:                       }
145:                       break;
146:                   case LED_LONG_FLICKER_OFF:
147:                       APP_writeLED2(0);
11EB8  9CBF     BCF 0xFBF, 6, ACCESS
148:                       if (flashCounter[YELLOW_LED] >= 50) {     // 500ms
11EBA  0E31     MOVLW 0x31
11EBC  D7F3     BRA 0x1EA4
149:                           flashCounter[YELLOW_LED] = 0;
150:                           ledState[YELLOW_LED] = LED_ON;
151:                       }
152:                       break;
153:                   case LED_OFF_1S:
154:                       APP_writeLED2(0);
11EBE  9CBF     BCF 0xFBF, 6, ACCESS
155:                       if (flashCounter[YELLOW_LED] >= 100) {     // 500ms
11EC0  0E63     MOVLW 0x63
11EC2  D7F0     BRA 0x1EA4
156:                           flashCounter[YELLOW_LED] = 0;
157:                           ledState[YELLOW_LED] = LED_ON;
158:                       }
159:                       break;
160:               }
11EC4  0105     MOVLB 0x5
11EC6  5196     MOVF SPI2BAUD, W, BANKED
11EC8  6E0C     MOVWF 0xC, ACCESS
11ECA  6A0D     CLRF 0xD, ACCESS
11ECC  500D     MOVF 0xD, W, ACCESS
11ECE  0A00     XORLW 0x0
11ED0  A4D8     BTFSS 0xFD8, 2, ACCESS
11ED2  D07C     BRA 0x1FCC
11ED4  500C     MOVF 0xC, W, ACCESS
11ED6  0A00     XORLW 0x0
11ED8  B4D8     BTFSC 0xFD8, 2, ACCESS
11EDA  D79C     BRA 0x1E14
11EDC  0A01     XORLW 0x1
11EDE  B4D8     BTFSC 0xFD8, 2, ACCESS
11EE0  D795     BRA 0x1E0C
11EE2  0A03     XORLW 0x3
11EE4  B4D8     BTFSC 0xFD8, 2, ACCESS
11EE6  D798     BRA 0x1E18
11EE8  0A01     XORLW 0x1
11EEA  B4D8     BTFSC 0xFD8, 2, ACCESS
11EEC  D7AB     BRA 0x1E44
11EEE  0A07     XORLW 0x7
11EF0  B4D8     BTFSC 0xFD8, 2, ACCESS
11EF2  D7BB     BRA 0x1E6A
11EF4  0A01     XORLW 0x1
11EF6  B4D8     BTFSC 0xFD8, 2, ACCESS
11EF8  D7D3     BRA 0x1EA0
11EFA  0A03     XORLW 0x3
11EFC  B4D8     BTFSC 0xFD8, 2, ACCESS
11EFE  D7C8     BRA 0x1E90
11F00  0A01     XORLW 0x1
11F02  B4D8     BTFSC 0xFD8, 2, ACCESS
11F04  D7D9     BRA 0x1EB8
11F06  0A0F     XORLW 0xF
11F08  B4D8     BTFSC 0xFD8, 2, ACCESS
11F0A  D7D3     BRA 0x1EB2
11F0C  0A01     XORLW 0x1
11F0E  B4D8     BTFSC 0xFD8, 2, ACCESS
11F10  D7D6     BRA 0x1EBE
11F12  D05C     BRA 0x1FCC
161:           
162:               switch (ledState[GREEN_LED]) {
163:                   case LED_ON:
164:                       APP_writeLED1(1);
11F14  8EBF     BSF 0xFBF, 7, ACCESS
165:                       flashCounter[GREEN_LED] = 0;
11F16  0E00     MOVLW 0x0
11F18  6F93     MOVWF SPI2CON2, BANKED
166:                       break;
11F1A  0012     RETURN 0
167:                   case LED_OFF:
168:                       APP_writeLED1(0);
11F1C  9EBF     BCF 0xFBF, 7, ACCESS
11F1E  D7FB     BRA 0x1F16
169:                       flashCounter[GREEN_LED] = 0;
170:                       break;
171:                   case LED_FLASH_50_2HZ:
172:                       // 1Hz (500ms per cycle is a count of 25 
173:                       APP_writeLED1(flashCounter[GREEN_LED]/25); 
11F20  C593     MOVFF flashCounter, i
11F22  F502     NOP
11F24  6A03     CLRF __activetblptr, ACCESS
11F26  0E00     MOVLW 0x0
11F28  6E05     MOVWF 0x5, ACCESS
11F2A  0E19     MOVLW 0x19
11F2C  6E04     MOVWF __activetblptr, ACCESS
11F2E  EC77     CALL 0x146EE, 0
11F30  F0A3     NOP
11F32  3202     RRCF ___rparam_used, F, ACCESS
11F34  3202     RRCF ___rparam_used, F, ACCESS
11F36  50BF     MOVF 0xFBF, W, ACCESS
11F38  1802     XORWF ___rparam_used, W, ACCESS
11F3A  0B7F     ANDLW 0x7F
11F3C  1802     XORWF ___rparam_used, W, ACCESS
11F3E  6EBF     MOVWF 0xFBF, ACCESS
174:                       if (flashCounter[GREEN_LED] >= 50) {
11F40  0E31     MOVLW 0x31
11F42  0105     MOVLB 0x5
11F44  6593     CPFSGT SPI2CON2, BANKED
11F46  0012     RETURN 0
11F48  D7E6     BRA 0x1F16
175:                           flashCounter[GREEN_LED] = 0;
176:                       }
177:                       break;
178:                   case LED_FLASH_50_1HZ:
179:                       // 1Hz (500ms per cycle is a count of 50 
180:                       APP_writeLED1(flashCounter[GREEN_LED]/50); 
11F4A  C593     MOVFF flashCounter, i
11F4C  F502     NOP
11F4E  6A03     CLRF __activetblptr, ACCESS
11F50  0E00     MOVLW 0x0
11F52  6E05     MOVWF 0x5, ACCESS
11F54  0E32     MOVLW 0x32
11F56  6E04     MOVWF __activetblptr, ACCESS
11F58  EC77     CALL 0x146EE, 0
11F5A  F0A3     NOP
11F5C  3202     RRCF ___rparam_used, F, ACCESS
11F5E  3202     RRCF ___rparam_used, F, ACCESS
11F60  50BF     MOVF 0xFBF, W, ACCESS
11F62  1802     XORWF ___rparam_used, W, ACCESS
11F64  0B7F     ANDLW 0x7F
11F66  1802     XORWF ___rparam_used, W, ACCESS
11F68  6EBF     MOVWF 0xFBF, ACCESS
181:                       if (flashCounter[GREEN_LED] >= 100) {
11F6A  0E63     MOVLW 0x63
11F6C  D7EA     BRA 0x1F42
182:                           flashCounter[GREEN_LED] = 0;
183:                       }
184:                       break;
185:                   case LED_FLASH_50_HALF_HZ:
186:                       APP_writeLED1(flashCounter[GREEN_LED]/100);
11F6E  C593     MOVFF flashCounter, i
11F70  F502     NOP
11F72  6A03     CLRF __activetblptr, ACCESS
11F74  0E00     MOVLW 0x0
11F76  6E05     MOVWF 0x5, ACCESS
11F78  0E64     MOVLW 0x64
11F7A  6E04     MOVWF __activetblptr, ACCESS
11F7C  EC77     CALL 0x146EE, 0
11F7E  F0A3     NOP
11F80  3202     RRCF ___rparam_used, F, ACCESS
11F82  3202     RRCF ___rparam_used, F, ACCESS
11F84  50BF     MOVF 0xFBF, W, ACCESS
11F86  1802     XORWF ___rparam_used, W, ACCESS
11F88  0B7F     ANDLW 0x7F
11F8A  1802     XORWF ___rparam_used, W, ACCESS
11F8C  6EBF     MOVWF 0xFBF, ACCESS
187:                       if (flashCounter[GREEN_LED] >= 200) {
11F8E  0EC7     MOVLW 0xC7
11F90  D7D8     BRA 0x1F42
188:                           flashCounter[GREEN_LED] = 0;
189:                       }
190:                       break;
191:                   case LED_SINGLE_FLICKER_ON:
192:                       APP_writeLED1(1);
11F92  8EBF     BSF 0xFBF, 7, ACCESS
193:                       if (flashCounter[GREEN_LED] >= 25) {     // 250ms
11F94  0E18     MOVLW 0x18
11F96  D00F     BRA 0x1FB6
194:                           flashCounter[GREEN_LED] = 0;
11F98  0E00     MOVLW 0x0
11F9A  6F93     MOVWF SPI2CON2, BANKED
195:                           ledState[GREEN_LED] = LED_OFF;
11F9C  0E00     MOVLW 0x0
11F9E  6F95     MOVWF SPI2TWIDTH, BANKED
11FA0  0012     RETURN 0
196:                       }
197:                       break;
198:                   case LED_SINGLE_FLICKER_OFF:
199:                       APP_writeLED1(0);
11FA2  9EBF     BCF 0xFBF, 7, ACCESS
200:                       if (flashCounter[GREEN_LED] >= 25) {     // 250ms
11FA4  0E18     MOVLW 0x18
11FA6  D00C     BRA 0x1FC0
201:                           flashCounter[GREEN_LED] = 0;
11FA8  0E00     MOVLW 0x0
11FAA  6F93     MOVWF SPI2CON2, BANKED
202:                           ledState[GREEN_LED] = LED_ON;
11FAC  0E01     MOVLW 0x1
11FAE  6F95     MOVWF SPI2TWIDTH, BANKED
11FB0  0012     RETURN 0
203:                       }
204:                       break;
205:                   case LED_LONG_FLICKER_ON:
206:                       APP_writeLED1(1);
11FB2  8EBF     BSF 0xFBF, 7, ACCESS
207:                       if (flashCounter[GREEN_LED] >= 50) {     // 500ms
11FB4  0E31     MOVLW 0x31
11FB6  6593     CPFSGT SPI2CON2, BANKED
11FB8  0012     RETURN 0
11FBA  D7EE     BRA 0x1F98
208:                           flashCounter[GREEN_LED] = 0;
209:                           ledState[GREEN_LED] = LED_OFF;
210:                       }
211:                       break;
212:                   case LED_LONG_FLICKER_OFF:
213:                       APP_writeLED1(0);
11FBC  9EBF     BCF 0xFBF, 7, ACCESS
214:                       if (flashCounter[GREEN_LED] >= 50) {     // 500ms
11FBE  0E31     MOVLW 0x31
11FC0  6593     CPFSGT SPI2CON2, BANKED
11FC2  0012     RETURN 0
11FC4  D7F1     BRA 0x1FA8
215:                           flashCounter[GREEN_LED] = 0;
216:                           ledState[GREEN_LED] = LED_ON;
217:                       }
218:                       break;
219:                   case LED_OFF_1S:
220:                       APP_writeLED1(0);
11FC6  9EBF     BCF 0xFBF, 7, ACCESS
221:                       if (flashCounter[GREEN_LED] >= 100) {     // 500ms
11FC8  0E63     MOVLW 0x63
11FCA  D7FA     BRA 0x1FC0
222:                           flashCounter[GREEN_LED] = 0;
223:                           ledState[GREEN_LED] = LED_ON;
224:                       }
225:                       break;
226:               }
11FCC  5195     MOVF SPI2TWIDTH, W, BANKED
11FCE  6E0C     MOVWF 0xC, ACCESS
11FD0  6A0D     CLRF 0xD, ACCESS
11FD2  500D     MOVF 0xD, W, ACCESS
11FD4  0A00     XORLW 0x0
11FD6  A4D8     BTFSS 0xFD8, 2, ACCESS
11FD8  0012     RETURN 0
11FDA  500C     MOVF 0xC, W, ACCESS
11FDC  0A00     XORLW 0x0
11FDE  B4D8     BTFSC 0xFD8, 2, ACCESS
11FE0  D79D     BRA 0x1F1C
11FE2  0A01     XORLW 0x1
11FE4  B4D8     BTFSC 0xFD8, 2, ACCESS
11FE6  D796     BRA 0x1F14
11FE8  0A03     XORLW 0x3
11FEA  B4D8     BTFSC 0xFD8, 2, ACCESS
11FEC  D799     BRA 0x1F20
11FEE  0A01     XORLW 0x1
11FF0  B4D8     BTFSC 0xFD8, 2, ACCESS
11FF2  D7AB     BRA 0x1F4A
11FF4  0A07     XORLW 0x7
11FF6  B4D8     BTFSC 0xFD8, 2, ACCESS
11FF8  D7BA     BRA 0x1F6E
11FFA  0A01     XORLW 0x1
11FFC  B4D8     BTFSC 0xFD8, 2, ACCESS
11FFE  D7D1     BRA 0x1FA2
12000  0A03     XORLW 0x3
12002  B4D8     BTFSC 0xFD8, 2, ACCESS
12004  D7C6     BRA 0x1F92
12006  0A01     XORLW 0x1
12008  B4D8     BTFSC 0xFD8, 2, ACCESS
1200A  D7D8     BRA 0x1FBC
1200C  0A0F     XORLW 0xF
1200E  B4D8     BTFSC 0xFD8, 2, ACCESS
12010  D7D0     BRA 0x1FB2
12012  0A01     XORLW 0x1
12014  A4D8     BTFSS 0xFD8, 2, ACCESS
12014  A4D8     BTFSS 0xFD8, 2, ACCESS
12014  A4D8     BTFSS 0xFD8, 2, ACCESS
227:           }
228:           
229:           /**
230:            * This function ensures that the LEDs display the correct information based upon 
231:            * the state of the module.
232:            * Call this function whenever the module state changes.
233:            * @param s the StatusDisplay to be indicated by the LEDs
234:            */
235:           void showStatus(StatusDisplay s) {
1379A  6E04     MOVWF __activetblptr, ACCESS
236:               switch (s) {
1379C  D046     BRA 0x382A
237:                   case STATUS_OFF:
238:                       ledState[GREEN_LED] = LED_OFF;
1379E  0E00     MOVLW 0x0
137A0  0105     MOVLB 0x5
137A2  6F95     MOVWF SPI2TWIDTH, BANKED
239:                       ledState[YELLOW_LED] = LED_OFF;
137A4  0E00     MOVLW 0x0
137A6  6F96     MOVWF SPI2BAUD, BANKED
240:                       break;
137A8  0012     RETURN 0
241:                   case STATUS_UNINITIALISED:
242:                       ledState[GREEN_LED] = LED_ON;
137AA  0E01     MOVLW 0x1
137AC  0105     MOVLB 0x5
137AE  6F95     MOVWF SPI2TWIDTH, BANKED
243:                       ledState[YELLOW_LED] = LED_OFF;
137B0  0E00     MOVLW 0x0
137B2  6F96     MOVWF SPI2BAUD, BANKED
244:                       break;
137B4  0012     RETURN 0
245:                   case STATUS_SETUP:
246:                       ledState[GREEN_LED] = LED_OFF;
137B6  0E00     MOVLW 0x0
137B8  0105     MOVLB 0x5
137BA  6F95     MOVWF SPI2TWIDTH, BANKED
247:                       ledState[YELLOW_LED] = LED_FLASH_50_1HZ;
137BC  0E03     MOVLW 0x3
137BE  6F96     MOVWF SPI2BAUD, BANKED
248:                       break;
137C0  0012     RETURN 0
249:                   case STATUS_NORMAL:
250:                   case STATUS_LEARN:
251:                   case STATUS_BOOT:
252:                   case STATUS_TRANSMIT_ERROR:
253:                   case STATUS_RECEIVE_ERROR:
254:                       ledState[GREEN_LED] = LED_OFF;
137C2  0E00     MOVLW 0x0
137C4  0105     MOVLB 0x5
137C6  6F95     MOVWF SPI2TWIDTH, BANKED
255:                       ledState[YELLOW_LED] = LED_ON;
137C8  0E01     MOVLW 0x1
137CA  6F96     MOVWF SPI2BAUD, BANKED
256:                       break;
137CC  0012     RETURN 0
257:                   case STATUS_RESET_WARNING:
258:                       flashCounter[YELLOW_LED] = 0;
137CE  0E00     MOVLW 0x0
137D0  0105     MOVLB 0x5
137D2  6F94     MOVWF SPI2STATUS, BANKED
259:                       flashCounter[GREEN_LED] = 25;
137D4  0E19     MOVLW 0x19
137D6  6F93     MOVWF SPI2CON2, BANKED
260:                       ledState[GREEN_LED] = LED_FLASH_50_2HZ;
137D8  0E02     MOVLW 0x2
137DA  6F95     MOVWF SPI2TWIDTH, BANKED
261:                       ledState[YELLOW_LED] = LED_FLASH_50_2HZ;
137DC  0E02     MOVLW 0x2
137DE  6F96     MOVWF SPI2BAUD, BANKED
262:                       break;
137E0  0012     RETURN 0
263:                   case STATUS_MESSAGE_RECEIVED:
264:                       if (mode_state == MODE_UNINITIALISED) {
137E2  0105     MOVLB 0x5
137E4  29AB     INCF 0xAB, W, BANKED
137E6  A4D8     BTFSS 0xFD8, 2, ACCESS
137E8  D003     BRA 0x37F0
265:                           ledState[YELLOW_LED] = LED_SINGLE_FLICKER_ON;
137EA  0E06     MOVLW 0x6
137EC  6F96     MOVWF SPI2BAUD, BANKED
266:                       } else if (mode_state == MODE_NORMAL) {
137EE  0012     RETURN 0
137F0  05AB     DECF 0xAB, W, BANKED
137F2  A4D8     BTFSS 0xFD8, 2, ACCESS
137F4  0012     RETURN 0
267:                           ledState[GREEN_LED] = LED_SINGLE_FLICKER_ON;
137F6  0E06     MOVLW 0x6
137F8  6F95     MOVWF SPI2TWIDTH, BANKED
137FA  0012     RETURN 0
268:                       }
269:                       break;
270:                   case STATUS_MESSAGE_ACTED:
271:                       if (mode_state == MODE_UNINITIALISED) {
137FC  0105     MOVLB 0x5
137FE  29AB     INCF 0xAB, W, BANKED
13800  A4D8     BTFSS 0xFD8, 2, ACCESS
13802  D003     BRA 0x380A
272:                           ledState[YELLOW_LED] = LED_LONG_FLICKER_ON;
13804  0E08     MOVLW 0x8
13806  6F96     MOVWF SPI2BAUD, BANKED
273:                       } else if (mode_state == MODE_NORMAL) {
13808  0012     RETURN 0
1380A  05AB     DECF 0xAB, W, BANKED
1380C  A4D8     BTFSS 0xFD8, 2, ACCESS
1380E  0012     RETURN 0
274:                           ledState[GREEN_LED] = LED_LONG_FLICKER_ON;
13810  0E08     MOVLW 0x8
13812  6F95     MOVWF SPI2TWIDTH, BANKED
13814  0012     RETURN 0
275:                       }
276:                       break;
277:                   case STATUS_MEMORY_FAULT:
278:                   case STATUS_FATAL_ERROR:
279:                       flashCounter[YELLOW_LED] = 0;
13816  0E00     MOVLW 0x0
13818  0105     MOVLB 0x5
1381A  6F94     MOVWF SPI2STATUS, BANKED
280:                       flashCounter[GREEN_LED] = 0;
1381C  0E00     MOVLW 0x0
1381E  6F93     MOVWF SPI2CON2, BANKED
281:                       ledState[GREEN_LED] = LED_FLASH_50_2HZ;
13820  0E02     MOVLW 0x2
13822  6F95     MOVWF SPI2TWIDTH, BANKED
282:                       ledState[YELLOW_LED] = LED_FLASH_50_2HZ;
13824  0E02     MOVLW 0x2
13826  6F96     MOVWF SPI2BAUD, BANKED
283:                       break;
13828  0012     RETURN 0
284:               }
1382A  5004     MOVF __activetblptr, W, ACCESS
1382C  6E02     MOVWF ___rparam_used, ACCESS
1382E  6A03     CLRF __activetblptr, ACCESS
13830  5003     MOVF __activetblptr, W, ACCESS
13832  0A00     XORLW 0x0
13834  A4D8     BTFSS 0xFD8, 2, ACCESS
13836  0012     RETURN 0
13838  5002     MOVF ___rparam_used, W, ACCESS
1383A  0A00     XORLW 0x0
1383C  B4D8     BTFSC 0xFD8, 2, ACCESS
1383E  D7AF     BRA 0x379E
13840  0A01     XORLW 0x1
13842  B4D8     BTFSC 0xFD8, 2, ACCESS
13844  D7B2     BRA 0x37AA
13846  0A03     XORLW 0x3
13848  B4D8     BTFSC 0xFD8, 2, ACCESS
1384A  D7B5     BRA 0x37B6
1384C  0A01     XORLW 0x1
1384E  B4D8     BTFSC 0xFD8, 2, ACCESS
13850  D7B8     BRA 0x37C2
13852  0A07     XORLW 0x7
13854  B4D8     BTFSC 0xFD8, 2, ACCESS
13856  D7BB     BRA 0x37CE
13858  0A01     XORLW 0x1
1385A  B4D8     BTFSC 0xFD8, 2, ACCESS
1385C  D7B2     BRA 0x37C2
1385E  0A03     XORLW 0x3
13860  B4D8     BTFSC 0xFD8, 2, ACCESS
13862  D7AF     BRA 0x37C2
13864  0A01     XORLW 0x1
13866  B4D8     BTFSC 0xFD8, 2, ACCESS
13868  D7BC     BRA 0x37E2
1386A  0A0F     XORLW 0xF
1386C  B4D8     BTFSC 0xFD8, 2, ACCESS
1386E  D7C6     BRA 0x37FC
13870  0A01     XORLW 0x1
13872  B4D8     BTFSC 0xFD8, 2, ACCESS
13874  D7A6     BRA 0x37C2
13876  0A03     XORLW 0x3
13878  B4D8     BTFSC 0xFD8, 2, ACCESS
1387A  D7A3     BRA 0x37C2
1387C  0A01     XORLW 0x1
1387E  B4D8     BTFSC 0xFD8, 2, ACCESS
13880  D7CA     BRA 0x3816
13882  0A07     XORLW 0x7
13884  A4D8     BTFSS 0xFD8, 2, ACCESS
13884  A4D8     BTFSS 0xFD8, 2, ACCESS
13884  A4D8     BTFSS 0xFD8, 2, ACCESS
285:           }
286:           
287:           
---  C:/Users/ianwh/github/VLCBlib_PIC/nvm.c  -----------------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            */
35:            /**
36:             * @author Original CANACC8 assembler version (c) Mike Bolton
37:             * @author Modifications to EEPROM routines and conversion to C18 (c) Andrew Crosland
38:             * @author FLASH routines by (c) Chuck Hoelzen
39:             * @author Modifications, refinements & combine EEPROM and FLASH into one module (C) Pete Brownlow 2014-2017   software@upsys.co.u
40:             * @author Major rewrite  Ian Hogg  
41:             * @date Dec 2022
42:             * 
43:             * EEPROM read and write are straightforward since the PIC offers byte read and 
44:             * write access to the EEPROM so these routines just provide the necessary functionality
45:             * and register access and write unlocking.
46:             * 
47:             * Flash read is also done using the PIC reading of a single byte of flash.
48:             * 
49:             * Flashing writing is complicated due to the PIC only supporting page writes and
50:             * bits can only be cleared. If any bit needs to be set then the entire page needs 
51:             * to be erased. To do this a RAM buffer is used to hold the current page's contents.
52:             * Writing a byte to Flash involves checking if the current page in the buffer 
53:             * is the correct page for the byte to be written, if it is not then the current page 
54:             * may need to be flushed out before the correct page is read in and the byte modified.
55:             * To flush the page then the buffer needs to be checked to see if it is dirty (been modified).
56:             * If the buffer is dirty and bits have been cleared then the page first needs to 
57:             * be erased before the whole page is is written.
58:             * 
59:             */
60:            
61:            /**
62:             * @file
63:             * @brief
64:             * Non volatile memory functions.
65:             * 
66:             * @details
67:             * Functionality for reading and writing to EEPROM and Flash NVM.
68:             * Read and write to EEPROM is straightforward.
69:             * Reading from flash is also straightforward but writing to flash is complex. 
70:             * This involves needing to erase a block if changing any bit from 0 to 1 and
71:             * if changing a single byte the entire block must be read, the byte changed 
72:             * and the entire block written back.
73:             */
74:            
75:            #include <xc.h>
76:            #include "vlcb.h"
77:            #include "hardware.h"
78:            #include "nvm.h"
79:            #include "mns.h"
80:            
81:            #if defined(_18F66K80_FAMILY_)
82:            #define FLASH_PAGE_SIZE _FLASH_ERASE_SIZE
83:            #endif
84:            
85:            #if defined(_18FXXQ83_FAMILY_)
86:            
87:            /**
88:             * Contains the size of a Flash page in bytes.
89:             */
90:            #define FLASH_PAGE_SIZE          (256U)
91:            
92:            /**
93:             * Contains the total size of Flash in bytes.
94:             */
95:            #define PROGMEM_SIZE               (0x020000U)
96:            
97:            /**
98:             * @ingroup nvm_driver
99:             * @def BUFFER_RAM_START_ADDRESS
100:            * Contains the starting address of the buffer RAM.
101:            */
102:           #define BUFFER_RAM_START_ADDRESS   (0x3700U)
103:           
104:           /**
105:            * @ingroup nvm_driver
106:            * @def EEPROM_START_ADDRESS
107:            * Contains the starting address of EEPROM.
108:            */
109:           #define EEPROM_START_ADDRESS       (0x380000U)
110:           
111:           /**
112:            * @ingroup nvm_driver
113:            * @def EEPROM_SIZE
114:            * Contains the size of EEPROM in bytes.
115:            */
116:           #define EEPROM_SIZE                (1024U)
117:           #endif
118:           
119:           #define NVMCMD_READ             0x00
120:           #define NVMCMD_READ_POSTINC     0x01
121:           #define NVMCMD_READPAGE         0x02
122:           #define NVMCMD_WRITE            0x03
123:           #define NVMCMD_WRITE_POSTINC    0x04
124:           #define NVMCMD_WRITEPAGE        0x05
125:           #define NVMCMD_ERASEPAGE        0x06
126:           #define NVMCMD_NOP              0x07
127:           
128:           
129:           // Structure for tracking Flash operations
130:           static union
131:           {
132:               uint8_t asByte;       
133:               struct  {
134:                   uint8_t writeNeeded:1; //flag if buffer is modified
135:                   uint8_t eraseNeeded:1;  //flag if long write with block erase
136:               };
137:           } flashFlags;
138:           
139:           #if defined(_18F66K80_FAMILY_)
140:           static flash_data_t       flashBuffer[FLASH_PAGE_SIZE];    // Assumes that Erase and Write are the same size
141:           #endif
142:           #if defined(_18FXXQ83_FAMILY_)
143:           // On the Q series the NVM peripheral uses a fixed RAM buffer at 0x3700
144:            flash_data_t        * flashBuffer = (flash_data_t *)BUFFER_RAM_START_ADDRESS;
145:           #endif
146:           static flash_address_t    flashBlock;     //address of current flash block
147:           
148:           /** Provides the Flash Block number given an address.*/
149:           #define BLOCK(A)    (A&(~((flash_address_t)FLASH_PAGE_SIZE-1)))
150:           /** Provides the offset into a Flash Block given an address.*/
151:           #define OFFSET(A)   (A&(FLASH_PAGE_SIZE-1))
152:           
153:           /**
154:            *  Initialise variables for Flash program tracking.
155:            */
156:           void initRomOps(void) {
157:               flashFlags.asByte = 0;  // no write and no erase
16192  0E00     MOVLW 0x0
16194  0105     MOVLB 0x5
16196  6FA6     MOVWF 0xA6, BANKED
158:               flashBlock = 0x0700; // invalid but as long a write isn't needed it will be 
16198  0E00     MOVLW 0x0
1619A  6FF8     MOVWF DMAnSSZH, BANKED
1619C  0E07     MOVLW 0x7
1619E  6FF9     MOVWF DMAnSSA, BANKED
161A0  0E00     MOVLW 0x0
161A2  6FFA     MOVWF DMAnSSAH, BANKED
159:                                    // ok. Next write will always be to a different block.
160:               TBLPTRU = 0;
161A4  0E00     MOVLW 0x0
161A6  6EF8     MOVWF 0xFF8, ACCESS
161:           #if defined(_18FXXQ83_FAMILY_)
162:               NVMCON1bits.WRERR = 0;
161A8  0100     MOVLB 0x0
161AA  9F41     BCF NVMCON1, 7, BANKED
163:           #endif
164:           }
161AC  0012     RETURN 0
165:           
166:           /**
167:            * Read EEPROM.  
168:            * @param index the address
169:            * @return the value
170:            */
171:           eeprom_data_t EEPROM_Read(eeprom_address_t index) {
172:           #if defined (_18F66K80_FAMILY_)
173:               // do read of EEPROM
174:               while (EECON1bits.WR)       // Errata says this is required
175:                   ;
176:               // EEADRH = index >> 8;        //  High byte of address to read
177:               SET_EADDRH((index >> 8)&0xFF);
178:               EEADR = index & 0xFF;       	/* Low byte of Data Memory Address to read */
179:               EECON1bits.EEPGD = 0;    	/* Point to DATA memory */
180:               EECON1bits.CFGS = 0;    	/* Access program FLASH/Data EEPROM memory */
181:               EECON1bits.RD = 1;			/* EEPROM Read */
182:               while (EECON1bits.RD)
183:                   ;
184:           
185:               asm("NOP");                 /* data available after a NOP */
186:           
187:               return EEDATA;
188:           #endif
189:           #if defined(_18FXXQ83_FAMILY_)
190:               // ready?
191:               while (NVMCON0bits.GO)
15C18  0100     MOVLB 0x0
15C1A  B140     BTFSC NVMCON0, 0, BANKED
15C1C  D7FD     BRA 0x5C18
192:                   ;
193:               //Load NVMADR with the desired byte address
194:               NVMADRU = 0x38;
15C1E  0E38     MOVLW 0x38
15C20  6F45     MOVWF NVMADRU, BANKED
195:               NVMADRH = (uint8_t) (index >> 8);
15C22  C502     MOVFF i, i
15C24  F505     NOP
15C26  C503     MOVFF opc, id
15C28  F506     NOP
15C2A  C504     MOVFF s, i
15C2C  F507     NOP
15C2E  C506     MOVFF id, i
15C30  F505     NOP
15C32  C507     MOVFF i, id
15C34  F506     NOP
15C36  6A07     CLRF 0x7, ACCESS
15C38  5005     MOVF 0x5, W, ACCESS
15C3A  6F44     MOVWF NVMADRH, BANKED
196:               NVMADRL = (uint8_t) index;
15C3C  C502     MOVFF i, NVMADR
15C3E  F043     NOP
197:           
198:               //Set the byte read command
199:               NVMCON1bits.NVMCMD = NVMCMD_READ;
15C40  0EF8     MOVLW 0xF8
15C42  1741     ANDWF NVMCON1, F, BANKED
200:               
201:               //Start byte read
202:               NVMCON0bits.GO = 1;
15C44  8140     BSF NVMCON0, 0, BANKED
203:               while (NVMCON0bits.GO)
204:                   ;
15C46  B140     BTFSC NVMCON0, 0, BANKED
15C48  D7FE     BRA 0x5C46
205:           
206:               return NVMDATL;
15C4A  5146     MOVF NVMDAT, W, BANKED
207:           #endif
208:           }
15C4C  0012     RETURN 0
209:           
210:           /**
211:            * Write a byte to EEPROM
212:            * @param index the address
213:            * @param value the value to be written
214:            * @return 0 for success or error otherwise
215:            */
216:           uint8_t EEPROM_Write(eeprom_address_t index, eeprom_data_t value) {
217:               uint8_t interruptEnabled;
218:               interruptEnabled = geti(); // store current global interrupt state
14972  0E00     MOVLW 0x0
14974  BED6     BTFSC 0xFD6, 7, ACCESS
14976  0E01     MOVLW 0x1
14978  6E0F     MOVWF 0xF, ACCESS
219:               do {
220:           #if defined (_18F66K80_FAMILY_)
221:                   SET_EADDRH((index >> 8)&0xFF);      // High byte of address to write
222:                   EEADR = index & 0xFF;       	/* Low byte of Data Memory Address to write */
223:                   EEDATA = value;
224:                   EECON1bits.EEPGD = 0;       /* Point to DATA memory */
225:                   EECON1bits.CFGS = 0;        /* Access program FLASH/Data EEPROM memory */
226:                   EECON1bits.WREN = 1;        /* Enable writes */
227:                   /* Disable Interrupts */
228:                   bothDi();                       
229:                   EECON2 = 0x55;
230:                   EECON2 = 0xAA;
231:                   EECON1bits.WR = 1;
232:                   while (EECON1bits.WR)       // should wait until WR clears
233:                       ;
234:                   while (!EEIF)
235:                       ;
236:                   EEIF = 0;
237:                   if (interruptEnabled) {     // Only enable interrupts if they were enabled at function entry
238:                       /* Re-enable Interrupts */
239:                       bothEi();                  
240:                   }
241:                   EECON1bits.WREN = 0;		/* Disable writes */
242:           #endif
243:           #if defined(_18FXXQ83_FAMILY_)
244:                   // ready?
245:                   while (NVMCON0bits.GO)
246:                       ;
1497A  0100     MOVLB 0x0
1497C  B140     BTFSC NVMCON0, 0, BANKED
1497E  D7FD     BRA 0x497A
247:                   //Load NVMADR with the target address of the byte
248:                   NVMADRU = 0x38;
14980  0E38     MOVLW 0x38
14982  6F45     MOVWF NVMADRU, BANKED
249:                   NVMADRH = (uint8_t) (index >> 8);
14984  C508     MOVFF index, txWaiting
14986  F50C     NOP
14988  C509     MOVFF d, i
1498A  F50D     NOP
1498C  C50A     MOVFF index, evNum
1498E  F50E     NOP
14990  C50D     MOVFF i, txWaiting
14992  F50C     NOP
14994  C50E     MOVFF evNum, i
14996  F50D     NOP
14998  6A0E     CLRF 0xE, ACCESS
1499A  500C     MOVF 0xC, W, ACCESS
1499C  6F44     MOVWF NVMADRH, BANKED
250:                   NVMADRL = (uint8_t) index;
1499E  C508     MOVFF index, NVMADR
149A0  F043     NOP
251:           
252:                   //Load NVMDAT with the desired value
253:                   NVMDATL = value;
149A2  C50B     MOVFF index, NVMDAT
149A4  F046     NOP
254:           
255:                   //Set the byte write command
256:                   NVMCON1bits.NVMCMD = NVMCMD_WRITE;
149A6  5141     MOVF NVMCON1, W, BANKED
149A8  0BF8     ANDLW 0xF8
149AA  0903     IORLW 0x3
149AC  6F41     MOVWF NVMCON1, BANKED
257:           
258:                   //Disable global interrupt
259:                   bothDi();
149AE  9ED6     BCF 0xFD6, 7, ACCESS
260:           
261:                   //Perform the unlock sequence 
262:                   NVMLOCK = 0x55;
149B0  0E55     MOVLW 0x55
149B2  6F42     MOVWF NVMLOCK, BANKED
263:                   NVMLOCK = 0xAA;
149B4  0EAA     MOVLW 0xAA
149B6  6F42     MOVWF NVMLOCK, BANKED
264:                   
265:                   //Start byte write
266:                   NVMCON0bits.GO = 1;
149B8  8140     BSF NVMCON0, 0, BANKED
267:           
268:                   if (interruptEnabled) {     // Only enable interrupts if they were enabled at function entry
149BA  500F     MOVF 0xF, W, ACCESS
149BC  A4D8     BTFSS 0xFD8, 2, ACCESS
269:                       /* Re-enable Interrupts */
270:                       bothEi();                  
149BE  8ED6     BSF 0xFD6, 7, ACCESS
271:                   }
272:           
273:                   //Clear the NVM Command
274:                   NVMCON1bits.NVMCMD = NVMCMD_NOP;
149C0  0E07     MOVLW 0x7
149C2  1341     IORWF NVMCON1, F, BANKED
275:           #endif
276:                   // check that it worked
277:                   if (EEPROM_Read(index) == value) {
149C4  C508     MOVFF index, i
149C6  F502     NOP
149C8  C509     MOVFF d, opc
149CA  F503     NOP
149CC  C50A     MOVFF index, s
149CE  F504     NOP
149D0  EC0C     CALL 0x15C18, 0
149D2  F0AE     NOP
149D4  180B     XORWF 0xB, W, ACCESS
149D6  B4D8     BTFSC 0xFD8, 2, ACCESS
149D8  D006     BRA 0x49E6
278:                       break;
279:                   }
280:           #ifdef VLCB_DIAG
281:                   mnsDiagnostics[MNS_DIAGNOSTICS_MEMERRS].asUint++;
149DA  0105     MOVLB 0x5
149DC  4BBF     INFSNZ ISRPR, F, BANKED
149DE  2BC0     INCF 0xC0, F, BANKED
282:                   updateModuleErrorStatus();
149E0  EC23     CALL 0x16246, 0
149E2  F0B1     NOP
283:           #endif
284:               } while (1);
149E4  D7CA     BRA 0x497A
285:               return GRSP_OK;
149E6  0E00     MOVLW 0x0
286:           }
149E8  0012     RETURN 0
287:           
288:           
289:           
290:           /**
291:            * Read Flash. 
292:            * @param address the address
293:            * @return the value
294:            */
295:           static flash_data_t FLASH_Read(flash_address_t address) {
296:               // do read of Flash
297:               if (BLOCK(address) == flashBlock) {
14F32  0E00     MOVLW 0x0
14F34  1402     ANDWF ___rparam_used, W, ACCESS
14F36  6E05     MOVWF 0x5, ACCESS
14F38  0EFF     MOVLW 0xFF
14F3A  1403     ANDWF __activetblptr, W, ACCESS
14F3C  6E06     MOVWF 0x6, ACCESS
14F3E  0EFF     MOVLW 0xFF
14F40  1404     ANDWF __activetblptr, W, ACCESS
14F42  6E07     MOVWF 0x7, ACCESS
14F44  0105     MOVLB 0x5
14F46  51F8     MOVF DMAnSSZH, W, BANKED
14F48  1805     XORWF 0x5, W, ACCESS
14F4A  E115     BNZ 0x4F76
14F4C  51F9     MOVF DMAnSSA, W, BANKED
14F4E  1806     XORWF 0x6, W, ACCESS
14F50  E112     BNZ 0x4F76
14F52  51FA     MOVF DMAnSSAH, W, BANKED
14F54  1807     XORWF 0x7, W, ACCESS
14F56  A4D8     BTFSS 0xFD8, 2, ACCESS
14F58  D00E     BRA 0x4F76
298:                   // if the block is the current one then get it directly
299:                   return flashBuffer[OFFSET(address)];
14F5A  0EFF     MOVLW 0xFF
14F5C  1402     ANDWF ___rparam_used, W, ACCESS
14F5E  6E05     MOVWF 0x5, ACCESS
14F60  0E00     MOVLW 0x0
14F62  1403     ANDWF __activetblptr, W, ACCESS
14F64  6E06     MOVWF 0x6, ACCESS
14F66  0E00     MOVLW 0x0
14F68  2405     ADDWF 0x5, W, ACCESS
14F6A  6ED9     MOVWF 0xFD9, ACCESS
14F6C  0E37     MOVLW 0x37
14F6E  2006     ADDWFC 0x6, W, ACCESS
14F70  6EDA     MOVWF 0xFDA, ACCESS
14F72  50DF     MOVF 0xFDF, W, ACCESS
14F74  0012     RETURN 0
300:               } else {
301:                   // we'll read single byte from flash
302:           #if defined (_18F66K80_FAMILY_)
303:                   TBLPTR = address;
304:                   TBLPTRU = 0;
305:                   asm("TBLRD");
306:           #endif
307:           #if defined (_18FXXQ83_FAMILY_)
308:                   //Load table pointer with the target address of the byte  
309:                   TBLPTRU = (uint8_t) (address >> 16);
14F76  C504     MOVFF s, TBLPTRU
14F78  F4F8     NOP
310:                   TBLPTRH = (uint8_t) (address >> 8);
14F7A  C502     MOVFF i, i
14F7C  F505     NOP
14F7E  C503     MOVFF opc, id
14F80  F506     NOP
14F82  C504     MOVFF s, i
14F84  F507     NOP
14F86  C506     MOVFF id, i
14F88  F505     NOP
14F8A  C507     MOVFF i, id
14F8C  F506     NOP
14F8E  6A07     CLRF 0x7, ACCESS
14F90  5005     MOVF 0x5, W, ACCESS
14F92  6EF7     MOVWF 0xFF7, ACCESS
311:                   TBLPTRL = (uint8_t) address;
14F94  C502     MOVFF i, TBLPTR
14F96  F4F6     NOP
312:                   //Execute table read 
313:                   asm("TBLRD*");
14F98  0008     TBLRD*
314:           #endif
315:                   return TABLAT;
14F9A  50F5     MOVF 0xFF5, W, ACCESS
316:               }
317:           }
14F9C  0012     RETURN 0
318:           
319:           /**
320:            * Erase a block of flash.
321:            * May block awaiting for the application to indicate that it is a suitable time
322:            * to allow the CPU to be halted.
323:            */
324:           void eraseFlashBlock(void) {
325:               uint8_t interruptEnabled;
326:               // Call back into the application to check if now is a good time to write the flash
327:               // as the processor will be suspended for up to 2ms.
328:               while (! APP_isSuitableTimeToWriteFlash())
152A0  EC4F     CALL 0x1629E, 0
152A2  F0B1     NOP
152A4  0900     IORLW 0x0
152A6  B4D8     BTFSC 0xFD8, 2, ACCESS
152A8  D7FB     BRA 0x52A0
329:                   ;
330:               
331:               interruptEnabled = geti(); // store current global interrupt state
152AA  0E00     MOVLW 0x0
152AC  BED6     BTFSC 0xFD6, 7, ACCESS
152AE  0E01     MOVLW 0x1
152B0  6E05     MOVWF 0x5, ACCESS
332:           #if defined (_18F66K80_FAMILY_)
333:               TBLPTR = flashBlock;
334:               TBLPTRU = 0;
335:               EECON1bits.EEPGD = 1;   // 1=Program memory, 0=EEPROM
336:               EECON1bits.CFGS = 0;    // 0=Program memory/EEPROM, 1=ConfigBits
337:               EECON1bits.WREN = 1;    // enable write to memory
338:               EECON1bits.FREE = 1;    // enable row erase operation
339:               bothDi();     // disable all interrupts
340:               EECON2 = 0x55;          // write 0x55
341:               EECON2 = 0xaa;          // write 0xaa
342:               EECON1bits.WR = 1;      // start erasing
343:               while(EECON1bits.WR)    // wait to finish
344:                   ;
345:               EECON1bits.WREN = 0;    // disable write to memory
346:           #endif
347:           #if defined (_18FXXQ83_FAMILY_)
348:               // ready?
349:               while (NVMCON0bits.GO)
350:                   ;
152B2  0100     MOVLB 0x0
152B4  B140     BTFSC NVMCON0, 0, BANKED
152B6  D7FD     BRA 0x52B2
351:               //Load NVMADR with the any address in the memory page. NVMADRL is ignored
352:               NVMADRU = (uint8_t) (flashBlock >> 16);
152B8  C5FA     MOVFF 0x5FA, NVMADRU
152BA  F045     NOP
353:               NVMADRH = (uint8_t) (flashBlock >> 8);
152BC  C5F8     MOVFF flashBlock, i
152BE  F502     NOP
152C0  C5F9     MOVFF 0x5F9, opc
152C2  F503     NOP
152C4  C5FA     MOVFF 0x5FA, s
152C6  F504     NOP
152C8  C503     MOVFF opc, i
152CA  F502     NOP
152CC  C504     MOVFF s, opc
152CE  F503     NOP
152D0  6A04     CLRF __activetblptr, ACCESS
152D2  5002     MOVF ___rparam_used, W, ACCESS
152D4  6F44     MOVWF NVMADRH, BANKED
354:           
355:               NVMCON1bits.NVMCMD = NVMCMD_ERASEPAGE;      //Set the page erase command
152D6  5141     MOVF NVMCON1, W, BANKED
152D8  0BF8     ANDLW 0xF8
152DA  0906     IORLW 0x6
152DC  6F41     MOVWF NVMCON1, BANKED
356:               bothDi();                       // disable all interrupts
152DE  9ED6     BCF 0xFD6, 7, ACCESS
357:               //Perform the unlock sequence 
358:               NVMLOCK = 0x55;
152E0  0E55     MOVLW 0x55
152E2  6F42     MOVWF NVMLOCK, BANKED
359:               NVMLOCK = 0xAA;
152E4  0EAA     MOVLW 0xAA
152E6  6F42     MOVWF NVMLOCK, BANKED
360:               NVMCON0bits.GO = 1;             //Start byte write
152E8  8140     BSF NVMCON0, 0, BANKED
361:               while (NVMCON0bits.GO)          // Wait to complete
362:                   ;
152EA  B140     BTFSC NVMCON0, 0, BANKED
152EC  D7FE     BRA 0x52EA
363:               NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
152EE  0E07     MOVLW 0x7
152F0  1341     IORWF NVMCON1, F, BANKED
364:           #endif
365:               if (interruptEnabled) {     // Only enable interrupts if they were enabled at function entry
152F2  5005     MOVF 0x5, W, ACCESS
152F4  B4D8     BTFSC 0xFD8, 2, ACCESS
152F6  0012     RETURN 0
366:                   bothEi();                   /* Enable Interrupts */
152F8  8ED6     BSF 0xFD6, 7, ACCESS
367:               }
368:           }
152FA  0012     RETURN 0
369:           
370:           
371:           /**
372:            * Flush the current flash buffer out to flash.
373:            * Will suspend the CPU.
374:            */
375:           void flushFlashBlock(void) {
376:               uint8_t interruptEnabled;
377:           #if defined (_18F66K80_FAMILY_)
378:               TBLPTR = flashBlock; //force row boundary
379:               TBLPTRU = 0;
380:           #endif
381:           #if defined (_18FXXQ83_FAMILY_)
382:               
383:           #endif
384:               if (! flashFlags.writeNeeded) return;
15244  0105     MOVLB 0x5
15246  A1A6     BTFSS 0xA6, 0, BANKED
15248  0012     RETURN 0
385:               
386:               // Wait until App tells us it is a good time
387:               while (APP_isSuitableTimeToWriteFlash() == BAD_TIME)  // block awaiting a good time
1524A  EC4F     CALL 0x1629E, 0
1524C  F0B1     NOP
1524E  0900     IORLW 0x0
15250  B4D8     BTFSC 0xFD8, 2, ACCESS
15252  D7FB     BRA 0x524A
388:                   ;
389:                   
390:               if (flashFlags.eraseNeeded) {
15254  0105     MOVLB 0x5
15256  B3A6     BTFSC 0xA6, 1, BANKED
391:                   eraseFlashBlock();
15258  EC50     CALL 0x152A0, 0
1525A  F0A9     NOP
392:               }
393:               
394:               interruptEnabled = geti(); // store current global interrupt state
1525C  0E00     MOVLW 0x0
1525E  BED6     BTFSC 0xFD6, 7, ACCESS
15260  0E01     MOVLW 0x1
15262  6E06     MOVWF 0x6, ACCESS
395:               bothDi();     // disable all interrupts ERRATA says this is needed before TBLWT
15264  9ED6     BCF 0xFD6, 7, ACCESS
396:           #if defined (_18F66K80_FAMILY_)
397:               for (uint8_t i=0; i<FLASH_PAGE_SIZE; i++) {
398:                   TABLAT = flashBuffer[i];
399:                   asm("TBLWT*+");
400:               }
401:               // Note from data sheet: 
402:               //   Before setting the WR bit, the Table
403:               //   Pointer address needs to be within the
404:               //   intended address range of the 64 bytes in
405:               //   the holding register.
406:               // So we put it back into the block here
407:               TBLPTR = flashBlock;
408:               TBLPTRU = 0;
409:               EECON1bits.EEPGD = 1;   // 1=Program memory, 0=EEPROM
410:               EECON1bits.CFGS = 0;    // 0=ProgramMemory/EEPROM, 1=ConfigBits
411:               EECON1bits.FREE = 0;    // No erase
412:               EECON1bits.WREN = 1;    // enable write to memory
413:               
414:               EECON2 = 0x55;
415:               EECON2 = 0xAA;
416:               EECON1bits.WR = 1;
417:               EECON1bits.WREN = 0;
418:           #endif
419:           #if defined(_18FXXQ83_FAMILY_)
420:               // ready?
421:               while (NVMCON0bits.GO)
422:                   ;
15266  0100     MOVLB 0x0
15268  B140     BTFSC NVMCON0, 0, BANKED
1526A  D7FD     BRA 0x5266
423:               //Load NVMADR with the start address of the memory page
424:               /*NVMADRU = (uint8_t) (flashBlock >> 16);
425:               NVMADRH = (uint8_t) (flashBlock >> 8);
426:               NVMADRL = (uint8_t) flashBlock;*/
427:               NVMADR = flashBlock;
1526C  C5F8     MOVFF flashBlock, NVMADR
1526E  F043     NOP
15270  C5F9     MOVFF 0x5F9, NVMADRH
15272  F044     NOP
15274  C5FA     MOVFF 0x5FA, NVMADRU
15276  F045     NOP
428:           
429:               NVMCON1bits.NVMCMD = NVMCMD_WRITEPAGE;      //Set the page write command
15278  5141     MOVF NVMCON1, W, BANKED
1527A  0BF8     ANDLW 0xF8
1527C  0905     IORLW 0x5
1527E  6F41     MOVWF NVMCON1, BANKED
430:               //Perform the unlock sequence 
431:               NVMLOCK = 0x55;
15280  0E55     MOVLW 0x55
15282  6F42     MOVWF NVMLOCK, BANKED
432:               NVMLOCK = 0xAA;
15284  0EAA     MOVLW 0xAA
15286  6F42     MOVWF NVMLOCK, BANKED
433:               NVMCON0bits.GO = 1;             //Start byte write
15288  8140     BSF NVMCON0, 0, BANKED
434:               while (NVMCON0bits.GO)          // Wait to complete
435:           
436:                   ;
1528A  B140     BTFSC NVMCON0, 0, BANKED
1528C  D7FE     BRA 0x528A
437:               NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
1528E  0E07     MOVLW 0x7
15290  1341     IORWF NVMCON1, F, BANKED
438:           
439:           #endif
440:               if (interruptEnabled) {     // Only enable interrupts if they were enabled at function entry
15292  5006     MOVF 0x6, W, ACCESS
15294  A4D8     BTFSS 0xFD8, 2, ACCESS
441:                   bothEi();                   /* Enable Interrupts */
15296  8ED6     BSF 0xFD6, 7, ACCESS
442:               }
443:               flashFlags.asByte = 0;  // no erase, no write
15298  0E00     MOVLW 0x0
1529A  0105     MOVLB 0x5
1529C  6FA6     MOVWF 0xA6, BANKED
444:           }
1529E  0012     RETURN 0
445:           
446:           /**
447:            * Load an entire block of flash into the flash buffer.
448:            */
449:           void loadFlashBlock(void) {
450:           #if defined (_18F66K80_FAMILY_)
451:               EECON1=0X80;    // access to flash
452:               TBLPTR = flashBlock;
453:               TBLPTRU = 0;
454:               for (uint8_t i=0; i<64; i++) {
455:                   asm("TBLRD*+");
456:                   NOP();
457:                   flashBuffer[i] = TABLAT;
458:               }
459:               TBLPTR = flashBlock;
460:               TBLPTRU = 0;
461:           #endif
462:           #if defined(_18FXXQ83_FAMILY_)
463:               // ready?
464:               while (NVMCON0bits.GO)
15A06  0100     MOVLB 0x0
15A08  B140     BTFSC NVMCON0, 0, BANKED
15A0A  D7FD     BRA 0x5A06
465:                   ;
466:               //Load NVMADR with the starting address of the memory page
467:               NVMADRU = (uint8_t) (flashBlock >> 16);
15A0C  C5FA     MOVFF 0x5FA, NVMADRU
15A0E  F045     NOP
468:               NVMADRH = (uint8_t) (flashBlock >> 8);
15A10  C5F8     MOVFF flashBlock, i
15A12  F502     NOP
15A14  C5F9     MOVFF 0x5F9, opc
15A16  F503     NOP
15A18  C5FA     MOVFF 0x5FA, s
15A1A  F504     NOP
15A1C  C503     MOVFF opc, i
15A1E  F502     NOP
15A20  C504     MOVFF s, opc
15A22  F503     NOP
15A24  6A04     CLRF __activetblptr, ACCESS
15A26  5002     MOVF ___rparam_used, W, ACCESS
15A28  6F44     MOVWF NVMADRH, BANKED
469:               NVMADRL = (uint8_t) flashBlock;
15A2A  C5F8     MOVFF flashBlock, NVMADR
15A2C  F043     NOP
470:               NVMCON1bits.NVMCMD = NVMCMD_READPAGE;      //Set the page read command
15A2E  5141     MOVF NVMCON1, W, BANKED
15A30  0BF8     ANDLW 0xF8
15A32  0902     IORLW 0x2
15A34  6F41     MOVWF NVMCON1, BANKED
471:               NVMCON0bits.GO = 1;             //Start page read
15A36  8140     BSF NVMCON0, 0, BANKED
472:               while (NVMCON0bits.GO)          // Wait to complete
473:                   ;
15A38  B140     BTFSC NVMCON0, 0, BANKED
15A3A  D7FE     BRA 0x5A38
474:               NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
15A3C  0E07     MOVLW 0x7
15A3E  1341     IORWF NVMCON1, F, BANKED
475:           #endif
476:               flashFlags.asByte = 0; // no erase, no write needed
15A40  0E00     MOVLW 0x0
15A42  0105     MOVLB 0x5
15A44  6FA6     MOVWF 0xA6, BANKED
477:           }
15A46  0012     RETURN 0
478:              
479:           /**
480:            * Write a byte to Flash.
481:            * May block awaiting for the application to indicate that it is a suitable time
482:            * to allow the CPU to be halted.
483:            * @param index the address
484:            * @param value the value to be written
485:            * @return 0 for success or error otherwise
486:            */
487:           uint8_t FLASH_Write(flash_address_t index, flash_data_t value) {
488:               uint8_t oldValue;
489:               
490:               /*
491:                * Writing flash is a bit of a pain as you must write in blocks. If you want to
492:                * write just 1 byte then you need ensure you don't change any other byte in the
493:                * block. To do this the block must be read into a buffer the byte changed 
494:                * and then the whole buffer written. Unfortunately this algorithm would cause
495:                * too many writes to happen and the flash would wear out.
496:                * Instead after reading the block and updating the byte we don't write the
497:                * buffer back in case there is another update within the same block. The 
498:                * block is only written back if another block needs to be updated.
499:                * Whilst writing back if any bit changes from 0 to 1 then the block needs
500:                * to be erased before writing.
501:                *
502:                */
503:               if (BLOCK(index) != flashBlock) {
13A50  0E00     MOVLW 0x0
13A52  1407     ANDWF 0x7, W, ACCESS
13A54  6E0B     MOVWF 0xB, ACCESS
13A56  0EFF     MOVLW 0xFF
13A58  1408     ANDWF 0x8, W, ACCESS
13A5A  6E0C     MOVWF 0xC, ACCESS
13A5C  0EFF     MOVLW 0xFF
13A5E  1409     ANDWF 0x9, W, ACCESS
13A60  6E0D     MOVWF 0xD, ACCESS
13A62  0105     MOVLB 0x5
13A64  51F8     MOVF DMAnSSZH, W, BANKED
13A66  180B     XORWF 0xB, W, ACCESS
13A68  E107     BNZ 0x3A78
13A6A  51F9     MOVF DMAnSSA, W, BANKED
13A6C  180C     XORWF 0xC, W, ACCESS
13A6E  E104     BNZ 0x3A78
13A70  51FA     MOVF DMAnSSAH, W, BANKED
13A72  180D     XORWF 0xD, W, ACCESS
13A74  B4D8     BTFSC 0xFD8, 2, ACCESS
13A76  D019     BRA 0x3AAA
504:                   if (flashBlock != 0) {
13A78  51F8     MOVF DMAnSSZH, W, BANKED
13A7A  11F9     IORWF DMAnSSA, W, BANKED
13A7C  11FA     IORWF DMAnSSAH, W, BANKED
13A7E  B4D8     BTFSC 0xFD8, 2, ACCESS
13A80  D008     BRA 0x3A92
505:                       // ok we want to write a different block so flush the current block 
506:                       if (flashFlags.eraseNeeded) {
13A82  A3A6     BTFSS 0xA6, 1, BANKED
13A84  D004     BRA 0x3A8E
507:                           eraseFlashBlock();
13A86  EC50     CALL 0x152A0, 0
13A88  F0A9     NOP
508:                           flashFlags.eraseNeeded = 0;
13A8A  0105     MOVLB 0x5
13A8C  93A6     BCF 0xA6, 1, BANKED
509:                       }
510:           
511:                       flushFlashBlock();
13A8E  EC22     CALL 0x15244, 0
13A90  F0A9     NOP
512:                   }
513:                   
514:                   // and load the new one
515:                   flashBlock = BLOCK(index);
13A92  0E00     MOVLW 0x0
13A94  1407     ANDWF 0x7, W, ACCESS
13A96  0105     MOVLB 0x5
13A98  6FF8     MOVWF DMAnSSZH, BANKED
13A9A  0EFF     MOVLW 0xFF
13A9C  1408     ANDWF 0x8, W, ACCESS
13A9E  6FF9     MOVWF DMAnSSA, BANKED
13AA0  0EFF     MOVLW 0xFF
13AA2  1409     ANDWF 0x9, W, ACCESS
13AA4  6FFA     MOVWF DMAnSSAH, BANKED
516:                   loadFlashBlock();
13AA6  EC03     CALL 0x15A06, 0
13AA8  F0AD     NOP
517:               }
518:               flashFlags.eraseNeeded |= (value & ~flashBuffer[OFFSET(index)])?1:0;
13AAA  0EFF     MOVLW 0xFF
13AAC  1407     ANDWF 0x7, W, ACCESS
13AAE  6E0B     MOVWF 0xB, ACCESS
13AB0  0E00     MOVLW 0x0
13AB2  1408     ANDWF 0x8, W, ACCESS
13AB4  6E0C     MOVWF 0xC, ACCESS
13AB6  0E00     MOVLW 0x0
13AB8  240B     ADDWF 0xB, W, ACCESS
13ABA  6ED9     MOVWF 0xFD9, ACCESS
13ABC  0E37     MOVLW 0x37
13ABE  200C     ADDWFC 0xC, W, ACCESS
13AC0  6EDA     MOVWF 0xFDA, ACCESS
13AC2  50DF     MOVF 0xFDF, W, ACCESS
13AC4  0AFF     XORLW 0xFF
13AC6  140A     ANDWF 0xA, W, ACCESS
13AC8  0900     IORLW 0x0
13ACA  B4D8     BTFSC 0xFD8, 2, ACCESS
13ACC  D003     BRA 0x3AD4
13ACE  6A0D     CLRF 0xD, ACCESS
13AD0  2A0D     INCF 0xD, F, ACCESS
13AD2  D001     BRA 0x3AD6
13AD4  6A0D     CLRF 0xD, ACCESS
13AD6  0105     MOVLB 0x5
13AD8  31A6     RRCF 0xA6, W, BANKED
13ADA  0B01     ANDLW 0x1
13ADC  6E0E     MOVWF 0xE, ACCESS
13ADE  500D     MOVF 0xD, W, ACCESS
13AE0  120E     IORWF 0xE, F, ACCESS
13AE2  360E     RLCF 0xE, F, ACCESS
13AE4  51A6     MOVF 0xA6, W, BANKED
13AE6  180E     XORWF 0xE, W, ACCESS
13AE8  0BFD     ANDLW 0xFD
13AEA  180E     XORWF 0xE, W, ACCESS
13AEC  6FA6     MOVWF 0xA6, BANKED
519:               if (flashBuffer[OFFSET(index)] != value) {
13AEE  0EFF     MOVLW 0xFF
13AF0  1407     ANDWF 0x7, W, ACCESS
13AF2  6E0B     MOVWF 0xB, ACCESS
13AF4  0E00     MOVLW 0x0
13AF6  1408     ANDWF 0x8, W, ACCESS
13AF8  6E0C     MOVWF 0xC, ACCESS
13AFA  0E00     MOVLW 0x0
13AFC  240B     ADDWF 0xB, W, ACCESS
13AFE  6ED9     MOVWF 0xFD9, ACCESS
13B00  0E37     MOVLW 0x37
13B02  200C     ADDWFC 0xC, W, ACCESS
13B04  6EDA     MOVWF 0xFDA, ACCESS
13B06  500A     MOVF 0xA, W, ACCESS
13B08  18DE     XORWF 0xFDE, W, ACCESS
13B0A  B4D8     BTFSC 0xFD8, 2, ACCESS
13B0C  D00F     BRA 0x3B2C
520:                   flashFlags.writeNeeded = 1;
13B0E  81A6     BSF 0xA6, 0, BANKED
521:                   flashBuffer[OFFSET(index)] = value;
13B10  0EFF     MOVLW 0xFF
13B12  1407     ANDWF 0x7, W, ACCESS
13B14  6E0B     MOVWF 0xB, ACCESS
13B16  0E00     MOVLW 0x0
13B18  1408     ANDWF 0x8, W, ACCESS
13B1A  6E0C     MOVWF 0xC, ACCESS
13B1C  0E00     MOVLW 0x0
13B1E  240B     ADDWF 0xB, W, ACCESS
13B20  6ED9     MOVWF 0xFD9, ACCESS
13B22  0E37     MOVLW 0x37
13B24  200C     ADDWFC 0xC, W, ACCESS
13B26  6EDA     MOVWF 0xFDA, ACCESS
13B28  C50A     MOVFF index, INDF2
13B2A  F4DF     NOP
522:               }
523:               return GRSP_OK;
13B2C  0E00     MOVLW 0x0
524:           }
13B2E  0012     RETURN 0
525:           
526:           /**
527:            * Write a single byte to NVM.
528:            * @param type the type of memory to access
529:            * @param index the memory address
530:            * @param value the value to be written
531:            * @return 0 for success, error otherwise
532:            */
533:           uint8_t writeNVM(NVMtype type, uint24_t index, uint8_t value) {
156FC  6E16     MOVWF 0x16, ACCESS
534:               switch(type) {
156FE  D016     BRA 0x572C
535:                   case EEPROM_NVM_TYPE:
536:                       return EEPROM_Write((eeprom_address_t)index, value);
15700  C510     MOVFF receivedCanId, index
15702  F508     NOP
15704  C511     MOVFF m, d
15706  F509     NOP
15708  C512     MOVFF i, index
1570A  F50A     NOP
1570C  C513     MOVFF hi, index
1570E  F50B     NOP
15710  ECB9     CALL 0x14972, 0
15712  F0A4     NOP
15714  0012     RETURN 0
537:                   case FLASH_NVM_TYPE:
538:                       return FLASH_Write((flash_address_t)index, value);
15716  C510     MOVFF receivedCanId, i
15718  F507     NOP
1571A  C511     MOVFF m, index
1571C  F508     NOP
1571E  C512     MOVFF i, d
15720  F509     NOP
15722  C513     MOVFF hi, index
15724  F50A     NOP
15726  EC28     CALL 0x13A50, 0
15728  F09D     NOP
1572A  0012     RETURN 0
539:                   default:
540:                       return GRSP_UNKNOWN_NVM_TYPE;
541:               }
1572C  5016     MOVF 0x16, W, ACCESS
1572E  6E14     MOVWF 0x14, ACCESS
15730  6A15     CLRF 0x15, ACCESS
15732  5015     MOVF 0x15, W, ACCESS
15734  0A00     XORLW 0x0
15736  A4D8     BTFSS 0xFD8, 2, ACCESS
15738  0012     RETURN 0
1573A  5014     MOVF 0x14, W, ACCESS
1573C  0A00     XORLW 0x0
1573E  B4D8     BTFSC 0xFD8, 2, ACCESS
15740  D7DF     BRA 0x5700
15742  0A01     XORLW 0x1
15744  A4D8     BTFSS 0xFD8, 2, ACCESS
15744  A4D8     BTFSS 0xFD8, 2, ACCESS
15744  A4D8     BTFSS 0xFD8, 2, ACCESS
542:           }
543:           
544:           /**
545:            * Read a single byte of NVM.
546:            * @param type the type of memory to be accessed
547:            * @param index the address
548:            * @return the value if >=0, -error otherwise
549:            */
550:           int16_t readNVM(NVMtype type, uint24_t index) {
151E6  6E0D     MOVWF 0xD, ACCESS
551:               switch(type) {
151E8  D01E     BRA 0x5226
552:                   case EEPROM_NVM_TYPE:
553:                       return EEPROM_Read((uint16_t)index);
151EA  C508     MOVFF index, i
151EC  F502     NOP
151EE  C509     MOVFF d, opc
151F0  F503     NOP
151F2  6A04     CLRF __activetblptr, ACCESS
151F4  EC0C     CALL 0x15C18, 0
151F6  F0AE     NOP
151F8  6E0B     MOVWF 0xB, ACCESS
151FA  500B     MOVF 0xB, W, ACCESS
151FC  6E08     MOVWF 0x8, ACCESS
151FE  6A09     CLRF 0x9, ACCESS
15200  0012     RETURN 0
554:                   case FLASH_NVM_TYPE:
555:           #if defined(_18F66K80_FAMILY_)
556:                       return FLASH_Read((uint16_t)index);
557:           #endif
558:           #if defined(_18FXXQ83_FAMILY_)
559:                       return FLASH_Read(index);
15202  C508     MOVFF index, i
15204  F502     NOP
15206  C509     MOVFF d, opc
15208  F503     NOP
1520A  C50A     MOVFF index, s
1520C  F504     NOP
1520E  EC99     CALL 0x14F32, 0
15210  F0A7     NOP
15212  6E0B     MOVWF 0xB, ACCESS
15214  500B     MOVF 0xB, W, ACCESS
15216  6E08     MOVWF 0x8, ACCESS
15218  6A09     CLRF 0x9, ACCESS
1521A  0012     RETURN 0
560:           #endif
561:                   default:
562:                       return -GRSP_UNKNOWN_NVM_TYPE;
1521C  0EFF     MOVLW 0xFF
1521E  6E09     MOVWF 0x9, ACCESS
15220  0E02     MOVLW 0x2
15222  6E08     MOVWF 0x8, ACCESS
15224  0012     RETURN 0
563:               }
15226  500D     MOVF 0xD, W, ACCESS
15228  6E0B     MOVWF 0xB, ACCESS
1522A  6A0C     CLRF 0xC, ACCESS
1522C  500C     MOVF 0xC, W, ACCESS
1522E  0A00     XORLW 0x0
15230  A4D8     BTFSS 0xFD8, 2, ACCESS
15232  D7F4     BRA 0x521C
15234  500B     MOVF 0xB, W, ACCESS
15236  0A00     XORLW 0x0
15238  B4D8     BTFSC 0xFD8, 2, ACCESS
1523A  D7D7     BRA 0x51EA
1523C  0A01     XORLW 0x1
1523E  B4D8     BTFSC 0xFD8, 2, ACCESS
1523E  B4D8     BTFSC 0xFD8, 2, ACCESS
1523E  B4D8     BTFSC 0xFD8, 2, ACCESS
564:           }
565:           
566:           
567:               
---  C:/Users/ianwh/github/VLCBlib_PIC/nv.c  ------------------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:              Ian Hogg Nov 2022
36:             */
37:            
38:            /**
39:             * @file
40:             * @brief
41:             * Implementation of the VLCB NV Service.
42:             * @details
43:             * The service definition object is called nvService.
44:             *
45:             * The NV service implements the VLCB Node Variable Service. This supports 
46:             * the NVSET, NVRD and NVSETRD opcodes.
47:             * 
48:             * If NV_CACHE is defined in module.h then the NV service implements a cache
49:             * of NV values in RAM. This can be used to speed up obtaining NV values used 
50:             * within the application at the expense of additional RAM usage.
51:             */
52:            
53:            #include <xc.h>
54:            #include "vlcb.h"
55:            #include "module.h"
56:            #include "nv.h"
57:            #include "mns.h"
58:            #include "nvm.h"
59:            #include "timedResponse.h"
60:            
61:            // forward declarations
62:            /**
63:             * Load the NV cache using values stored in non volatile memory.
64:             */
65:            void loadNvCache(void);
66:            static void nvFactoryReset(void);
67:            static void nvPowerUp(void);
68:            static Processed nvProcessMessage(Message *m);
69:            static uint8_t nvGetESDdata(uint8_t id);
70:            TimedResponseResult nvTRnvrdCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
71:            #ifdef VLCB_DIAG
72:            static DiagnosticVal * nvGetDiagnostic(uint8_t index);
73:            static DiagnosticVal nvDiagnostics[NUM_NV_DIAGNOSTICS+1];
74:            #endif
75:            
76:            /**
77:             * The service descriptor for the NV service. The application must include this
78:             * descriptor within the const Service * const services[] array and include the
79:             * necessary settings within module.h in order to make use of the Node Variable
80:             * service.
81:             */
82:            const Service nvService = {
83:                SERVICE_ID_NV,      // id
84:                1,                  // version
85:                nvFactoryReset,     // factoryReset
86:                nvPowerUp,          // powerUp
87:                nvProcessMessage,   // processMessage
88:                NULL,               // poll
89:            #if defined(_18F66K80_FAMILY_)
90:                NULL,               // highIsr
91:                NULL,               // lowIsr
92:            #endif
93:            #ifdef VLCB_SERVICE
94:                nvGetESDdata,       // get ESD data
95:            #endif
96:            #ifdef VLCB_DIAG
97:                nvGetDiagnostic     // getDiagnostic
98:            #endif
99:            };
100:           
101:           
102:           
103:           /**
104:            *  nv cache
105:            */
106:           #ifdef NV_CACHE
107:           static uint8_t nvCache[NV_NUM+1];
108:           #endif
109:           
110:           /**
111:            * Function to be provided by the application to be called by the VLCB library
112:            * whenever an NV value is changed.
113:            * Allows the application to perform special actions upon NV change.
114:            */
115:           extern void APP_nvValueChanged(uint8_t index, uint8_t value, uint8_t oldValue);
116:           /**
117:            * Function to be provided by the application to be called by the VLCB library
118:            * to determine the application's default value of an NV.
119:            */
120:           extern uint8_t APP_nvDefault(uint8_t index);
121:           
122:           /**
123:            * The factoryReset for the NV service. Requests the application for defaults
124:            * for each NV and write those values to the non-volatile memory (NVM) store.
125:            */
126:           static void nvFactoryReset(void) {
127:               uint8_t i;
128:               for (i=1; i<= NV_NUM; i++) {
15BE2  0E01     MOVLW 0x1
15BE4  6E19     MOVWF 0x19, ACCESS
129:                   writeNVM(NV_NVM_TYPE, NV_ADDRESS+i, APP_nvDefault(i));
15BE6  0E00     MOVLW 0x0
15BE8  2419     ADDWF 0x19, W, ACCESS
15BEA  6E17     MOVWF 0x17, ACCESS
15BEC  6A18     CLRF 0x18, ACCESS
15BEE  0E02     MOVLW 0x2
15BF0  2218     ADDWFC 0x18, F, ACCESS
15BF2  C517     MOVFF tableIndex, receivedCanId
15BF4  F510     NOP
15BF6  C518     MOVFF evIdx, m
15BF8  F511     NOP
15BFA  6A12     CLRF 0x12, ACCESS
15BFC  BE11     BTFSC 0x11, 7, ACCESS
15BFE  0612     DECF 0x12, F, ACCESS
15C00  5019     MOVF 0x19, W, ACCESS
15C02  EC0C     CALL 0x16218, 0
15C04  F0B1     NOP
15C06  6E13     MOVWF 0x13, ACCESS
15C08  0E00     MOVLW 0x0
15C0A  EC7E     CALL 0x156FC, 0
15C0C  F0AB     NOP
130:               }
15C0E  2A19     INCF 0x19, F, ACCESS
15C0E  2A19     INCF 0x19, F, ACCESS
15C0E  2A19     INCF 0x19, F, ACCESS
15C0E  2A19     INCF 0x19, F, ACCESS
15C0E  2A19     INCF 0x19, F, ACCESS
131:           }
132:           
133:           /**
134:            * Upon power up read the NV values from NVM and fill the NV cache.
135:            */
136:           static void nvPowerUp(void) {
137:           #ifdef VLCB_DIAG
138:               uint8_t i;
139:               for (i=1; i <= NUM_NV_DIAGNOSTICS; i++) {
15CE8  0E01     MOVLW 0x1
15CEA  6E13     MOVWF 0x13, ACCESS
140:                   nvDiagnostics[i].asUint = 0;
15CEC  5013     MOVF 0x13, W, ACCESS
15CEE  0D02     MULLW 0x2
15CF0  0EC5     MOVLW 0xC5
15CF2  24F3     ADDWF 0xFF3, W, ACCESS
15CF4  6ED9     MOVWF 0xFD9, ACCESS
15CF6  0E05     MOVLW 0x5
15CF8  20F4     ADDWFC 0xFF4, W, ACCESS
15CFA  6EDA     MOVWF 0xFDA, ACCESS
15CFC  6ADE     CLRF 0xFDE, ACCESS
15CFE  6ADD     CLRF 0xFDD, ACCESS
141:               }
15D00  2A13     INCF 0x13, F, ACCESS
15D02  0E02     MOVLW 0x2
15D04  6413     CPFSGT 0x13, ACCESS
15D06  D7F2     BRA 0x5CEC
142:               nvDiagnostics[NV_DIAG_COUNT].asUint = NUM_NV_DIAGNOSTICS;
15D08  0E00     MOVLW 0x0
15D0A  0105     MOVLB 0x5
15D0C  6FC6     MOVWF 0xC6, BANKED
15D0E  0E02     MOVLW 0x2
15D10  6FC5     MOVWF 0xC5, BANKED
143:           #endif
144:           #ifdef NV_CACHE
145:               loadNvCache();
15D12  ECCB     CALL 0x15796, 0
15D14  F0AB     NOP
146:           #endif
147:           }
15D16  0012     RETURN 0
148:           
149:           #ifdef VLCB_DIAG
150:           static DiagnosticVal * nvGetDiagnostic(uint8_t index) {
1600A  6E0A     MOVWF 0xA, ACCESS
151:               if (index > NUM_NV_DIAGNOSTICS) {
1600C  0E02     MOVLW 0x2
1600E  640A     CPFSGT 0xA, ACCESS
16010  D005     BRA 0x601C
152:                   return NULL;
16012  0E00     MOVLW 0x0
16014  6E08     MOVWF 0x8, ACCESS
16016  0E00     MOVLW 0x0
16018  6E09     MOVWF 0x9, ACCESS
1601A  0012     RETURN 0
153:               }
154:               return &(nvDiagnostics[index]);
1601C  500A     MOVF 0xA, W, ACCESS
1601E  0D02     MULLW 0x2
16020  0EC5     MOVLW 0xC5
16022  24F3     ADDWF 0xFF3, W, ACCESS
16024  6E08     MOVWF 0x8, ACCESS
16026  0E05     MOVLW 0x5
16028  20F4     ADDWFC 0xFF4, W, ACCESS
1602A  6E09     MOVWF 0x9, ACCESS
155:           }
1602C  0012     RETURN 0
156:           #endif
157:           
158:           #ifdef NV_CACHE
159:           /**
160:            * Load the NV cache using values stored in non volatile memory.
161:            */
162:           void loadNvCache(void) {
163:               uint8_t i;
164:               int16_t temp;
165:               
166:               for (i=1; i<= NV_NUM; i++) {
15796  0E01     MOVLW 0x1
15798  6E12     MOVWF 0x12, ACCESS
167:                   temp = readNVM(NV_NVM_TYPE, NV_ADDRESS+i);
1579A  0E00     MOVLW 0x0
1579C  2412     ADDWF 0x12, W, ACCESS
1579E  6E0E     MOVWF 0xE, ACCESS
157A0  6A0F     CLRF 0xF, ACCESS
157A2  0E02     MOVLW 0x2
157A4  220F     ADDWFC 0xF, F, ACCESS
157A6  C50E     MOVFF evNum, index
157A8  F508     NOP
157AA  C50F     MOVFF interruptEnabled, d
157AC  F509     NOP
157AE  6A0A     CLRF 0xA, ACCESS
157B0  BE09     BTFSC 0x9, 7, ACCESS
157B2  060A     DECF 0xA, F, ACCESS
157B4  0E00     MOVLW 0x0
157B6  ECF3     CALL 0x151E6, 0
157B8  F0A8     NOP
157BA  C508     MOVFF index, receivedCanId
157BC  F510     NOP
157BE  C509     MOVFF d, m
157C0  F511     NOP
168:                   if (temp < 0) {
157C2  BE11     BTFSC 0x11, 7, ACCESS
157C4  D008     BRA 0x57D6
169:                       // unsure how to handle an error here
170:                   } else {
171:                       nvCache[i] = (uint8_t)temp;
157C6  0E97     MOVLW 0x97
157C8  2412     ADDWF 0x12, W, ACCESS
157CA  6ED9     MOVWF 0xFD9, ACCESS
157CC  6ADA     CLRF 0xFDA, ACCESS
157CE  0E05     MOVLW 0x5
157D0  22DA     ADDWFC 0xFDA, F, ACCESS
157D2  C510     MOVFF receivedCanId, INDF2
157D4  F4DF     NOP
172:                   }
173:               }
157D6  2A12     INCF 0x12, F, ACCESS
157D6  2A12     INCF 0x12, F, ACCESS
157D6  2A12     INCF 0x12, F, ACCESS
157D6  2A12     INCF 0x12, F, ACCESS
157D6  2A12     INCF 0x12, F, ACCESS
174:           }
175:           #endif
176:           
177:           /**
178:            * Get the value of an NV. Either obtained from the cache or from NVM.
179:            * @param index the NV index
180:            * @return the NV value
181:            */
182:           int16_t getNV(uint8_t index) {
15B72  6E05     MOVWF 0x5, ACCESS
183:               if (index == 0) return NV_NUM;
15B74  5005     MOVF 0x5, W, ACCESS
15B76  A4D8     BTFSS 0xFD8, 2, ACCESS
15B78  D005     BRA 0x5B84
15B7A  0E00     MOVLW 0x0
15B7C  6E03     MOVWF __activetblptr, ACCESS
15B7E  0E01     MOVLW 0x1
15B80  6E02     MOVWF ___rparam_used, ACCESS
15B82  0012     RETURN 0
184:               if (index > NV_NUM) return -CMDERR_INV_NV_IDX;
15B84  0E01     MOVLW 0x1
15B86  6405     CPFSGT 0x5, ACCESS
15B88  D005     BRA 0x5B94
15B8A  0EFF     MOVLW 0xFF
15B8C  6E03     MOVWF __activetblptr, ACCESS
15B8E  0EF6     MOVLW 0xF6
15B90  6E02     MOVWF ___rparam_used, ACCESS
15B92  0012     RETURN 0
185:           #ifdef NV_CACHE
186:               return nvCache[index];
15B94  0E97     MOVLW 0x97
15B96  2405     ADDWF 0x5, W, ACCESS
15B98  6ED9     MOVWF 0xFD9, ACCESS
15B9A  6ADA     CLRF 0xFDA, ACCESS
15B9C  0E05     MOVLW 0x5
15B9E  22DA     ADDWFC 0xFDA, F, ACCESS
15BA0  50DF     MOVF 0xFDF, W, ACCESS
15BA2  6E04     MOVWF __activetblptr, ACCESS
15BA4  5004     MOVF __activetblptr, W, ACCESS
15BA6  6E02     MOVWF ___rparam_used, ACCESS
15BA8  6A03     CLRF __activetblptr, ACCESS
187:           #else
188:               return readNVM(NV_NVM_TYPE, NV_ADDRESS+index);
189:           #endif
190:           }
15BAA  0012     RETURN 0
191:           
192:           /**
193:            * Save (write) the value of an NV.
194:            * Does no validation and does not call back into the application.
195:            * 
196:            * @param index the NV index
197:            * @param value the value of the NV to be written 
198:            */
199:           void saveNV(uint8_t index, uint8_t value) {
200:           #ifdef NV_CACHE
201:               nvCache[index] = value;
202:           #endif
203:               writeNVM(NV_NVM_TYPE, NV_ADDRESS+index, value);
204:           }
205:           
206:           /**
207:            * Set (write) the value of an NV.
208:            * The module's application is called (APP_nvValidate) to check that the 
209:            * value being written is valid.
210:            * After updating the NV the application's function APP_nvValueChanged is
211:            * called so that the application can perform any related checks, changes or 
212:            * functionality.
213:            * 
214:            * @param index the NV index
215:            * @param value the value of the NV to be written 
216:            * @return 0 for no error otherwise the error
217:            */
218:           uint8_t setNV(uint8_t index, uint8_t value) {
14A60  6E1B     MOVWF 0x1B, ACCESS
219:               uint8_t oldValue;
220:               
221:               if (index > NV_NUM) return CMDERR_INV_NV_IDX;
14A62  0E01     MOVLW 0x1
14A64  641B     CPFSGT 0x1B, ACCESS
14A66  D002     BRA 0x4A6C
14A68  0E0A     MOVLW 0xA
14A6A  0012     RETURN 0
222:               if (APP_nvValidate(index, value) == INVALID) return CMDERR_INV_NV_VALUE;
14A6C  C517     MOVFF tableIndex, i
14A6E  F502     NOP
14A70  501B     MOVF 0x1B, W, ACCESS
14A72  EC15     CALL 0x1622A, 0
14A74  F0B1     NOP
14A76  0900     IORLW 0x0
14A78  A4D8     BTFSS 0xFD8, 2, ACCESS
14A7A  D002     BRA 0x4A80
14A7C  0E0C     MOVLW 0xC
14A7E  0012     RETURN 0
223:           #ifdef NV_CACHE
224:               oldValue = nvCache[index];
14A80  0E97     MOVLW 0x97
14A82  241B     ADDWF 0x1B, W, ACCESS
14A84  6ED9     MOVWF 0xFD9, ACCESS
14A86  6ADA     CLRF 0xFDA, ACCESS
14A88  0E05     MOVLW 0x5
14A8A  22DA     ADDWFC 0xFDA, F, ACCESS
14A8C  50DF     MOVF 0xFDF, W, ACCESS
14A8E  6E1A     MOVWF 0x1A, ACCESS
225:               nvCache[index] = value;
14A90  0E97     MOVLW 0x97
14A92  241B     ADDWF 0x1B, W, ACCESS
14A94  6ED9     MOVWF 0xFD9, ACCESS
14A96  6ADA     CLRF 0xFDA, ACCESS
14A98  0E05     MOVLW 0x5
14A9A  22DA     ADDWFC 0xFDA, F, ACCESS
14A9C  C517     MOVFF tableIndex, INDF2
14A9E  F4DF     NOP
226:               writeNVM(NV_NVM_TYPE, NV_ADDRESS+index, value);
14AA0  0E00     MOVLW 0x0
14AA2  241B     ADDWF 0x1B, W, ACCESS
14AA4  6E18     MOVWF 0x18, ACCESS
14AA6  6A19     CLRF 0x19, ACCESS
14AA8  0E02     MOVLW 0x2
14AAA  2219     ADDWFC 0x19, F, ACCESS
14AAC  C518     MOVFF evIdx, receivedCanId
14AAE  F510     NOP
14AB0  C519     MOVFF tableIndex, m
14AB2  F511     NOP
14AB4  6A12     CLRF 0x12, ACCESS
14AB6  BE11     BTFSC 0x11, 7, ACCESS
14AB8  0612     DECF 0x12, F, ACCESS
14ABA  C517     MOVFF tableIndex, hi
14ABC  F513     NOP
14ABE  0E00     MOVLW 0x0
14AC0  EC7E     CALL 0x156FC, 0
14AC2  F0AB     NOP
227:           #else
228:               oldValue = (uint8_t)readNVM(NV_NVM_TYPE, NV_ADDRESS+index);
229:               writeNVM(NV_NVM_TYPE, NV_ADDRESS+index, value);
230:           #endif
231:               APP_nvValueChanged(index, value, oldValue);
14AC4  C517     MOVFF tableIndex, i
14AC6  F502     NOP
14AC8  C51A     MOVFF txFifoObj, opc
14ACA  F503     NOP
14ACC  501B     MOVF 0x1B, W, ACCESS
14ACE  EC52     CALL 0x162A4, 0
14AD0  F0B1     NOP
232:               return 0;
14AD2  0E00     MOVLW 0x0
233:           }
14AD4  0012     RETURN 0
234:           
235:           /**
236:            * Process the NV related messages.
237:            * @param m the VLCB message
238:            * @return PROCESSED if the message was processed, NOT_PROCESSED otherwise
239:            */
240:           static Processed nvProcessMessage(Message * m) {
241:               int16_t valueOrError;
242:               
243:               if (m->len < 3) {
11AC2  C546     MOVFF m, FSR2
11AC4  F4D9     NOP
11AC6  C547     MOVFF 0x547, FSR2H
11AC8  F4DA     NOP
11ACA  0E03     MOVLW 0x3
11ACC  60DF     CPFSLT 0xFDF, ACCESS
11ACE  D002     BRA 0x1AD4
244:                   return NOT_PROCESSED;
11AD0  0E00     MOVLW 0x0
11AD2  0012     RETURN 0
245:               }
246:               // check NN matches us
247:               if (m->bytes[0] != nn.bytes.hi) return NOT_PROCESSED;
11AD4  EE20     LFSR 2, 0x2
11AD6  F002     NOP
11AD8  5046     MOVF NVMDAT, W, ACCESS
11ADA  26D9     ADDWF 0xFD9, F, ACCESS
11ADC  5047     MOVF NVMDATH, W, ACCESS
11ADE  22DA     ADDWFC 0xFDA, F, ACCESS
11AE0  50DE     MOVF 0xFDE, W, ACCESS
11AE2  1854     XORWF 0x54, W, ACCESS
11AE4  A4D8     BTFSS 0xFD8, 2, ACCESS
11AE6  D7F4     BRA 0x1AD0
248:               if (m->bytes[1] != nn.bytes.lo) return NOT_PROCESSED;
11AE8  EE20     LFSR 2, 0x3
11AEA  F003     NOP
11AEC  5046     MOVF NVMDAT, W, ACCESS
11AEE  26D9     ADDWF 0xFD9, F, ACCESS
11AF0  5047     MOVF NVMDATH, W, ACCESS
11AF2  22DA     ADDWFC 0xFDA, F, ACCESS
11AF4  5053     MOVF 0x53, W, ACCESS
11AF6  18DE     XORWF 0xFDE, W, ACCESS
11AF8  A4D8     BTFSS 0xFD8, 2, ACCESS
11AFA  D7EA     BRA 0x1AD0
11AFC  D14A     BRA 0x1D92
249:               
250:               switch (m->opc) {
251:                   case OPC_NVRD:
252:                       if (m->len < 4) {
11AFE  C546     MOVFF m, FSR2
11B00  F4D9     NOP
11B02  C547     MOVFF 0x547, FSR2H
11B04  F4DA     NOP
11B06  0E04     MOVLW 0x4
11B08  60DF     CPFSLT 0xFDF, ACCESS
11B0A  D01B     BRA 0x1B42
253:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_CMD);
11B0C  C554     MOVFF 0x554, data1
11B0E  F525     NOP
11B10  C553     MOVFF nn, data2
11B12  F526     NOP
11B14  0E01     MOVLW 0x1
11B16  6E27     MOVWF 0x27, ACCESS
11B18  0E6F     MOVLW 0x6F
11B1A  EC3E     CALL 0x15E7C, 0
11B1C  F0AF     NOP
254:           #ifdef VLCB_GRSP
255:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVRD, SERVICE_ID_MNS, CMDERR_INV_CMD);
11B1E  C554     MOVFF 0x554, data1
11B20  F525     NOP
11B22  C553     MOVFF nn, data2
11B24  F526     NOP
11B26  0E71     MOVLW 0x71
11B28  6E27     MOVWF 0x27, ACCESS
11B2A  0E01     MOVLW 0x1
11B2C  6E28     MOVWF 0x28, ACCESS
11B2E  0E01     MOVLW 0x1
11B30  6E29     MOVWF 0x29, ACCESS
11B32  0EAF     MOVLW 0xAF
11B34  EC7D     CALL 0x15EFA, 0
11B36  F0AF     NOP
256:           #endif
257:           #ifdef VLCB_DIAG
258:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
11B38  0105     MOVLB 0x5
11B3A  4BC9     INFSNZ 0xC9, F, BANKED
11B3C  2BCA     INCF _writeConfigByte, F, BANKED
259:           #endif
260:                           return PROCESSED;
11B3E  0E01     MOVLW 0x1
11B40  0012     RETURN 0
261:                       }
262:                       valueOrError = getNV(m->bytes[2]);
11B42  EE20     LFSR 2, 0x4
11B44  F004     NOP
11B46  5046     MOVF NVMDAT, W, ACCESS
11B48  26D9     ADDWF 0xFD9, F, ACCESS
11B4A  5047     MOVF NVMDATH, W, ACCESS
11B4C  22DA     ADDWFC 0xFDA, F, ACCESS
11B4E  50DF     MOVF 0xFDF, W, ACCESS
11B50  ECB9     CALL 0x15B72, 0
11B52  F0AD     NOP
11B54  C502     MOVFF i, eventEN
11B56  F54A     NOP
11B58  C503     MOVFF opc, enn
11B5A  F54B     NOP
263:                       if (valueOrError < 0) {
11B5C  AE4B     BTFSS HLVDCON1, 7, ACCESS
11B5E  D019     BRA 0x1B92
264:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(-valueOrError));
11B60  C554     MOVFF 0x554, data1
11B62  F525     NOP
11B64  C553     MOVFF nn, data2
11B66  F526     NOP
11B68  504A     MOVF HLVDCON0, W, ACCESS
11B6A  0800     SUBLW 0x0
11B6C  6E27     MOVWF 0x27, ACCESS
11B6E  0E6F     MOVLW 0x6F
11B70  EC3E     CALL 0x15E7C, 0
11B72  F0AF     NOP
265:           #ifdef VLCB_GRSP
266:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVRD, SERVICE_ID_MNS, (uint8_t)(-valueOrError));
11B74  C554     MOVFF 0x554, data1
11B76  F525     NOP
11B78  C553     MOVFF nn, data2
11B7A  F526     NOP
11B7C  0E71     MOVLW 0x71
11B7E  6E27     MOVWF 0x27, ACCESS
11B80  0E01     MOVLW 0x1
11B82  6E28     MOVWF 0x28, ACCESS
11B84  504A     MOVF HLVDCON0, W, ACCESS
11B86  0800     SUBLW 0x0
11B88  6E29     MOVWF 0x29, ACCESS
11B8A  0EAF     MOVLW 0xAF
11B8C  EC7D     CALL 0x15EFA, 0
11B8E  F0AF     NOP
11B90  D7D3     BRA 0x1B38
267:           #endif
268:           #ifdef VLCB_DIAG
269:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
270:           #endif
271:                           return PROCESSED;
272:                       }
273:           #ifdef VLCB_DIAG
274:                       nvDiagnostics[NV_DIAGNOSTICS_NUM_ACCESS].asUint++;
11B92  0105     MOVLB 0x5
11B94  4BC7     INFSNZ 0xC7, F, BANKED
11B96  2BC8     INCF 0xC8, F, BANKED
275:           #endif
276:                       sendMessage4(OPC_NVANS, nn.bytes.hi, nn.bytes.lo, m->bytes[2], (uint8_t)(valueOrError));
11B98  C554     MOVFF 0x554, data1
11B9A  F525     NOP
11B9C  C553     MOVFF nn, data2
11B9E  F526     NOP
11BA0  EE20     LFSR 2, 0x4
11BA2  F004     NOP
11BA4  5046     MOVF NVMDAT, W, ACCESS
11BA6  26D9     ADDWF 0xFD9, F, ACCESS
11BA8  5047     MOVF NVMDATH, W, ACCESS
11BAA  22DA     ADDWFC 0xFDA, F, ACCESS
11BAC  50DF     MOVF 0xFDF, W, ACCESS
11BAE  6E27     MOVWF 0x27, ACCESS
11BB0  C54A     MOVFF eventEN, data4
11BB2  F528     NOP
11BB4  0E97     MOVLW 0x97
11BB6  EC92     CALL 0x15F24, 0
11BB8  F0AF     NOP
277:           #ifdef VLCB_ZERO_RESPONSES
278:                       if (m->bytes[2] == 0) {
11BBA  EE20     LFSR 2, 0x4
11BBC  F004     NOP
11BBE  5046     MOVF NVMDAT, W, ACCESS
11BC0  26D9     ADDWF 0xFD9, F, ACCESS
11BC2  5047     MOVF NVMDATH, W, ACCESS
11BC4  22DA     ADDWFC 0xFDA, F, ACCESS
11BC6  50DF     MOVF 0xFDF, W, ACCESS
11BC8  A4D8     BTFSS 0xFD8, 2, ACCESS
11BCA  D7B9     BRA 0x1B3E
279:                           // a NVANS response for all of the NVs
280:                           startTimedResponse(TIMED_RESPONSE_NVRD, findServiceIndex(SERVICE_ID_NV), nvTRnvrdCallback);
11BCC  0E02     MOVLW 0x2
11BCE  EC18     CALL 0x14C30, 0
11BD0  F0A6     NOP
11BD2  6E06     MOVWF 0x6, ACCESS
11BD4  0E86     MOVLW 0x86
11BD6  6E07     MOVWF 0x7, ACCESS
11BD8  0E5A     MOVLW 0x5A
11BDA  6E08     MOVWF 0x8, ACCESS
11BDC  0E01     MOVLW 0x1
11BDE  6E09     MOVWF 0x9, ACCESS
11BE0  0E06     MOVLW 0x6
11BE2  ECE2     CALL 0x159C4, 0
11BE4  F0AC     NOP
11BE6  D7AB     BRA 0x1B3E
281:                       }
282:           #endif
283:                       return PROCESSED;
284:                   case OPC_NVSET:
285:                       if (m->len < 5) {
11BE8  C546     MOVFF m, FSR2
11BEA  F4D9     NOP
11BEC  C547     MOVFF 0x547, FSR2H
11BEE  F4DA     NOP
11BF0  0E05     MOVLW 0x5
11BF2  60DF     CPFSLT 0xFDF, ACCESS
11BF4  D00E     BRA 0x1C12
286:           //                sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_CMD);
287:           #ifdef VLCB_GRSP
288:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSET, SERVICE_ID_MNS, CMDERR_INV_CMD);
11BF6  C554     MOVFF 0x554, data1
11BF8  F525     NOP
11BFA  C553     MOVFF nn, data2
11BFC  F526     NOP
11BFE  0E96     MOVLW 0x96
11C00  6E27     MOVWF 0x27, ACCESS
11C02  0E01     MOVLW 0x1
11C04  6E28     MOVWF 0x28, ACCESS
11C06  0E01     MOVLW 0x1
11C08  6E29     MOVWF 0x29, ACCESS
11C0A  0EAF     MOVLW 0xAF
11C0C  EC7D     CALL 0x15EFA, 0
11C0E  F0AF     NOP
11C10  D793     BRA 0x1B38
289:           #endif
290:           #ifdef VLCB_DIAG
291:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
292:           #endif
293:                           return PROCESSED;
294:                       }
295:                       valueOrError = setNV(m->bytes[2], m->bytes[3]);
11C12  EE20     LFSR 2, 0x5
11C14  F005     NOP
11C16  5046     MOVF NVMDAT, W, ACCESS
11C18  26D9     ADDWF 0xFD9, F, ACCESS
11C1A  5047     MOVF NVMDATH, W, ACCESS
11C1C  22DA     ADDWFC 0xFDA, F, ACCESS
11C1E  50DF     MOVF 0xFDF, W, ACCESS
11C20  6E17     MOVWF 0x17, ACCESS
11C22  EE20     LFSR 2, 0x4
11C24  F004     NOP
11C26  5046     MOVF NVMDAT, W, ACCESS
11C28  26D9     ADDWF 0xFD9, F, ACCESS
11C2A  5047     MOVF NVMDATH, W, ACCESS
11C2C  22DA     ADDWFC 0xFDA, F, ACCESS
11C2E  50DF     MOVF 0xFDF, W, ACCESS
11C30  EC30     CALL 0x14A60, 0
11C32  F0A5     NOP
11C34  6E48     MOVWF VREGCON, ACCESS
11C36  5048     MOVF VREGCON, W, ACCESS
11C38  6E4A     MOVWF HLVDCON0, ACCESS
11C3A  6A4B     CLRF HLVDCON1, ACCESS
296:                       if (valueOrError >0) {
11C3C  BE4B     BTFSC HLVDCON1, 7, ACCESS
11C3E  D00F     BRA 0x1C5E
11C40  504B     MOVF HLVDCON1, W, ACCESS
11C42  E103     BNZ 0x1C4A
11C44  044A     DECF HLVDCON0, W, ACCESS
11C46  A0D8     BTFSS 0xFD8, 0, ACCESS
11C48  D00A     BRA 0x1C5E
297:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(valueOrError));
11C4A  C554     MOVFF 0x554, data1
11C4C  F525     NOP
11C4E  C553     MOVFF nn, data2
11C50  F526     NOP
11C52  C54A     MOVFF eventEN, data3
11C54  F527     NOP
11C56  0E6F     MOVLW 0x6F
11C58  EC3E     CALL 0x15E7C, 0
11C5A  F0AF     NOP
11C5C  D76D     BRA 0x1B38
298:           //                sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSET, SERVICE_ID_MNS, (uint8_t)(valueOrError));
299:           #ifdef VLCB_DIAG
300:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
301:           #endif
302:                           return PROCESSED;
303:                       }
304:                       sendMessage2(OPC_WRACK, nn.bytes.hi, nn.bytes.lo);
11C5E  C554     MOVFF 0x554, data1
11C60  F525     NOP
11C62  C553     MOVFF nn, data2
11C64  F526     NOP
11C66  0E59     MOVLW 0x59
11C68  EC53     CALL 0x15EA6, 0
11C6A  F0AF     NOP
305:           #ifdef VLCB_GRSP
306:                       sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSET, SERVICE_ID_MNS, GRSP_OK);
11C6C  C554     MOVFF 0x554, data1
11C6E  F525     NOP
11C70  C553     MOVFF nn, data2
11C72  F526     NOP
11C74  0E96     MOVLW 0x96
11C76  6E27     MOVWF 0x27, ACCESS
11C78  0E01     MOVLW 0x1
11C7A  6E28     MOVWF 0x28, ACCESS
11C7C  0E00     MOVLW 0x0
11C7E  6E29     MOVWF 0x29, ACCESS
11C80  0EAF     MOVLW 0xAF
11C82  EC7D     CALL 0x15EFA, 0
11C84  F0AF     NOP
11C86  D75B     BRA 0x1B3E
307:           #endif
308:                       return PROCESSED;
309:           #ifdef VLCB_NVSETRD
310:                   case OPC_NVSETRD:
311:                       if (m->len < 5) {
11C88  C546     MOVFF m, FSR2
11C8A  F4D9     NOP
11C8C  C547     MOVFF 0x547, FSR2H
11C8E  F4DA     NOP
11C90  0E05     MOVLW 0x5
11C92  60DF     CPFSLT 0xFDF, ACCESS
11C94  D00E     BRA 0x1CB2
312:           //                sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_CMD);
313:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSETRD, SERVICE_ID_MNS, CMDERR_INV_CMD);
11C96  C554     MOVFF 0x554, data1
11C98  F525     NOP
11C9A  C553     MOVFF nn, data2
11C9C  F526     NOP
11C9E  0E8E     MOVLW 0x8E
11CA0  6E27     MOVWF 0x27, ACCESS
11CA2  0E01     MOVLW 0x1
11CA4  6E28     MOVWF 0x28, ACCESS
11CA6  0E01     MOVLW 0x1
11CA8  6E29     MOVWF 0x29, ACCESS
11CAA  0EAF     MOVLW 0xAF
11CAC  EC7D     CALL 0x15EFA, 0
11CAE  F0AF     NOP
11CB0  D743     BRA 0x1B38
314:           #ifdef VLCB_DIAG
315:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
316:           #endif
317:                           return PROCESSED;
318:                       }
319:                       valueOrError = setNV(m->bytes[2], m->bytes[3]);
11CB2  EE20     LFSR 2, 0x5
11CB4  F005     NOP
11CB6  5046     MOVF NVMDAT, W, ACCESS
11CB8  26D9     ADDWF 0xFD9, F, ACCESS
11CBA  5047     MOVF NVMDATH, W, ACCESS
11CBC  22DA     ADDWFC 0xFDA, F, ACCESS
11CBE  50DF     MOVF 0xFDF, W, ACCESS
11CC0  6E17     MOVWF 0x17, ACCESS
11CC2  EE20     LFSR 2, 0x4
11CC4  F004     NOP
11CC6  5046     MOVF NVMDAT, W, ACCESS
11CC8  26D9     ADDWF 0xFD9, F, ACCESS
11CCA  5047     MOVF NVMDATH, W, ACCESS
11CCC  22DA     ADDWFC 0xFDA, F, ACCESS
11CCE  50DF     MOVF 0xFDF, W, ACCESS
11CD0  EC30     CALL 0x14A60, 0
11CD2  F0A5     NOP
11CD4  6E48     MOVWF VREGCON, ACCESS
11CD6  5048     MOVF VREGCON, W, ACCESS
11CD8  6E4A     MOVWF HLVDCON0, ACCESS
11CDA  6A4B     CLRF HLVDCON1, ACCESS
320:                       if (valueOrError >0) {
11CDC  BE4B     BTFSC HLVDCON1, 7, ACCESS
11CDE  D01C     BRA 0x1D18
11CE0  504B     MOVF HLVDCON1, W, ACCESS
11CE2  E103     BNZ 0x1CEA
11CE4  044A     DECF HLVDCON0, W, ACCESS
11CE6  A0D8     BTFSS 0xFD8, 0, ACCESS
11CE8  D017     BRA 0x1D18
321:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(valueOrError));
11CEA  C554     MOVFF 0x554, data1
11CEC  F525     NOP
11CEE  C553     MOVFF nn, data2
11CF0  F526     NOP
11CF2  C54A     MOVFF eventEN, data3
11CF4  F527     NOP
11CF6  0E6F     MOVLW 0x6F
11CF8  EC3E     CALL 0x15E7C, 0
11CFA  F0AF     NOP
322:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSETRD, SERVICE_ID_MNS, (uint8_t)(valueOrError));
11CFC  C554     MOVFF 0x554, data1
11CFE  F525     NOP
11D00  C553     MOVFF nn, data2
11D02  F526     NOP
11D04  0E8E     MOVLW 0x8E
11D06  6E27     MOVWF 0x27, ACCESS
11D08  0E01     MOVLW 0x1
11D0A  6E28     MOVWF 0x28, ACCESS
11D0C  C54A     MOVFF eventEN, data5
11D0E  F529     NOP
11D10  0EAF     MOVLW 0xAF
11D12  EC7D     CALL 0x15EFA, 0
11D14  F0AF     NOP
11D16  D710     BRA 0x1B38
323:           #ifdef VLCB_DIAG
324:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
325:           #endif
326:                           return PROCESSED;
327:                       }
328:                       valueOrError = getNV(m->bytes[2]);
11D18  EE20     LFSR 2, 0x4
11D1A  F004     NOP
11D1C  5046     MOVF NVMDAT, W, ACCESS
11D1E  26D9     ADDWF 0xFD9, F, ACCESS
11D20  5047     MOVF NVMDATH, W, ACCESS
11D22  22DA     ADDWFC 0xFDA, F, ACCESS
11D24  50DF     MOVF 0xFDF, W, ACCESS
11D26  ECB9     CALL 0x15B72, 0
11D28  F0AD     NOP
11D2A  C502     MOVFF i, eventEN
11D2C  F54A     NOP
11D2E  C503     MOVFF opc, enn
11D30  F54B     NOP
329:                       if (valueOrError < 0) {
11D32  AE4B     BTFSS HLVDCON1, 7, ACCESS
11D34  D019     BRA 0x1D68
330:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(-valueOrError));
11D36  C554     MOVFF 0x554, data1
11D38  F525     NOP
11D3A  C553     MOVFF nn, data2
11D3C  F526     NOP
11D3E  504A     MOVF HLVDCON0, W, ACCESS
11D40  0800     SUBLW 0x0
11D42  6E27     MOVWF 0x27, ACCESS
11D44  0E6F     MOVLW 0x6F
11D46  EC3E     CALL 0x15E7C, 0
11D48  F0AF     NOP
331:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NVSETRD, SERVICE_ID_MNS, (uint8_t)(-valueOrError));
11D4A  C554     MOVFF 0x554, data1
11D4C  F525     NOP
11D4E  C553     MOVFF nn, data2
11D50  F526     NOP
11D52  0E8E     MOVLW 0x8E
11D54  6E27     MOVWF 0x27, ACCESS
11D56  0E01     MOVLW 0x1
11D58  6E28     MOVWF 0x28, ACCESS
11D5A  504A     MOVF HLVDCON0, W, ACCESS
11D5C  0800     SUBLW 0x0
11D5E  6E29     MOVWF 0x29, ACCESS
11D60  0EAF     MOVLW 0xAF
11D62  EC7D     CALL 0x15EFA, 0
11D64  F0AF     NOP
11D66  D6E8     BRA 0x1B38
332:           #ifdef VLCB_DIAG
333:                           nvDiagnostics[NV_DIAGNOSTICS_NUM_FAIL].asUint++;
334:           #endif
335:                           return PROCESSED;
336:                       }
337:                       sendMessage4(OPC_NVANS, nn.bytes.hi, nn.bytes.lo, m->bytes[2], (uint8_t)(valueOrError));
11D68  C554     MOVFF 0x554, data1
11D6A  F525     NOP
11D6C  C553     MOVFF nn, data2
11D6E  F526     NOP
11D70  EE20     LFSR 2, 0x4
11D72  F004     NOP
11D74  5046     MOVF NVMDAT, W, ACCESS
11D76  26D9     ADDWF 0xFD9, F, ACCESS
11D78  5047     MOVF NVMDATH, W, ACCESS
11D7A  22DA     ADDWFC 0xFDA, F, ACCESS
11D7C  50DF     MOVF 0xFDF, W, ACCESS
11D7E  6E27     MOVWF 0x27, ACCESS
11D80  C54A     MOVFF eventEN, data4
11D82  F528     NOP
11D84  0E97     MOVLW 0x97
11D86  EC92     CALL 0x15F24, 0
11D88  F0AF     NOP
338:           #ifdef VLCB_DIAG
339:                       nvDiagnostics[NV_DIAGNOSTICS_NUM_ACCESS].asUint++;
11D8A  0105     MOVLB 0x5
11D8C  4BC7     INFSNZ 0xC7, F, BANKED
11D8E  2BC8     INCF 0xC8, F, BANKED
11D90  D6D6     BRA 0x1B3E
340:           #endif
341:                       return PROCESSED;
342:           #endif
343:                   default:
344:                       return NOT_PROCESSED;   // message not processed
345:               }
11D92  EE20     LFSR 2, 0x1
11D94  F001     NOP
11D96  5046     MOVF NVMDAT, W, ACCESS
11D98  26D9     ADDWF 0xFD9, F, ACCESS
11D9A  5047     MOVF NVMDATH, W, ACCESS
11D9C  22DA     ADDWFC 0xFDA, F, ACCESS
11D9E  50DF     MOVF 0xFDF, W, ACCESS
11DA0  6E48     MOVWF VREGCON, ACCESS
11DA2  6A49     CLRF BORCON, ACCESS
11DA4  5049     MOVF BORCON, W, ACCESS
11DA6  0A00     XORLW 0x0
11DA8  A4D8     BTFSS 0xFD8, 2, ACCESS
11DAA  D692     BRA 0x1AD0
11DAC  5048     MOVF VREGCON, W, ACCESS
11DAE  0A71     XORLW 0x71
11DB0  B4D8     BTFSC 0xFD8, 2, ACCESS
11DB2  D6A5     BRA 0x1AFE
11DB4  0AFF     XORLW 0xFF
11DB6  B4D8     BTFSC 0xFD8, 2, ACCESS
11DB8  D767     BRA 0x1C88
11DBA  0A18     XORLW 0x18
11DBC  B4D8     BTFSC 0xFD8, 2, ACCESS
11DBC  B4D8     BTFSC 0xFD8, 2, ACCESS
11DBC  B4D8     BTFSC 0xFD8, 2, ACCESS
346:           }
347:           
348:           #ifdef VLCB_SERVICE
349:           /**
350:            * Obtain the ESD data response bytes. Only Data1 containing the number of NVs
351:            * is used.
352:            * @param id the data index
353:            * @return the data value
354:            */
355:           static uint8_t nvGetESDdata(uint8_t id) {
161AE  6E02     MOVWF ___rparam_used, ACCESS
356:               switch (id) {
161B0  D004     BRA 0x61BA
357:                   case 1: return NV_NUM;
161B2  0E01     MOVLW 0x1
161B4  0012     RETURN 0
358:                   default: return 0;
161B6  0E00     MOVLW 0x0
161B8  0012     RETURN 0
359:               }
161BA  5002     MOVF ___rparam_used, W, ACCESS
161BC  0A01     XORLW 0x1
161BE  B4D8     BTFSC 0xFD8, 2, ACCESS
161C0  D7F8     BRA 0x61B2
161C0  D7F8     BRA 0x61B2
360:           }
361:           #endif
362:           
363:           #ifdef VLCB_ZERO_RESPONSES
364:           /**
365:            * This is the callback used by the service discovery responses.
366:            * @param type always set to TIMED_RESPONSE_NVRD
367:            * @param serviceIndex indicates the service requesting the responses
368:            * @param step loops through each service to be discovered
369:            * @return whether all of the responses have been sent yet.
370:            */
371:           TimedResponseResult nvTRnvrdCallback(uint8_t type, uint8_t serviceIndex, uint8_t step) {
372:               int16_t valueOrError;
373:               if (step > NV_NUM) {
15A86  0E01     MOVLW 0x1
15A88  6433     CPFSGT 0x33, ACCESS
15A8A  D002     BRA 0x5A90
374:                   return TIMED_RESPONSE_RESULT_FINISHED;
15A8C  0E00     MOVLW 0x0
15A8E  0012     RETURN 0
375:               }
376:               valueOrError = getNV(step+1);
15A90  2833     INCF 0x33, W, ACCESS
15A92  ECB9     CALL 0x15B72, 0
15A94  F0AD     NOP
15A96  C502     MOVFF i, nodeNumber
15A98  F534     NOP
15A9A  C503     MOVFF opc, error
15A9C  F535     NOP
377:               if (valueOrError < 0) {
15A9E  BE35     BTFSC 0x35, 7, ACCESS
15AA0  D7F5     BRA 0x5A8C
378:                   return TIMED_RESPONSE_RESULT_FINISHED;
379:               }
380:               sendMessage4(OPC_NVANS, nn.bytes.hi, nn.bytes.lo, step+1, (uint8_t)(valueOrError));
15AA2  C554     MOVFF 0x554, data1
15AA4  F525     NOP
15AA6  C553     MOVFF nn, data2
15AA8  F526     NOP
15AAA  2833     INCF 0x33, W, ACCESS
15AAC  6E27     MOVWF 0x27, ACCESS
15AAE  C534     MOVFF nodeNumber, data4
15AB0  F528     NOP
15AB2  0E97     MOVLW 0x97
15AB4  EC92     CALL 0x15F24, 0
15AB6  F0AF     NOP
381:           #ifdef VLCB_DIAG
382:               nvDiagnostics[NV_DIAGNOSTICS_NUM_ACCESS].asUint++;
15AB8  0105     MOVLB 0x5
15ABA  4BC7     INFSNZ 0xC7, F, BANKED
15ABC  2BC8     INCF 0xC8, F, BANKED
383:           #endif
384:               return TIMED_RESPONSE_RESULT_NEXT;
15ABE  0E02     MOVLW 0x2
385:           }
15AC0  0012     RETURN 0
386:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/mns.c  -----------------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:              * BUGS
6:              * Shouldn't persist SETUP mode
7:              * Holding PB whilst in Setup should return to Uninitialised
8:              * 
9:              */
10:            /*
11:              This work is licensed under the:
12:                  Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
13:               To view a copy of this license, visit:
14:                  http://creativecommons.org/licenses/by-nc-sa/4.0/
15:               or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
16:            
17:               License summary:
18:                You are free to:
19:                  Share, copy and redistribute the material in any medium or format
20:                  Adapt, remix, transform, and build upon the material
21:            
22:                The licensor cannot revoke these freedoms as long as you follow the license terms.
23:            
24:                Attribution : You must give appropriate credit, provide a link to the license,
25:                               and indicate if changes were made. You may do so in any reasonable manner,
26:                               but not in any way that suggests the licensor endorses you or your use.
27:            
28:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
29:            
30:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
31:                              your contributions under the same license as the original.
32:            
33:                No additional restrictions : You may not apply legal terms or technological measures that
34:                                              legally restrict others from doing anything the license permits.
35:            
36:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
37:            
38:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
39:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
40:            */
41:            /**
42:             * @author Ian Hogg 
43:             * @date Dec 2022
44:             * 
45:             */ 
46:            
47:            /**
48:             *
49:             * @file
50:             * @brief
51:             * Implementation of the VLCB Minimum Module Service.
52:             * @details
53:             * MNS provides functionality required by all VLCB modules.
54:             *
55:             * The service definition object is called mnsService.
56:             * This is a large service as it handles mode transitions, including setting of 
57:             * node number. The module's LEDs and push button are also supported.
58:             * Service discovery and Diagnostics are also processed from this service.
59:             * 
60:             * # Dependencies on other Services
61:             * None.
62:             * 
63:             * MNS is a mandatory service for all VLCB modules and is therefore to be
64:             * included by all module applications.
65:             * 
66:             * # Module.h definitions required for the MNS service
67:             * - \#define NUM_SERVICES with the number of service pointers in the services array.
68:             * - \#define APP_NVM_VERSION the version number of the data structures stored in NVM
69:             *                      this is located where NV#0 is stored therefore NV_ADDRESS
70:             *                      and NV_NVM_TYPE must be defined even without the NV service.
71:             * - \#define clkMHz       Must be set to the clock speed of the module. Typically 
72:             *                      this would be 4 or 16.
73:             * - \#define NN_ADDRESS   This must be set to the address in non volatile memory
74:             *                      at which the node number is to be stored.
75:             * - \#define NN_NVM_TYPE  This must be set to the type of the NVM where the node
76:             *                      number is to be stored.
77:             * - \#define MODE_ADDRESS This must be set to the address in non volatile memory
78:             *                      at which the mode variable is to be stored.
79:             * - \#define MODE_NVM_TYPE This must be set to the type of the NVM where the mode
80:             *                      variable is to be stored.
81:             * - \#define APP_setPortDirections() This macro must be set to configure the 
82:             *                      processor's pins for output to the LEDs and input from the
83:             *                      push button. It should also enable digital I/O if required 
84:             *                      by the processor.
85:             * - \#define APP_writeLED1(state) This macro must be defined to set LED1 (normally
86:             *                      yellow) to the state specified. 1 is LED on.
87:             * - \#define APP_writeLED2(state) This macro must be defined to set LED1 (normally
88:             *                      green) to the state specified. 1 is LED on.
89:             * - \#define APP_pbPressed() This macro must be defined to read the push button
90:             *                      input, returning true when the push button is held down.
91:             * - \#define NAME         The name of the module must be defined. Must be exactly 
92:             *                      7 characters. Shorter names should be padded on the right 
93:             *                      with spaces. The name must leave off the communications 
94:             *                      protocol e.g. the CANMIO module would be set to "MIO    ".
95:             * 
96:             * The following parameter values are required to be defined for use by MNS:
97:             * - \#define PARAM_MANU              See the manufacturer settings in vlcb.h
98:             * - \#define PARAM_MAJOR_VERSION     The major version number
99:             * - \#define PARAM_MINOR_VERSION     The minor version character. E.g. 'a'
100:            * - \#define PARAM_BUILD_VERSION     The build version number
101:            * - \#define PARAM_MODULE_ID         The module ID. Normally set to MTYP_VLCB
102:            * - \#define PARAM_NUM_NV            The number of NVs. Normally set to NV_NUM
103:            * - \#define PARAM_NUM_EVENTS        The number of events.
104:            * - \#define PARAM_NUM_EV_EVENT      The number of EVs per event
105:            * 
106:            */
107:           #include <xc.h>
108:           
109:           #include "vlcb.h"
110:           #include "module.h"
111:           #include "devincs.h"
112:           #include "vlcbdefs_enums.h"
113:           #include "mns.h"
114:           #include "ticktime.h"
115:           #include "nvm.h"
116:           #include "timedResponse.h"
117:           #include "statusDisplay.h"
118:           #include "statusLeds.h"
119:           
120:           /** Version of this Service implementation.*/
121:           #define MNS_VERSION 1
122:           
123:           // Forward declarations
124:           static void mnsFactoryReset(void);
125:           static void mnsPowerUp(void);
126:           static void mnsPoll(void);
127:           static Processed mnsProcessMessage(Message * m);
128:           static void mnsLowIsr(void);
129:           static uint8_t getParameter(uint8_t);
130:           #ifdef VLCB_DIAG
131:           static DiagnosticVal * mnsGetDiagnostic(uint8_t index);
132:           /**
133:            * The diagnostic values supported by the MNS service.
134:            */
135:           DiagnosticVal mnsDiagnostics[NUM_MNS_DIAGNOSTICS+1];
136:           #endif
137:           
138:           #ifdef PRODUCED_EVENTS
139:           #include "event_teach.h"
140:           #include "event_producer.h"
141:           Boolean sendProducedEvent(Happening happening, EventState onOff);
142:           #endif
143:           #ifdef EVENT_HASH_TABLE
144:           extern void rebuildHashtable(void);
145:           #endif
146:           void setLEDsByMode(void);
147:           
148:           /**
149:            *  The descriptor for the MNS service.
150:            */
151:           const Service mnsService = {
152:               SERVICE_ID_MNS,         // id
153:               1,                      // version
154:               mnsFactoryReset,        // factoryReset
155:               mnsPowerUp,             // powerUp
156:               mnsProcessMessage,      // processMessage
157:               mnsPoll,                // poll
158:           #if defined(_18F66K80_FAMILY_)
159:               NULL,                   // highIsr
160:               mnsLowIsr,              // lowIsr
161:           #endif
162:           #ifdef VLCB_SERVICE
163:               NULL,                   // get ESD data
164:           #endif
165:           #ifdef VLCB_DIAG
166:               mnsGetDiagnostic        // getDiagnostic
167:           #endif
168:           };
169:           
170:           // General MNS variables
171:           /**
172:            * Node number.
173:            */
174:           Word nn;            // node number
175:           /**
176:            * Module operating mode.
177:            */
178:           uint8_t mode_state; // operational mode
179:           static uint8_t last_mode_state;
180:           
181:           #define MODE_PRESETUP   0xFD    // hope not to clash with any defined by standard
182:           
183:           /**
184:            * Module operating mode flags.
185:            */
186:           uint8_t mode_flags; // operational mode flags
187:           static uint8_t last_mode_flags;
188:           
189:           /**
190:            * The module's name. The NAME macro should be specified by the application 
191:            * code in module.h.
192:            */
193:           const char name[] __at(0x848) = NAME; // module name
194:           // mode transition variables if timeout occurs
195:           /**
196:            * The previous mode so it can be restored if a timeout occurs.
197:            */
198:           static uint8_t setupModePreviousMode;
199:           /**
200:            * The previous node number so it can be restored if a timeout occurs.
201:            */
202:           static Word previousNN;
203:           
204:           
205:           /**
206:            * Module's push button handling.
207:            * Other UI options are not currently supported.
208:            */
209:           TickValue pbTimer;
210:           
211:           
212:           /* Heartbeat controls */
213:           static uint8_t heartbeatSequence;
214:           static TickValue heartbeatTimer;
215:           
216:           /* Uptime controls */
217:           static TickValue uptimeTimer;
218:           
219:           /*
220:            * Forward declaration for the TimedResponse callback function for sending
221:            * Service Discovery responses.
222:            * @param type type of TimedResponse
223:            * @param serviceIndex the service
224:            * @param step the TimedResponse step
225:            * @return indication if all the responses have been sent.
226:            */
227:           TimedResponseResult mnsTRserviceDiscoveryCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
228:           /*
229:            * Forward declaration for the TimedResponse callback function for sending
230:            * Diagnostic responses.
231:            * @param type type of TimedResponse
232:            * @param serviceIndex the service
233:            * @param step the TimedResponse step
234:            * @return indication if all the responses have been sent.
235:            */
236:           TimedResponseResult mnsTRallDiagnosticsCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
237:           /*
238:            * Forward declaration for the TimedResponse callback function for sending
239:            * Parameter responses.
240:            * @param type type of TimedResponse
241:            * @param serviceIndex the service
242:            * @param step the TimedResponse step
243:            * @return indication if all the responses have been sent.
244:            */
245:           TimedResponseResult  mnsTRrqnpnCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
246:           
247:           /*
248:            * Defines for the PNN flags byte
249:            */
250:           /** Parameter Flag bit for a Consumer module. */
251:           #define PNN_FLAGS_CONSUMER  1
252:           /** Parameter Flag bit for a Producer module. */
253:           #define PNN_FLAGS_PRODUCER  2
254:           /** Parameter Flag bit for a module in Normal mode. */
255:           #define PNN_FLAGS_NORMAL    4
256:           /** Parameter Flag bit for a module supporting the PIC Boot process. */
257:           #define PNN_FLAGS_BOOT      8
258:           /** Parameter Flag bit for a module which can consume its own events. */
259:           #define PNN_FLAGS_COE       16
260:           /** Parameter Flag bit for a module in Learn mode. */
261:           #define PNN_FLAGS_LEARN     32
262:           /** Parameter Flag bit for a module that is compliant with VLCB. */
263:           #define PNN_FLAGS_VLCB      64
264:           
265:           /*
266:            * Forward declaration for getParameterFlags.
267:            */
268:           static uint8_t getParameterFlags(void);
269:           
270:           /*
271:            * The Service functions
272:            */
273:           /**
274:            * Perform the MNS factory reset. Just set the node number and mode to default.
275:            */
276:           static void mnsFactoryReset(void) {
277:               nn.bytes.hi = NN_HI_DEFAULT;
14BBE  0E00     MOVLW 0x0
14BC0  6E54     MOVWF 0x54, ACCESS
278:               nn.bytes.lo = NN_LO_DEFAULT;
14BC2  0E00     MOVLW 0x0
14BC4  6E53     MOVWF 0x53, ACCESS
279:               writeNVM(NN_NVM_TYPE, NN_ADDRESS+1, nn.bytes.hi);
14BC6  0EFD     MOVLW 0xFD
14BC8  6E10     MOVWF 0x10, ACCESS
14BCA  0E03     MOVLW 0x3
14BCC  6E11     MOVWF 0x11, ACCESS
14BCE  0E00     MOVLW 0x0
14BD0  6E12     MOVWF 0x12, ACCESS
14BD2  C554     MOVFF 0x554, hi
14BD4  F513     NOP
14BD6  0E00     MOVLW 0x0
14BD8  EC7E     CALL 0x156FC, 0
14BDA  F0AB     NOP
280:               writeNVM(NN_NVM_TYPE, NN_ADDRESS, nn.bytes.lo);
14BDC  0EFC     MOVLW 0xFC
14BDE  6E10     MOVWF 0x10, ACCESS
14BE0  0E03     MOVLW 0x3
14BE2  6E11     MOVWF 0x11, ACCESS
14BE4  0E00     MOVLW 0x0
14BE6  6E12     MOVWF 0x12, ACCESS
14BE8  C553     MOVFF nn, hi
14BEA  F513     NOP
14BEC  0E00     MOVLW 0x0
14BEE  EC7E     CALL 0x156FC, 0
14BF0  F0AB     NOP
281:               
282:               last_mode_state = mode_state = MODE_UNINITIALISED;
14BF2  0105     MOVLB 0x5
14BF4  69AB     SETF 0xAB, BANKED
14BF6  69AA     SETF 0xAA, BANKED
283:               writeNVM(MODE_NVM_TYPE, MODE_ADDRESS, mode_state);
14BF8  0EFB     MOVLW 0xFB
14BFA  6E10     MOVWF 0x10, ACCESS
14BFC  0E03     MOVLW 0x3
14BFE  6E11     MOVWF 0x11, ACCESS
14C00  0E00     MOVLW 0x0
14C02  6E12     MOVWF 0x12, ACCESS
14C04  C5AB     MOVFF mode_state, hi
14C06  F513     NOP
14C08  0E00     MOVLW 0x0
14C0A  EC7E     CALL 0x156FC, 0
14C0C  F0AB     NOP
284:           
285:               //last_mode_flags = mode_flags = FLAG_MODE_HEARTBEAT; // heartbeat enabled by default
286:               last_mode_flags = mode_flags = 0;       // heartbeat disabled by default
14C0E  0E00     MOVLW 0x0
14C10  0105     MOVLB 0x5
14C12  6FB4     MOVWF PRLOCK, BANKED
14C14  C5B4     MOVFF mode_flags, last_mode_flags
14C16  F5A9     NOP
287:               writeNVM(MODE_FLAGS_NVM_TYPE, MODE_FLAGS_ADDRESS, mode_flags);
14C18  0EF9     MOVLW 0xF9
14C1A  6E10     MOVWF 0x10, ACCESS
14C1C  0E03     MOVLW 0x3
14C1E  6E11     MOVWF 0x11, ACCESS
14C20  0E00     MOVLW 0x0
14C22  6E12     MOVWF 0x12, ACCESS
14C24  C5B4     MOVFF mode_flags, hi
14C26  F513     NOP
14C28  0E00     MOVLW 0x0
14C2A  EC7E     CALL 0x156FC, 0
14C2C  F0AB     NOP
288:           }
14C2E  0012     RETURN 0
289:           
290:           /**
291:            * Perform the MNS power up.
292:            * Loads the node number and mode from non volatile memory. Initialises the LEDs 
293:            * clear the Diagnostics values.
294:            */
295:           static void mnsPowerUp(void) {
296:               int temp;
297:               uint8_t i;
298:               
299:               temp = readNVM(NN_NVM_TYPE, NN_ADDRESS+1);
1358A  0EFD     MOVLW 0xFD
1358C  6E08     MOVWF 0x8, ACCESS
1358E  0E03     MOVLW 0x3
13590  6E09     MOVWF 0x9, ACCESS
13592  0E00     MOVLW 0x0
13594  6E0A     MOVWF 0xA, ACCESS
13596  0E00     MOVLW 0x0
13598  ECF3     CALL 0x151E6, 0
1359A  F0A8     NOP
1359C  C508     MOVFF index, interruptEnabled
1359E  F50F     NOP
135A0  C509     MOVFF d, receivedCanId
135A2  F510     NOP
300:               if (temp < 0) {
135A4  AE10     BTFSS 0x10, 7, ACCESS
135A6  D005     BRA 0x35B2
301:                   nn.bytes.hi = NN_HI_DEFAULT;
135A8  0E00     MOVLW 0x0
135AA  6E54     MOVWF 0x54, ACCESS
302:                   nn.bytes.lo = NN_LO_DEFAULT;
135AC  0E00     MOVLW 0x0
135AE  6E53     MOVWF 0x53, ACCESS
303:               } else {
135B0  D013     BRA 0x35D8
304:                   nn.bytes.hi = (uint8_t)temp;
135B2  C50F     MOVFF interruptEnabled, 0x554
135B4  F554     NOP
305:                   temp = readNVM(NN_NVM_TYPE, NN_ADDRESS);
135B6  0EFC     MOVLW 0xFC
135B8  6E08     MOVWF 0x8, ACCESS
135BA  0E03     MOVLW 0x3
135BC  6E09     MOVWF 0x9, ACCESS
135BE  0E00     MOVLW 0x0
135C0  6E0A     MOVWF 0xA, ACCESS
135C2  0E00     MOVLW 0x0
135C4  ECF3     CALL 0x151E6, 0
135C6  F0A8     NOP
135C8  C508     MOVFF index, interruptEnabled
135CA  F50F     NOP
135CC  C509     MOVFF d, receivedCanId
135CE  F510     NOP
306:                   if (temp < 0) {
135D0  BE10     BTFSC 0x10, 7, ACCESS
135D2  D7EA     BRA 0x35A8
307:                       nn.bytes.hi = NN_HI_DEFAULT;
308:                       nn.bytes.lo = NN_LO_DEFAULT;
309:                   } else {
310:                       nn.bytes.lo = (uint8_t)temp;
135D4  C50F     MOVFF interruptEnabled, nn
135D6  F553     NOP
311:                   }
312:               }
313:               temp = readNVM(MODE_NVM_TYPE, MODE_ADDRESS);
135D8  0EFB     MOVLW 0xFB
135DA  6E08     MOVWF 0x8, ACCESS
135DC  0E03     MOVLW 0x3
135DE  6E09     MOVWF 0x9, ACCESS
135E0  0E00     MOVLW 0x0
135E2  6E0A     MOVWF 0xA, ACCESS
135E4  0E00     MOVLW 0x0
135E6  ECF3     CALL 0x151E6, 0
135E8  F0A8     NOP
135EA  C508     MOVFF index, interruptEnabled
135EC  F50F     NOP
135EE  C509     MOVFF d, receivedCanId
135F0  F510     NOP
314:               if (temp < 0) {
135F2  AE10     BTFSS 0x10, 7, ACCESS
135F4  D003     BRA 0x35FC
315:                   mode_state = MODE_DEFAULT;
135F6  0105     MOVLB 0x5
135F8  69AB     SETF 0xAB, BANKED
316:               } else {
135FA  D002     BRA 0x3600
317:                   mode_state = (uint8_t)temp;
135FC  C50F     MOVFF interruptEnabled, mode_state
135FE  F5AB     NOP
318:               }
319:               setupModePreviousMode = mode_state;
13600  C5AB     MOVFF mode_state, setupModePreviousMode
13602  F5A8     NOP
320:               temp = readNVM(MODE_FLAGS_NVM_TYPE, MODE_FLAGS_ADDRESS);
13604  0EF9     MOVLW 0xF9
13606  6E08     MOVWF 0x8, ACCESS
13608  0E03     MOVLW 0x3
1360A  6E09     MOVWF 0x9, ACCESS
1360C  0E00     MOVLW 0x0
1360E  6E0A     MOVWF 0xA, ACCESS
13610  0E00     MOVLW 0x0
13612  ECF3     CALL 0x151E6, 0
13614  F0A8     NOP
13616  C508     MOVFF index, interruptEnabled
13618  F50F     NOP
1361A  C509     MOVFF d, receivedCanId
1361C  F510     NOP
321:               if (temp < 0) {
1361E  AE10     BTFSS 0x10, 7, ACCESS
13620  D004     BRA 0x362A
322:                   mode_flags = FLAG_MODE_HEARTBEAT;
13622  0E04     MOVLW 0x4
13624  0105     MOVLB 0x5
13626  6FB4     MOVWF PRLOCK, BANKED
323:               } else {
13628  D002     BRA 0x362E
324:                   mode_flags = (uint8_t)temp;
1362A  C50F     MOVFF interruptEnabled, mode_flags
1362C  F5B4     NOP
325:               }
326:               
327:               setLEDsByMode();
1362E  EC5B     CALL 0x15CB6, 0
13630  F0AE     NOP
328:               
329:               pbTimer.val = tickGet();
13632  ECD8     CALL 0x153B0, 0
13634  F0A9     NOP
13636  C502     MOVFF i, pbTimer
13638  F574     NOP
1363A  C503     MOVFF opc, 0x575
1363C  F575     NOP
1363E  C504     MOVFF s, 0x576
13640  F576     NOP
13642  C505     MOVFF i, 0x577
13644  F577     NOP
330:               
331:           #ifdef VLCB_DIAG
332:               // Clear the diagnostics
333:               for (i=1; i<= NUM_MNS_DIAGNOSTICS; i++) {
13646  0E01     MOVLW 0x1
13648  6E0E     MOVWF 0xE, ACCESS
334:                   mnsDiagnostics[i].asInt = 0;
1364A  500E     MOVF 0xE, W, ACCESS
1364C  0D02     MULLW 0x2
1364E  0EB7     MOVLW 0xB7
13650  24F3     ADDWF 0xFF3, W, ACCESS
13652  6ED9     MOVWF 0xFD9, ACCESS
13654  0E05     MOVLW 0x5
13656  20F4     ADDWFC 0xFF4, W, ACCESS
13658  6EDA     MOVWF 0xFDA, ACCESS
1365A  6ADE     CLRF 0xFDE, ACCESS
1365C  6ADD     CLRF 0xFDD, ACCESS
335:               }
1365E  2A0E     INCF 0xE, F, ACCESS
13660  0E06     MOVLW 0x6
13662  640E     CPFSGT 0xE, ACCESS
13664  D7F2     BRA 0x364A
336:               mnsDiagnostics[MNS_DIAGNOSTICS_COUNT].asInt = NUM_MNS_DIAGNOSTICS;
13666  0E00     MOVLW 0x0
13668  0105     MOVLB 0x5
1366A  6FB8     MOVWF DMA3PR, BANKED
1366C  0E06     MOVLW 0x6
1366E  6FB7     MOVWF DMA2PR, BANKED
337:           #endif
338:               heartbeatSequence = 0;
13670  0E00     MOVLW 0x0
13672  6FA7     MOVWF 0xA7, BANKED
339:               heartbeatTimer.val = 0;
13674  0E00     MOVLW 0x0
13676  6F70     MOVWF CM1CON0, BANKED
13678  0E00     MOVLW 0x0
1367A  6F71     MOVWF CM1CON1, BANKED
1367C  0E00     MOVLW 0x0
1367E  6F72     MOVWF CM1NCH, BANKED
13680  0E00     MOVLW 0x0
13682  6F73     MOVWF CM1PCH, BANKED
340:               uptimeTimer.val = 0;
13684  0E00     MOVLW 0x0
13686  6F6C     MOVWF MD1SRC, BANKED
13688  0E00     MOVLW 0x0
1368A  6F6D     MOVWF MD1CARL, BANKED
1368C  0E00     MOVLW 0x0
1368E  6F6E     MOVWF MD1CARH, BANKED
13690  0E00     MOVLW 0x0
13692  6F6F     MOVWF CMOUT, BANKED
341:           }
13694  0012     RETURN 0
342:           
343:           /**
344:            * Minimum Node Specification service MERGCB message processing.
345:            * This handles all the opcodes for the MNS service. Also handles the mode
346:            * state transitions and LED changes.
347:            * 
348:            * @param m the VLCB message to be processed
349:            * @return PROCESSED if the message was processed, NOT_PROCESSED otherwise
350:            */
351:           static Processed mnsProcessMessage(Message * m) {
352:               uint8_t i;
353:               uint8_t flags;
354:               //const Service * s;
355:               uint8_t newMode;
356:           
357:               // Now do the MNS opcodes
358:           
359:               // SETUP mode messages
360:               if (mode_state == MODE_SETUP) {
10000  0105     MOVLB 0x5
10002  51AB     MOVF 0xAB, W, BANKED
10004  B4D8     BTFSC 0xFD8, 2, ACCESS
10006  D0B1     BRA 0x16A
10008  D116     BRA 0x236
361:                   switch (m->opc) {
362:                       case OPC_SNN:   // Set node number
363:                           if (m->len < 3) {
1000A  C546     MOVFF m, FSR2
1000C  F4D9     NOP
1000E  C547     MOVFF 0x547, FSR2H
10010  F4DA     NOP
10012  0E03     MOVLW 0x3
10014  60DF     CPFSLT 0xFDF, ACCESS
10016  D00E     BRA 0x34
364:           #ifdef VLCB_GRSP
365:                               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_SNN, SERVICE_ID_MNS, CMDERR_INV_CMD);
10018  C554     MOVFF 0x554, data1
1001A  F525     NOP
1001C  C553     MOVFF nn, data2
1001E  F526     NOP
10020  0E42     MOVLW 0x42
10022  6E27     MOVWF 0x27, ACCESS
10024  0E01     MOVLW 0x1
10026  6E28     MOVWF 0x28, ACCESS
10028  0E01     MOVLW 0x1
1002A  6E29     MOVWF 0x29, ACCESS
1002C  0EAF     MOVLW 0xAF
1002E  EC7D     CALL 0x15EFA, 0
10030  F0AF     NOP
366:           #endif
367:                           } else {    
10032  D035     BRA 0x9E
368:                               nn.bytes.hi = m->bytes[0];
10034  EE20     LFSR 2, 0x2
10036  F002     NOP
10038  5046     MOVF NVMDAT, W, ACCESS
1003A  26D9     ADDWF 0xFD9, F, ACCESS
1003C  5047     MOVF NVMDATH, W, ACCESS
1003E  22DA     ADDWFC 0xFDA, F, ACCESS
10040  50DF     MOVF 0xFDF, W, ACCESS
10042  6E54     MOVWF 0x54, ACCESS
369:                               nn.bytes.lo = m->bytes[1];
10044  EE20     LFSR 2, 0x3
10046  F003     NOP
10048  5046     MOVF NVMDAT, W, ACCESS
1004A  26D9     ADDWF 0xFD9, F, ACCESS
1004C  5047     MOVF NVMDATH, W, ACCESS
1004E  22DA     ADDWFC 0xFDA, F, ACCESS
10050  50DF     MOVF 0xFDF, W, ACCESS
10052  6E53     MOVWF 0x53, ACCESS
370:                               writeNVM(NN_NVM_TYPE, NN_ADDRESS+1, nn.bytes.hi);
10054  0EFD     MOVLW 0xFD
10056  6E10     MOVWF 0x10, ACCESS
10058  0E03     MOVLW 0x3
1005A  6E11     MOVWF 0x11, ACCESS
1005C  0E00     MOVLW 0x0
1005E  6E12     MOVWF 0x12, ACCESS
10060  C554     MOVFF 0x554, hi
10062  F513     NOP
10064  0E00     MOVLW 0x0
10066  EC7E     CALL 0x156FC, 0
10068  F0AB     NOP
371:                               writeNVM(NN_NVM_TYPE, NN_ADDRESS, nn.bytes.lo);
1006A  0EFC     MOVLW 0xFC
1006C  6E10     MOVWF 0x10, ACCESS
1006E  0E03     MOVLW 0x3
10070  6E11     MOVWF 0x11, ACCESS
10072  0E00     MOVLW 0x0
10074  6E12     MOVWF 0x12, ACCESS
10076  C553     MOVFF nn, hi
10078  F513     NOP
1007A  0E00     MOVLW 0x0
1007C  EC7E     CALL 0x156FC, 0
1007E  F0AB     NOP
372:                               
373:                               mode_state = MODE_NORMAL;
10080  0E01     MOVLW 0x1
10082  0105     MOVLB 0x5
10084  6FAB     MOVWF 0xAB, BANKED
374:           //                    writeNVM(MODE_NVM_TYPE, MODE_ADDRESS, mode_state);
375:           #ifdef EVENT_HASH_TABLE
376:                               rebuildHashtable();
377:           #endif
378:                               
379:                               sendMessage2(OPC_NNACK, nn.bytes.hi, nn.bytes.lo);
10086  C554     MOVFF 0x554, data1
10088  F525     NOP
1008A  C553     MOVFF nn, data2
1008C  F526     NOP
1008E  0E52     MOVLW 0x52
10090  EC53     CALL 0x15EA6, 0
10092  F0AF     NOP
380:           #ifdef VLCB_DIAG
381:                               mnsDiagnostics[MNS_DIAGNOSTICS_NNCHANGE].asUint++;
10094  0105     MOVLB 0x5
10096  4BC1     INFSNZ 0xC1, F, BANKED
10098  2BC2     INCF 0xC2, F, BANKED
382:           #endif
383:                               // Update the LEDs
384:                               setLEDsByMode();
1009A  EC5B     CALL 0x15CB6, 0
1009C  F0AE     NOP
385:                           }
386:                           return PROCESSED;
1009E  0E01     MOVLW 0x1
100A0  0012     RETURN 0
387:                       case OPC_RQNP:  // request parameters
388:                           sendMessage7(OPC_PARAMS, PARAM_MANU, PARAM_MINOR_VERSION, 
100A2  0EA5     MOVLW 0xA5
100A4  6E25     MOVWF 0x25, ACCESS
100A6  0E63     MOVLW 0x63
100A8  6E26     MOVWF 0x26, ACCESS
100AA  0E1D     MOVLW 0x1D
100AC  6E27     MOVWF 0x27, ACCESS
100AE  0EFE     MOVLW 0xFE
100B0  6E28     MOVWF 0x28, ACCESS
100B2  0E0D     MOVLW 0xD
100B4  6E29     MOVWF 0x29, ACCESS
100B6  0E01     MOVLW 0x1
100B8  6E2A     MOVWF 0x2A, ACCESS
100BA  0E04     MOVLW 0x4
100BC  6E2B     MOVWF 0x2B, ACCESS
100BE  0EEF     MOVLW 0xEF
100C0  EC68     CALL 0x15ED0, 0
100C2  F0AF     NOP
100C4  D7EC     BRA 0x9E
389:                                   PARAM_MODULE_ID, PARAM_NUM_EVENTS, PARAM_NUM_EV_EVENT, 
390:                                   PARAM_NUM_NV, PARAM_MAJOR_VERSION);
391:                           return PROCESSED;
392:                       case OPC_RQMN:  // Request name
393:                           sendMessage7(OPC_NAME, name[0], name[1], name[2], name[3],  
100C6  0E48     MOVLW 0x48
100C8  6EF6     MOVWF 0xFF6, ACCESS
100CA  0E08     MOVLW 0x8
100CC  6EF7     MOVWF 0xFF7, ACCESS
100CE  0E00     MOVLW 0x0
100D0  6EF8     MOVWF 0xFF8, ACCESS
100D2  0008     TBLRD*
100D4  C4F5     MOVFF TABLAT, data1
100D6  F525     NOP
100D8  0E49     MOVLW 0x49
100DA  6EF6     MOVWF 0xFF6, ACCESS
100DC  0E08     MOVLW 0x8
100DE  6EF7     MOVWF 0xFF7, ACCESS
100E0  0E00     MOVLW 0x0
100E2  6EF8     MOVWF 0xFF8, ACCESS
100E4  0008     TBLRD*
100E6  C4F5     MOVFF TABLAT, data2
100E8  F526     NOP
100EA  0E4A     MOVLW 0x4A
100EC  6EF6     MOVWF 0xFF6, ACCESS
100EE  0E08     MOVLW 0x8
100F0  6EF7     MOVWF 0xFF7, ACCESS
100F2  0E00     MOVLW 0x0
100F4  6EF8     MOVWF 0xFF8, ACCESS
100F6  0008     TBLRD*
100F8  C4F5     MOVFF TABLAT, data3
100FA  F527     NOP
100FC  0E4B     MOVLW 0x4B
100FE  6EF6     MOVWF 0xFF6, ACCESS
10100  0E08     MOVLW 0x8
10102  6EF7     MOVWF 0xFF7, ACCESS
10104  0E00     MOVLW 0x0
10106  6EF8     MOVWF 0xFF8, ACCESS
10108  0008     TBLRD*
1010A  C4F5     MOVFF TABLAT, data4
1010C  F528     NOP
1010E  0E4C     MOVLW 0x4C
10110  6EF6     MOVWF 0xFF6, ACCESS
10112  0E08     MOVLW 0x8
10114  6EF7     MOVWF 0xFF7, ACCESS
10116  0E00     MOVLW 0x0
10118  6EF8     MOVWF 0xFF8, ACCESS
1011A  0008     TBLRD*
1011C  C4F5     MOVFF TABLAT, data5
1011E  F529     NOP
10120  0E4D     MOVLW 0x4D
10122  6EF6     MOVWF 0xFF6, ACCESS
10124  0E08     MOVLW 0x8
10126  6EF7     MOVWF 0xFF7, ACCESS
10128  0E00     MOVLW 0x0
1012A  6EF8     MOVWF 0xFF8, ACCESS
1012C  0008     TBLRD*
1012E  C4F5     MOVFF TABLAT, data6
10130  F52A     NOP
10132  0E4E     MOVLW 0x4E
10134  6EF6     MOVWF 0xFF6, ACCESS
10136  0E08     MOVLW 0x8
10138  6EF7     MOVWF 0xFF7, ACCESS
1013A  0E00     MOVLW 0x0
1013C  6EF8     MOVWF 0xFF8, ACCESS
1013E  0008     TBLRD*
10140  C4F5     MOVFF TABLAT, opc
10142  F52B     NOP
10144  0EE2     MOVLW 0xE2
10146  EC68     CALL 0x15ED0, 0
10148  F0AF     NOP
1014A  D7A9     BRA 0x9E
394:                                   name[4], name[5], name[6]);
395:                           return PROCESSED;
396:                       case OPC_QNN:   // Query nodes
397:                           sendMessage5(OPC_PNN, 0,0, PARAM_MANU, PARAM_MODULE_ID, getParameterFlags());
1014C  0E00     MOVLW 0x0
1014E  6E25     MOVWF 0x25, ACCESS
10150  0E00     MOVLW 0x0
10152  6E26     MOVWF 0x26, ACCESS
10154  0EA5     MOVLW 0xA5
10156  6E27     MOVWF 0x27, ACCESS
10158  0E1D     MOVLW 0x1D
1015A  6E28     MOVWF 0x28, ACCESS
1015C  ECC1     CALL 0x15982, 0
1015E  F0AC     NOP
10160  6E29     MOVWF 0x29, ACCESS
10162  0EB6     MOVLW 0xB6
10164  EC7D     CALL 0x15EFA, 0
10166  F0AF     NOP
10168  D79A     BRA 0x9E
398:                           return PROCESSED;
399:                       default:
400:                           break;
401:                   }
1016A  EE20     LFSR 2, 0x1
1016C  F001     NOP
1016E  5046     MOVF NVMDAT, W, ACCESS
10170  26D9     ADDWF 0xFD9, F, ACCESS
10172  5047     MOVF NVMDATH, W, ACCESS
10174  22DA     ADDWFC 0xFDA, F, ACCESS
10176  50DF     MOVF 0xFDF, W, ACCESS
10178  6FE0     MOVWF 0xE0, BANKED
1017A  6BE1     CLRF 0xE1, BANKED
1017C  51E1     MOVF 0xE1, W, BANKED
1017E  0A00     XORLW 0x0
10180  A4D8     BTFSS 0xFD8, 2, ACCESS
10182  D00D     BRA 0x19E
10184  51E0     MOVF 0xE0, W, BANKED
10186  0A0D     XORLW 0xD
10188  B4D8     BTFSC 0xFD8, 2, ACCESS
1018A  D7E0     BRA ee_write
1018C  0A1D     XORLW 0x1D
1018E  B4D8     BTFSC 0xFD8, 2, ACCESS
10190  D788     BRA 0xA2
10192  0A01     XORLW 0x1
10194  B4D8     BTFSC 0xFD8, 2, ACCESS
10196  D797     BRA 0xC6
10198  0A53     XORLW 0x53
1019A  B4D8     BTFSC 0xFD8, 2, ACCESS
1019C  D736     BRA 0xA
402:                   return NOT_PROCESSED;
1019E  0E00     MOVLW 0x0
101A0  0012     RETURN 0
403:               }
404:               // No NN but in Normal mode or equivalent message processing
405:               switch (m->opc) {
406:                   case OPC_QNN:   // Query node
407:                       sendMessage5(OPC_PNN, nn.bytes.hi,nn.bytes.lo, PARAM_MANU, PARAM_MODULE_ID, getParameterFlags());
101A2  C554     MOVFF 0x554, data1
101A4  F525     NOP
101A6  C553     MOVFF nn, data2
101A8  F526     NOP
101AA  0EA5     MOVLW 0xA5
101AC  6E27     MOVWF 0x27, ACCESS
101AE  0E1D     MOVLW 0x1D
101B0  6E28     MOVWF 0x28, ACCESS
101B2  ECC1     CALL 0x15982, 0
101B4  F0AC     NOP
101B6  6E29     MOVWF 0x29, ACCESS
101B8  0EB6     MOVLW 0xB6
101BA  EC7D     CALL 0x15EFA, 0
101BC  F0AF     NOP
101BE  D76F     BRA 0x9E
408:                       return PROCESSED;
409:           #ifdef VLCB_MODE
410:                   case OPC_MODE:  // MODE
411:                       if (m->len < 4) {
101C0  C546     MOVFF m, FSR2
101C2  F4D9     NOP
101C4  C547     MOVFF 0x547, FSR2H
101C6  F4DA     NOP
101C8  0E04     MOVLW 0x4
101CA  60DF     CPFSLT 0xFDF, ACCESS
101CC  D00E     BRA 0x1EA
412:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, CMDERR_INV_CMD);
101CE  C554     MOVFF 0x554, data1
101D0  F525     NOP
101D2  C553     MOVFF nn, data2
101D4  F526     NOP
101D6  0E76     MOVLW 0x76
101D8  6E27     MOVWF 0x27, ACCESS
101DA  0E01     MOVLW 0x1
101DC  6E28     MOVWF 0x28, ACCESS
101DE  0E01     MOVLW 0x1
101E0  6E29     MOVWF 0x29, ACCESS
101E2  0EAF     MOVLW 0xAF
101E4  EC7D     CALL 0x15EFA, 0
101E6  F0AF     NOP
101E8  D75A     BRA 0x9E
413:                           return PROCESSED;
414:                       }
415:                       if ((m->bytes[0] == 0) && (m->bytes[1] == 0)) { // Global MODE
101EA  EE20     LFSR 2, 0x2
101EC  F002     NOP
101EE  5046     MOVF NVMDAT, W, ACCESS
101F0  26D9     ADDWF 0xFD9, F, ACCESS
101F2  5047     MOVF NVMDATH, W, ACCESS
101F4  22DA     ADDWFC 0xFDA, F, ACCESS
101F6  50DF     MOVF 0xFDF, W, ACCESS
101F8  A4D8     BTFSS 0xFD8, 2, ACCESS
101FA  D031     BRA 0x25E
101FC  EE20     LFSR 2, 0x3
101FE  F003     NOP
10200  5046     MOVF NVMDAT, W, ACCESS
10202  26D9     ADDWF 0xFD9, F, ACCESS
10204  5047     MOVF NVMDATH, W, ACCESS
10206  22DA     ADDWFC 0xFDA, F, ACCESS
10208  50DF     MOVF 0xFDF, W, ACCESS
1020A  A4D8     BTFSS 0xFD8, 2, ACCESS
1020C  D028     BRA 0x25E
416:                           newMode = m->bytes[2];
1020E  EE20     LFSR 2, 0x4
10210  F004     NOP
10212  5046     MOVF NVMDAT, W, ACCESS
10214  26D9     ADDWF 0xFD9, F, ACCESS
10216  5047     MOVF NVMDATH, W, ACCESS
10218  22DA     ADDWFC 0xFDA, F, ACCESS
1021A  50DF     MOVF 0xFDF, W, ACCESS
1021C  6E4C     MOVWF ZCDCON, ACCESS
417:                           // do heartbeat change
418:                           if (newMode == MODE_HEARTBEAT_ON) {
1021E  0E0C     MOVLW 0xC
10220  184C     XORWF ZCDCON, W, ACCESS
10222  A4D8     BTFSS 0xFD8, 2, ACCESS
10224  D002     BRA 0x22A
419:                               mode_flags |= FLAG_MODE_HEARTBEAT;
10226  85B4     BSF PRLOCK, 2, BANKED
10228  D73A     BRA 0x9E
420:           //                    sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, GRSP_OK);
421:                               return PROCESSED;
422:                           } else if (newMode == MODE_HEARTBEAT_OFF) {
1022A  0E0D     MOVLW 0xD
1022C  184C     XORWF ZCDCON, W, ACCESS
1022E  A4D8     BTFSS 0xFD8, 2, ACCESS
10230  D016     BRA 0x25E
423:                               mode_flags &= ~FLAG_MODE_HEARTBEAT;
10232  95B4     BCF PRLOCK, 2, BANKED
10234  D734     BRA 0x9E
424:           //                    sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, GRSP_OK);
425:                               return PROCESSED;
426:                           }
427:                       }
428:                       break;
429:           #endif
430:                   default:
431:                       break;
432:               }
10236  EE20     LFSR 2, 0x1
10238  F001     NOP
1023A  5046     MOVF NVMDAT, W, ACCESS
1023C  26D9     ADDWF 0xFD9, F, ACCESS
1023E  5047     MOVF NVMDATH, W, ACCESS
10240  22DA     ADDWFC 0xFDA, F, ACCESS
10242  50DF     MOVF 0xFDF, W, ACCESS
10244  6FE0     MOVWF 0xE0, BANKED
10246  6BE1     CLRF 0xE1, BANKED
10248  51E1     MOVF 0xE1, W, BANKED
1024A  0A00     XORLW 0x0
1024C  A4D8     BTFSS 0xFD8, 2, ACCESS
1024E  D007     BRA 0x25E
10250  51E0     MOVF 0xE0, W, BANKED
10252  0A0D     XORLW 0xD
10254  B4D8     BTFSC 0xFD8, 2, ACCESS
10256  D7A5     BRA 0x1A2
10258  0A7B     XORLW 0x7B
1025A  B4D8     BTFSC 0xFD8, 2, ACCESS
1025C  D7B1     BRA 0x1C0
433:               if (m->len < 3) {
1025E  C546     MOVFF m, FSR2
10260  F4D9     NOP
10262  C547     MOVFF 0x547, FSR2H
10264  F4DA     NOP
10266  0E03     MOVLW 0x3
10268  60DF     CPFSLT 0xFDF, ACCESS
1026A  D001     BRA 0x26E
1026C  D798     BRA 0x19E
434:                   return NOT_PROCESSED;
435:               }
436:               // With NN - check it is us
437:               if (m->bytes[0] != nn.bytes.hi) return NOT_PROCESSED;
1026E  EE20     LFSR 2, 0x2
10270  F002     NOP
10272  5046     MOVF NVMDAT, W, ACCESS
10274  26D9     ADDWF 0xFD9, F, ACCESS
10276  5047     MOVF NVMDATH, W, ACCESS
10278  22DA     ADDWFC 0xFDA, F, ACCESS
1027A  50DE     MOVF 0xFDE, W, ACCESS
1027C  1854     XORWF 0x54, W, ACCESS
1027E  A4D8     BTFSS 0xFD8, 2, ACCESS
10280  D78E     BRA 0x19E
438:               if (m->bytes[1] != nn.bytes.lo) return NOT_PROCESSED;
10282  EE20     LFSR 2, 0x3
10284  F003     NOP
10286  5046     MOVF NVMDAT, W, ACCESS
10288  26D9     ADDWF 0xFD9, F, ACCESS
1028A  5047     MOVF NVMDATH, W, ACCESS
1028C  22DA     ADDWFC 0xFDA, F, ACCESS
1028E  5053     MOVF 0x53, W, ACCESS
10290  18DE     XORWF 0xFDE, W, ACCESS
10292  A4D8     BTFSS 0xFD8, 2, ACCESS
10294  D784     BRA 0x19E
10296  D3E6     BRA 0xA64
439:               // NN message processing
440:               switch (m->opc) {
441:                   case OPC_RQNPN: // request node parameter
442:                       if (m->len < 4) {
10298  C546     MOVFF m, FSR2
1029A  F4D9     NOP
1029C  C547     MOVFF 0x547, FSR2H
1029E  F4DA     NOP
102A0  0E04     MOVLW 0x4
102A2  60DF     CPFSLT 0xFDF, ACCESS
102A4  D00E     BRA 0x2C2
443:           #ifdef VLCB_GRSP
444:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RQNPN, SERVICE_ID_MNS, CMDERR_INV_CMD);
102A6  C554     MOVFF 0x554, data1
102A8  F525     NOP
102AA  C553     MOVFF nn, data2
102AC  F526     NOP
102AE  0E73     MOVLW 0x73
102B0  6E27     MOVWF 0x27, ACCESS
102B2  0E01     MOVLW 0x1
102B4  6E28     MOVWF 0x28, ACCESS
102B6  0E01     MOVLW 0x1
102B8  6E29     MOVWF 0x29, ACCESS
102BA  0EAF     MOVLW 0xAF
102BC  EC7D     CALL 0x15EFA, 0
102BE  F0AF     NOP
102C0  D6EE     BRA 0x9E
445:           #endif
446:                           return PROCESSED;
447:                       }
448:                       if (m->bytes[2] > 20) {
102C2  EE20     LFSR 2, 0x4
102C4  F004     NOP
102C6  5046     MOVF NVMDAT, W, ACCESS
102C8  26D9     ADDWF 0xFD9, F, ACCESS
102CA  5047     MOVF NVMDATH, W, ACCESS
102CC  22DA     ADDWFC 0xFDA, F, ACCESS
102CE  0E14     MOVLW 0x14
102D0  64DF     CPFSGT 0xFDF, ACCESS
102D2  D017     BRA 0x302
449:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_PARAM_IDX);
102D4  C554     MOVFF 0x554, data1
102D6  F525     NOP
102D8  C553     MOVFF nn, data2
102DA  F526     NOP
102DC  0E09     MOVLW 0x9
102DE  6E27     MOVWF 0x27, ACCESS
102E0  0E6F     MOVLW 0x6F
102E2  EC3E     CALL 0x15E7C, 0
102E4  F0AF     NOP
450:           #ifdef VLCB_GRSP
451:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RQNPN, SERVICE_ID_MNS, CMDERR_INV_PARAM_IDX);
102E6  C554     MOVFF 0x554, data1
102E8  F525     NOP
102EA  C553     MOVFF nn, data2
102EC  F526     NOP
102EE  0E73     MOVLW 0x73
102F0  6E27     MOVWF 0x27, ACCESS
102F2  0E01     MOVLW 0x1
102F4  6E28     MOVWF 0x28, ACCESS
102F6  0E09     MOVLW 0x9
102F8  6E29     MOVWF 0x29, ACCESS
102FA  0EAF     MOVLW 0xAF
102FC  EC7D     CALL 0x15EFA, 0
102FE  F0AF     NOP
10300  D6CE     BRA 0x9E
452:           #endif
453:                           return PROCESSED;
454:                       }
455:                       i = getParameter(m->bytes[2]);
10302  EE20     LFSR 2, 0x4
10304  F004     NOP
10306  5046     MOVF NVMDAT, W, ACCESS
10308  26D9     ADDWF 0xFD9, F, ACCESS
1030A  5047     MOVF NVMDATH, W, ACCESS
1030C  22DA     ADDWFC 0xFDA, F, ACCESS
1030E  50DF     MOVF 0xFDF, W, ACCESS
10310  EC3D     CALL 0x1347A, 0
10312  F09A     NOP
10314  6E48     MOVWF VREGCON, ACCESS
456:                       sendMessage4(OPC_PARAN, nn.bytes.hi, nn.bytes.lo, m->bytes[2], i);
10316  C554     MOVFF 0x554, data1
10318  F525     NOP
1031A  C553     MOVFF nn, data2
1031C  F526     NOP
1031E  EE20     LFSR 2, 0x4
10320  F004     NOP
10322  5046     MOVF NVMDAT, W, ACCESS
10324  26D9     ADDWF 0xFD9, F, ACCESS
10326  5047     MOVF NVMDATH, W, ACCESS
10328  22DA     ADDWFC 0xFDA, F, ACCESS
1032A  50DF     MOVF 0xFDF, W, ACCESS
1032C  6E27     MOVWF 0x27, ACCESS
1032E  C548     MOVFF i, data4
10330  F528     NOP
10332  0E9B     MOVLW 0x9B
10334  EC92     CALL 0x15F24, 0
10336  F0AF     NOP
457:           #ifdef VLCB_ZERO_RESPONSES
458:                       if (m->bytes[2] == 0) {
10338  EE20     LFSR 2, 0x4
1033A  F004     NOP
1033C  5046     MOVF NVMDAT, W, ACCESS
1033E  26D9     ADDWF 0xFD9, F, ACCESS
10340  5047     MOVF NVMDATH, W, ACCESS
10342  22DA     ADDWFC 0xFDA, F, ACCESS
10344  50DF     MOVF 0xFDF, W, ACCESS
10346  A4D8     BTFSS 0xFD8, 2, ACCESS
10348  D6AA     BRA 0x9E
459:                           startTimedResponse(TIMED_RESPONSE_RQNPN, findServiceIndex(SERVICE_ID_MNS), mnsTRrqnpnCallback);
1034A  0E01     MOVLW 0x1
1034C  EC18     CALL 0x14C30, 0
1034E  F0A6     NOP
10350  6E06     MOVWF 0x6, ACCESS
10352  0E76     MOVLW 0x76
10354  6E07     MOVWF 0x7, ACCESS
10356  0E5F     MOVLW 0x5F
10358  6E08     MOVWF 0x8, ACCESS
1035A  0E01     MOVLW 0x1
1035C  6E09     MOVWF 0x9, ACCESS
1035E  0E07     MOVLW 0x7
10360  ECE2     CALL 0x159C4, 0
10362  F0AC     NOP
10364  D69C     BRA 0x9E
460:                       }
461:           #endif
462:                       return PROCESSED;
463:                   case OPC_NNRSM: // reset to manufacturer defaults
464:                       previousNN.word = nn.word;  // save the old NN
10366  C553     MOVFF nn, previousNN
10368  F599     NOP
1036A  C554     MOVFF 0x554, 0x59A
1036C  F59A     NOP
465:                       factoryReset();
1036E  EC45     CALL 0x1388A, 0
10370  F09C     NOP
466:                       if (previousNN.word != 0) {
10372  0105     MOVLB 0x5
10374  5199     MOVF SPI2CLK, W, BANKED
10376  119A     IORWF 0x9A, W, BANKED
10378  B4D8     BTFSC 0xFD8, 2, ACCESS
1037A  D007     BRA 0x38A
467:                           sendMessage2(OPC_NNREL, previousNN.bytes.hi, previousNN.bytes.lo);
1037C  C59A     MOVFF 0x59A, data1
1037E  F525     NOP
10380  C599     MOVFF previousNN, data2
10382  F526     NOP
10384  0E51     MOVLW 0x51
10386  EC53     CALL 0x15EA6, 0
10388  F0AF     NOP
468:                       }
469:                       RESET();
1038A  00FF     RESET
470:           #ifdef VLCB_DIAG
471:                   case OPC_RDGN:  // diagnostics
472:                       if (m->len < 5) {
1038C  C546     MOVFF m, FSR2
1038E  F4D9     NOP
10390  C547     MOVFF 0x547, FSR2H
10392  F4DA     NOP
10394  0E05     MOVLW 0x5
10396  60DF     CPFSLT 0xFDF, ACCESS
10398  D00E     BRA 0x3B6
473:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RDGN, SERVICE_ID_MNS, CMDERR_INV_CMD);
1039A  C554     MOVFF 0x554, data1
1039C  F525     NOP
1039E  C553     MOVFF nn, data2
103A0  F526     NOP
103A2  0E87     MOVLW 0x87
103A4  6E27     MOVWF 0x27, ACCESS
103A6  0E01     MOVLW 0x1
103A8  6E28     MOVWF 0x28, ACCESS
103AA  0E01     MOVLW 0x1
103AC  6E29     MOVWF 0x29, ACCESS
103AE  0EAF     MOVLW 0xAF
103B0  EC7D     CALL 0x15EFA, 0
103B2  F0AF     NOP
103B4  D674     BRA 0x9E
474:                           return PROCESSED;
475:                       }
476:                       if (m->bytes[2] == 0) {
103B6  EE20     LFSR 2, 0x4
103B8  F004     NOP
103BA  5046     MOVF NVMDAT, W, ACCESS
103BC  26D9     ADDWF 0xFD9, F, ACCESS
103BE  5047     MOVF NVMDATH, W, ACCESS
103C0  22DA     ADDWFC 0xFDA, F, ACCESS
103C2  50DF     MOVF 0xFDF, W, ACCESS
103C4  A4D8     BTFSS 0xFD8, 2, ACCESS
103C6  D00C     BRA 0x3E0
477:                           // a DGN response for all of the services
478:                           startTimedResponse(TIMED_RESPONSE_RDGN, SERVICE_ID_ALL, mnsTRallDiagnosticsCallback);
103C8  0E00     MOVLW 0x0
103CA  6E06     MOVWF 0x6, ACCESS
103CC  0E96     MOVLW 0x96
103CE  6E07     MOVWF 0x7, ACCESS
103D0  0E36     MOVLW 0x36
103D2  6E08     MOVWF 0x8, ACCESS
103D4  0E01     MOVLW 0x1
103D6  6E09     MOVWF 0x9, ACCESS
103D8  0E04     MOVLW 0x4
103DA  ECE2     CALL 0x159C4, 0
103DC  F0AC     NOP
479:                       } else {
103DE  D65F     BRA 0x9E
480:                           // bytes[2] is a serviceIndex
481:                           if (m->bytes[2] > NUM_SERVICES) {
103E0  EE20     LFSR 2, 0x4
103E2  F004     NOP
103E4  5046     MOVF NVMDAT, W, ACCESS
103E6  26D9     ADDWF 0xFD9, F, ACCESS
103E8  5047     MOVF NVMDATH, W, ACCESS
103EA  22DA     ADDWFC 0xFDA, F, ACCESS
103EC  0E09     MOVLW 0x9
103EE  64DF     CPFSGT 0xFDF, ACCESS
103F0  D00E     BRA 0x40E
482:                               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RDGN, 1, GRSP_INVALID_SERVICE);
103F2  C554     MOVFF 0x554, data1
103F4  F525     NOP
103F6  C553     MOVFF nn, data2
103F8  F526     NOP
103FA  0E87     MOVLW 0x87
103FC  6E27     MOVWF 0x27, ACCESS
103FE  0E01     MOVLW 0x1
10400  6E28     MOVWF 0x28, ACCESS
10402  0EFC     MOVLW 0xFC
10404  6E29     MOVWF 0x29, ACCESS
10406  0EAF     MOVLW 0xAF
10408  EC7D     CALL 0x15EFA, 0
1040A  F0AF     NOP
1040C  D648     BRA 0x9E
483:                               return PROCESSED;
484:                           }
485:                           if (services[m->bytes[2]-1]->getDiagnostic == NULL) {
1040E  EE20     LFSR 2, 0x4
10410  F004     NOP
10412  5046     MOVF NVMDAT, W, ACCESS
10414  26D9     ADDWF 0xFD9, F, ACCESS
10416  5047     MOVF NVMDATH, W, ACCESS
10418  22DA     ADDWFC 0xFDA, F, ACCESS
1041A  50DF     MOVF 0xFDF, W, ACCESS
1041C  0105     MOVLB 0x5
1041E  6FE0     MOVWF 0xE0, BANKED
10420  6BE1     CLRF 0xE1, BANKED
10422  90D8     BCF 0xFD8, 0, ACCESS
10424  37E0     RLCF 0xE0, F, BANKED
10426  37E1     RLCF 0xE1, F, BANKED
10428  0EFE     MOVLW 0xFE
1042A  25E0     ADDWF 0xE0, W, BANKED
1042C  6FE2     MOVWF 0xE2, BANKED
1042E  0EFF     MOVLW 0xFF
10430  21E1     ADDWFC 0xE1, W, BANKED
10432  6FE3     MOVWF 0xE3, BANKED
10434  0E23     MOVLW 0x23
10436  25E2     ADDWF 0xE2, W, BANKED
10438  6EF6     MOVWF 0xFF6, ACCESS
1043A  0EFF     MOVLW 0xFF
1043C  21E3     ADDWFC 0xE3, W, BANKED
1043E  6EF7     MOVWF 0xFF7, ACCESS
10440  6AF8     CLRF 0xFF8, ACCESS
10442  0E00     MOVLW 0x0
10444  22F8     ADDWFC 0xFF8, F, ACCESS
10446  0009     TBLRD*+
10448  C4F5     MOVFF TABLAT, 0x5E4
1044A  F5E4     NOP
1044C  0009     TBLRD*+
1044E  C4F5     MOVFF TABLAT, 0x5E5
10450  F5E5     NOP
10452  0E11     MOVLW 0x11
10454  27E4     ADDWF 0xE4, F, BANKED
10456  0E00     MOVLW 0x0
10458  23E5     ADDWFC 0xE5, F, BANKED
1045A  C5E4     MOVFF 0x5E4, TBLPTR
1045C  F4F6     NOP
1045E  C5E5     MOVFF 0x5E5, TBLPTRH
10460  F4F7     NOP
10462  0E00     MOVLW 0x0
10464  6EF8     MOVWF 0xFF8, ACCESS
10466  0009     TBLRD*+
10468  50F5     MOVF 0xFF5, W, ACCESS
1046A  0009     TBLRD*+
1046C  10F5     IORWF 0xFF5, W, ACCESS
1046E  0009     TBLRD*+
10470  10F5     IORWF 0xFF5, W, ACCESS
10472  A4D8     BTFSS 0xFD8, 2, ACCESS
10474  D013     BRA 0x49C
486:                               // the service doesn't support diagnostics
487:                               sendMessage5(OPC_DGN, nn.bytes.hi, nn.bytes.lo, OPC_RDGN, m->bytes[2], 0);
10476  C554     MOVFF 0x554, data1
10478  F525     NOP
1047A  C553     MOVFF nn, data2
1047C  F526     NOP
1047E  0E87     MOVLW 0x87
10480  6E27     MOVWF 0x27, ACCESS
10482  EE20     LFSR 2, 0x4
10484  F004     NOP
10486  5046     MOVF NVMDAT, W, ACCESS
10488  26D9     ADDWF 0xFD9, F, ACCESS
1048A  5047     MOVF NVMDATH, W, ACCESS
1048C  22DA     ADDWFC 0xFDA, F, ACCESS
1048E  50DF     MOVF 0xFDF, W, ACCESS
10490  6E28     MOVWF 0x28, ACCESS
10492  0E00     MOVLW 0x0
10494  6E29     MOVWF 0x29, ACCESS
10496  0EC7     MOVLW 0xC7
10498  EC7D     CALL 0x15EFA, 0
1049A  F0AF     NOP
488:                           } 
489:                           if (m->bytes[3] == 0) {
1049C  EE20     LFSR 2, 0x5
1049E  F005     NOP
104A0  5046     MOVF NVMDAT, W, ACCESS
104A2  26D9     ADDWF 0xFD9, F, ACCESS
104A4  5047     MOVF NVMDATH, W, ACCESS
104A6  22DA     ADDWFC 0xFDA, F, ACCESS
104A8  50DF     MOVF 0xFDF, W, ACCESS
104AA  A4D8     BTFSS 0xFD8, 2, ACCESS
104AC  D012     BRA 0x4D2
490:                               // a DGN for all diagnostics for a particular service
491:                               startTimedResponse(TIMED_RESPONSE_RDGN, m->bytes[2], mnsTRallDiagnosticsCallback);
104AE  EE20     LFSR 2, 0x4
104B0  F004     NOP
104B2  5046     MOVF NVMDAT, W, ACCESS
104B4  26D9     ADDWF 0xFD9, F, ACCESS
104B6  5047     MOVF NVMDATH, W, ACCESS
104B8  22DA     ADDWFC 0xFDA, F, ACCESS
104BA  50DF     MOVF 0xFDF, W, ACCESS
104BC  6E06     MOVWF 0x6, ACCESS
104BE  0E96     MOVLW 0x96
104C0  6E07     MOVWF 0x7, ACCESS
104C2  0E36     MOVLW 0x36
104C4  6E08     MOVWF 0x8, ACCESS
104C6  0E01     MOVLW 0x1
104C8  6E09     MOVWF 0x9, ACCESS
104CA  0E04     MOVLW 0x4
104CC  ECE2     CALL 0x159C4, 0
104CE  F0AC     NOP
104D0  D5E6     BRA 0x9E
492:                               return PROCESSED;
493:                           } else {
494:                               DiagnosticVal * d = services[m->bytes[2]-1]->getDiagnostic(m->bytes[3]);
104D2  EE20     LFSR 2, 0x4
104D4  F004     NOP
104D6  5046     MOVF NVMDAT, W, ACCESS
104D8  26D9     ADDWF 0xFD9, F, ACCESS
104DA  5047     MOVF NVMDATH, W, ACCESS
104DC  22DA     ADDWFC 0xFDA, F, ACCESS
104DE  50DF     MOVF 0xFDF, W, ACCESS
104E0  0105     MOVLB 0x5
104E2  6FE0     MOVWF 0xE0, BANKED
104E4  6BE1     CLRF 0xE1, BANKED
104E6  90D8     BCF 0xFD8, 0, ACCESS
104E8  37E0     RLCF 0xE0, F, BANKED
104EA  37E1     RLCF 0xE1, F, BANKED
104EC  0EFE     MOVLW 0xFE
104EE  25E0     ADDWF 0xE0, W, BANKED
104F0  6FE2     MOVWF 0xE2, BANKED
104F2  0EFF     MOVLW 0xFF
104F4  21E1     ADDWFC 0xE1, W, BANKED
104F6  6FE3     MOVWF 0xE3, BANKED
104F8  0E23     MOVLW 0x23
104FA  25E2     ADDWF 0xE2, W, BANKED
104FC  6EF6     MOVWF 0xFF6, ACCESS
104FE  0EFF     MOVLW 0xFF
10500  21E3     ADDWFC 0xE3, W, BANKED
10502  6EF7     MOVWF 0xFF7, ACCESS
10504  6AF8     CLRF 0xFF8, ACCESS
10506  0E00     MOVLW 0x0
10508  22F8     ADDWFC 0xFF8, F, ACCESS
1050A  0009     TBLRD*+
1050C  C4F5     MOVFF TABLAT, 0x5E4
1050E  F5E4     NOP
10510  0009     TBLRD*+
10512  C4F5     MOVFF TABLAT, 0x5E5
10514  F5E5     NOP
10516  0E11     MOVLW 0x11
10518  27E4     ADDWF 0xE4, F, BANKED
1051A  0E00     MOVLW 0x0
1051C  23E5     ADDWFC 0xE5, F, BANKED
1051E  C5E4     MOVFF 0x5E4, TBLPTR
10520  F4F6     NOP
10522  C5E5     MOVFF 0x5E5, TBLPTRH
10524  F4F7     NOP
10526  0E00     MOVLW 0x0
10528  6EF8     MOVWF 0xFF8, ACCESS
1052A  D801     RCALL 0x52E
1052C  D014     BRA 0x556
1052E  0005     PUSH
10530  6EFA     MOVWF 0xFFA, ACCESS
10532  0009     TBLRD*+
10534  50F5     MOVF 0xFF5, W, ACCESS
10536  6EFD     MOVWF 0xFFD, ACCESS
10538  0009     TBLRD*+
1053A  50F5     MOVF 0xFF5, W, ACCESS
1053C  6EFE     MOVWF 0xFFE, ACCESS
1053E  0009     TBLRD*+
10540  50F5     MOVF 0xFF5, W, ACCESS
10542  6EFF     MOVWF 0xFFF, ACCESS
10544  50FA     MOVF 0xFFA, W, ACCESS
10546  EE20     LFSR 2, 0x5
10548  F005     NOP
1054A  5046     MOVF NVMDAT, W, ACCESS
1054C  26D9     ADDWF 0xFD9, F, ACCESS
1054E  5047     MOVF NVMDATH, W, ACCESS
10550  22DA     ADDWFC 0xFDA, F, ACCESS
10552  50DF     MOVF 0xFDF, W, ACCESS
10554  0012     RETURN 0
10556  C508     MOVFF index, eventEN
10558  F54A     NOP
1055A  C509     MOVFF d, enn
1055C  F54B     NOP
495:                               if (d == NULL) {
1055E  504A     MOVF HLVDCON0, W, ACCESS
10560  104B     IORWF HLVDCON1, W, ACCESS
10562  A4D8     BTFSS 0xFD8, 2, ACCESS
10564  D00E     BRA 0x582
496:                                   // the requested diagnostic doesn't exist
497:                                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RDGN, 1, GRSP_INVALID_DIAGNOSTIC);
10566  C554     MOVFF 0x554, data1
10568  F525     NOP
1056A  C553     MOVFF nn, data2
1056C  F526     NOP
1056E  0E87     MOVLW 0x87
10570  6E27     MOVWF 0x27, ACCESS
10572  0E01     MOVLW 0x1
10574  6E28     MOVWF 0x28, ACCESS
10576  0EFD     MOVLW 0xFD
10578  6E29     MOVWF 0x29, ACCESS
1057A  0EAF     MOVLW 0xAF
1057C  EC7D     CALL 0x15EFA, 0
1057E  F0AF     NOP
498:                               } else {
10580  D58E     BRA 0x9E
499:                                   // it was a request for a single diagnostic from a single service
500:                                   sendMessage6(OPC_DGN, nn.bytes.hi, nn.bytes.lo, m->bytes[2], m->bytes[3],d->asBytes.hi, d->asBytes.lo);
10582  C554     MOVFF 0x554, data1
10584  F525     NOP
10586  C553     MOVFF nn, data2
10588  F526     NOP
1058A  EE20     LFSR 2, 0x4
1058C  F004     NOP
1058E  5046     MOVF NVMDAT, W, ACCESS
10590  26D9     ADDWF 0xFD9, F, ACCESS
10592  5047     MOVF NVMDATH, W, ACCESS
10594  22DA     ADDWFC 0xFDA, F, ACCESS
10596  50DF     MOVF 0xFDF, W, ACCESS
10598  6E27     MOVWF 0x27, ACCESS
1059A  EE20     LFSR 2, 0x5
1059C  F005     NOP
1059E  5046     MOVF NVMDAT, W, ACCESS
105A0  26D9     ADDWF 0xFD9, F, ACCESS
105A2  5047     MOVF NVMDATH, W, ACCESS
105A4  22DA     ADDWFC 0xFDA, F, ACCESS
105A6  50DF     MOVF 0xFDF, W, ACCESS
105A8  6E28     MOVWF 0x28, ACCESS
105AA  EE20     LFSR 2, 0x1
105AC  F001     NOP
105AE  504A     MOVF HLVDCON0, W, ACCESS
105B0  26D9     ADDWF 0xFD9, F, ACCESS
105B2  504B     MOVF HLVDCON1, W, ACCESS
105B4  22DA     ADDWFC 0xFDA, F, ACCESS
105B6  50DF     MOVF 0xFDF, W, ACCESS
105B8  6E29     MOVWF 0x29, ACCESS
105BA  C54A     MOVFF eventEN, FSR2
105BC  F4D9     NOP
105BE  C54B     MOVFF enn, FSR2H
105C0  F4DA     NOP
105C2  50DF     MOVF 0xFDF, W, ACCESS
105C4  6E2A     MOVWF 0x2A, ACCESS
105C6  0EC7     MOVLW 0xC7
105C8  EC29     CALL 0x15E52, 0
105CA  F0AF     NOP
105CC  D568     BRA 0x9E
501:                               }
502:                           }
503:                       }
504:                       return PROCESSED;
505:           #endif
506:           #ifdef VLCB_SERVICE
507:                   case OPC_RQSD:  // service discovery
508:                       if (m->len < 4) {
105CE  C546     MOVFF m, FSR2
105D0  F4D9     NOP
105D2  C547     MOVFF 0x547, FSR2H
105D4  F4DA     NOP
105D6  0E04     MOVLW 0x4
105D8  60DF     CPFSLT 0xFDF, ACCESS
105DA  D00E     BRA 0x5F8
509:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RQSD, SERVICE_ID_MNS, CMDERR_INV_CMD);
105DC  C554     MOVFF 0x554, data1
105DE  F525     NOP
105E0  C553     MOVFF nn, data2
105E2  F526     NOP
105E4  0E78     MOVLW 0x78
105E6  6E27     MOVWF 0x27, ACCESS
105E8  0E01     MOVLW 0x1
105EA  6E28     MOVWF 0x28, ACCESS
105EC  0E01     MOVLW 0x1
105EE  6E29     MOVWF 0x29, ACCESS
105F0  0EAF     MOVLW 0xAF
105F2  EC7D     CALL 0x15EFA, 0
105F4  F0AF     NOP
105F6  D553     BRA 0x9E
510:                           return PROCESSED;
511:                       }
512:                       if (m->bytes[2] == 0) {
105F8  EE20     LFSR 2, 0x4
105FA  F004     NOP
105FC  5046     MOVF NVMDAT, W, ACCESS
105FE  26D9     ADDWF 0xFD9, F, ACCESS
10600  5047     MOVF NVMDATH, W, ACCESS
10602  22DA     ADDWFC 0xFDA, F, ACCESS
10604  50DF     MOVF 0xFDF, W, ACCESS
10606  A4D8     BTFSS 0xFD8, 2, ACCESS
10608  D019     BRA 0x63C
513:                           // start with the number of services
514:                           sendMessage5(OPC_SD, nn.bytes.hi, nn.bytes.lo, 0, 0, NUM_SERVICES);
1060A  C554     MOVFF 0x554, data1
1060C  F525     NOP
1060E  C553     MOVFF nn, data2
10610  F526     NOP
10612  0E00     MOVLW 0x0
10614  6E27     MOVWF 0x27, ACCESS
10616  0E00     MOVLW 0x0
10618  6E28     MOVWF 0x28, ACCESS
1061A  0E09     MOVLW 0x9
1061C  6E29     MOVWF 0x29, ACCESS
1061E  0EAC     MOVLW 0xAC
10620  EC7D     CALL 0x15EFA, 0
10622  F0AF     NOP
515:                           // now a SD response for all of the services
516:                           startTimedResponse(TIMED_RESPONSE_RQSD, SERVICE_ID_MNS, mnsTRserviceDiscoveryCallback);
10624  0E01     MOVLW 0x1
10626  6E06     MOVWF 0x6, ACCESS
10628  0E42     MOVLW 0x42
1062A  6E07     MOVWF 0x7, ACCESS
1062C  0E44     MOVLW 0x44
1062E  6E08     MOVWF 0x8, ACCESS
10630  0E01     MOVLW 0x1
10632  6E09     MOVWF 0x9, ACCESS
10634  0E03     MOVLW 0x3
10636  ECE2     CALL 0x159C4, 0
10638  F0AC     NOP
517:                       } else if (m->bytes[2] > NUM_SERVICES) {
1063A  D531     BRA 0x9E
1063C  EE20     LFSR 2, 0x4
1063E  F004     NOP
10640  5046     MOVF NVMDAT, W, ACCESS
10642  26D9     ADDWF 0xFD9, F, ACCESS
10644  5047     MOVF NVMDATH, W, ACCESS
10646  22DA     ADDWFC 0xFDA, F, ACCESS
10648  0E09     MOVLW 0x9
1064A  64DF     CPFSGT 0xFDF, ACCESS
1064C  D00E     BRA 0x66A
518:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_RQSD, SERVICE_ID_MNS, GRSP_INVALID_SERVICE);
1064E  C554     MOVFF 0x554, data1
10650  F525     NOP
10652  C553     MOVFF nn, data2
10654  F526     NOP
10656  0E78     MOVLW 0x78
10658  6E27     MOVWF 0x27, ACCESS
1065A  0E01     MOVLW 0x1
1065C  6E28     MOVWF 0x28, ACCESS
1065E  0EFC     MOVLW 0xFC
10660  6E29     MOVWF 0x29, ACCESS
10662  0EAF     MOVLW 0xAF
10664  EC7D     CALL 0x15EFA, 0
10666  F0AF     NOP
10668  D51A     BRA 0x9E
519:                           return PROCESSED;
520:                       }else {
521:                           
522:                           if (services[m->bytes[2]-1]->getESDdata == NULL) {
1066A  EE20     LFSR 2, 0x4
1066C  F004     NOP
1066E  5046     MOVF NVMDAT, W, ACCESS
10670  26D9     ADDWF 0xFD9, F, ACCESS
10672  5047     MOVF NVMDATH, W, ACCESS
10674  22DA     ADDWFC 0xFDA, F, ACCESS
10676  50DF     MOVF 0xFDF, W, ACCESS
10678  6FE0     MOVWF 0xE0, BANKED
1067A  6BE1     CLRF 0xE1, BANKED
1067C  90D8     BCF 0xFD8, 0, ACCESS
1067E  37E0     RLCF 0xE0, F, BANKED
10680  37E1     RLCF 0xE1, F, BANKED
10682  0EFE     MOVLW 0xFE
10684  25E0     ADDWF 0xE0, W, BANKED
10686  6FE2     MOVWF 0xE2, BANKED
10688  0EFF     MOVLW 0xFF
1068A  21E1     ADDWFC 0xE1, W, BANKED
1068C  6FE3     MOVWF 0xE3, BANKED
1068E  0E23     MOVLW 0x23
10690  25E2     ADDWF 0xE2, W, BANKED
10692  6EF6     MOVWF 0xFF6, ACCESS
10694  0EFF     MOVLW 0xFF
10696  21E3     ADDWFC 0xE3, W, BANKED
10698  6EF7     MOVWF 0xFF7, ACCESS
1069A  6AF8     CLRF 0xFF8, ACCESS
1069C  0E00     MOVLW 0x0
1069E  22F8     ADDWFC 0xFF8, F, ACCESS
106A0  0009     TBLRD*+
106A2  C4F5     MOVFF TABLAT, 0x5E4
106A4  F5E4     NOP
106A6  0009     TBLRD*+
106A8  C4F5     MOVFF TABLAT, 0x5E5
106AA  F5E5     NOP
106AC  0E0E     MOVLW 0xE
106AE  27E4     ADDWF 0xE4, F, BANKED
106B0  0E00     MOVLW 0x0
106B2  23E5     ADDWFC 0xE5, F, BANKED
106B4  C5E4     MOVFF 0x5E4, TBLPTR
106B6  F4F6     NOP
106B8  C5E5     MOVFF 0x5E5, TBLPTRH
106BA  F4F7     NOP
106BC  0E00     MOVLW 0x0
106BE  6EF8     MOVWF 0xFF8, ACCESS
106C0  0009     TBLRD*+
106C2  50F5     MOVF 0xFF5, W, ACCESS
106C4  0009     TBLRD*+
106C6  10F5     IORWF 0xFF5, W, ACCESS
106C8  0009     TBLRD*+
106CA  10F5     IORWF 0xFF5, W, ACCESS
106CC  A4D8     BTFSS 0xFD8, 2, ACCESS
106CE  D040     BRA 0x750
523:                               sendMessage7(OPC_ESD, nn.bytes.hi, nn.bytes.lo, m->bytes[2], services[m->bytes[2]-1]->serviceNo, 0,0,0);
106D0  C554     MOVFF 0x554, data1
106D2  F525     NOP
106D4  C553     MOVFF nn, data2
106D6  F526     NOP
106D8  EE20     LFSR 2, 0x4
106DA  F004     NOP
106DC  5046     MOVF NVMDAT, W, ACCESS
106DE  26D9     ADDWF 0xFD9, F, ACCESS
106E0  5047     MOVF NVMDATH, W, ACCESS
106E2  22DA     ADDWFC 0xFDA, F, ACCESS
106E4  50DF     MOVF 0xFDF, W, ACCESS
106E6  6E27     MOVWF 0x27, ACCESS
106E8  EE20     LFSR 2, 0x4
106EA  F004     NOP
106EC  5046     MOVF NVMDAT, W, ACCESS
106EE  26D9     ADDWF 0xFD9, F, ACCESS
106F0  5047     MOVF NVMDATH, W, ACCESS
106F2  22DA     ADDWFC 0xFDA, F, ACCESS
106F4  50DF     MOVF 0xFDF, W, ACCESS
106F6  6FE0     MOVWF 0xE0, BANKED
106F8  6BE1     CLRF 0xE1, BANKED
106FA  90D8     BCF 0xFD8, 0, ACCESS
106FC  37E0     RLCF 0xE0, F, BANKED
106FE  37E1     RLCF 0xE1, F, BANKED
10700  0EFE     MOVLW 0xFE
10702  25E0     ADDWF 0xE0, W, BANKED
10704  6FE2     MOVWF 0xE2, BANKED
10706  0EFF     MOVLW 0xFF
10708  21E1     ADDWFC 0xE1, W, BANKED
1070A  6FE3     MOVWF 0xE3, BANKED
1070C  0E23     MOVLW 0x23
1070E  25E2     ADDWF 0xE2, W, BANKED
10710  6EF6     MOVWF 0xFF6, ACCESS
10712  0EFF     MOVLW 0xFF
10714  21E3     ADDWFC 0xE3, W, BANKED
10716  6EF7     MOVWF 0xFF7, ACCESS
10718  6AF8     CLRF 0xFF8, ACCESS
1071A  0E00     MOVLW 0x0
1071C  22F8     ADDWFC 0xFF8, F, ACCESS
1071E  0009     TBLRD*+
10720  C4F5     MOVFF TABLAT, 0x5E4
10722  F5E4     NOP
10724  0009     TBLRD*+
10726  C4F5     MOVFF TABLAT, 0x5E5
10728  F5E5     NOP
1072A  C5E4     MOVFF 0x5E4, TBLPTR
1072C  F4F6     NOP
1072E  C5E5     MOVFF 0x5E5, TBLPTRH
10730  F4F7     NOP
10732  0E00     MOVLW 0x0
10734  6EF8     MOVWF 0xFF8, ACCESS
10736  0008     TBLRD*
10738  C4F5     MOVFF TABLAT, data4
1073A  F528     NOP
1073C  0E00     MOVLW 0x0
1073E  6E29     MOVWF 0x29, ACCESS
10740  0E00     MOVLW 0x0
10742  6E2A     MOVWF 0x2A, ACCESS
10744  0E00     MOVLW 0x0
10746  6E2B     MOVWF 0x2B, ACCESS
10748  0EE7     MOVLW 0xE7
1074A  EC68     CALL 0x15ED0, 0
1074C  F0AF     NOP
524:                           } else {
1074E  D4A7     BRA 0x9E
525:                               sendMessage7(OPC_ESD, nn.bytes.hi, nn.bytes.lo, m->bytes[2], services[m->bytes[2]-1]->serviceNo, 
10750  C554     MOVFF 0x554, data1
10752  F525     NOP
10754  C553     MOVFF nn, data2
10756  F526     NOP
10758  EE20     LFSR 2, 0x4
1075A  F004     NOP
1075C  5046     MOVF NVMDAT, W, ACCESS
1075E  26D9     ADDWF 0xFD9, F, ACCESS
10760  5047     MOVF NVMDATH, W, ACCESS
10762  22DA     ADDWFC 0xFDA, F, ACCESS
10764  50DF     MOVF 0xFDF, W, ACCESS
10766  6E27     MOVWF 0x27, ACCESS
10768  EE20     LFSR 2, 0x4
1076A  F004     NOP
1076C  5046     MOVF NVMDAT, W, ACCESS
1076E  26D9     ADDWF 0xFD9, F, ACCESS
10770  5047     MOVF NVMDATH, W, ACCESS
10772  22DA     ADDWFC 0xFDA, F, ACCESS
10774  50DF     MOVF 0xFDF, W, ACCESS
10776  6FE0     MOVWF 0xE0, BANKED
10778  6BE1     CLRF 0xE1, BANKED
1077A  90D8     BCF 0xFD8, 0, ACCESS
1077C  37E0     RLCF 0xE0, F, BANKED
1077E  37E1     RLCF 0xE1, F, BANKED
10780  0EFE     MOVLW 0xFE
10782  25E0     ADDWF 0xE0, W, BANKED
10784  6FE2     MOVWF 0xE2, BANKED
10786  0EFF     MOVLW 0xFF
10788  21E1     ADDWFC 0xE1, W, BANKED
1078A  6FE3     MOVWF 0xE3, BANKED
1078C  0E23     MOVLW 0x23
1078E  25E2     ADDWF 0xE2, W, BANKED
10790  6EF6     MOVWF 0xFF6, ACCESS
10792  0EFF     MOVLW 0xFF
10794  21E3     ADDWFC 0xE3, W, BANKED
10796  6EF7     MOVWF 0xFF7, ACCESS
10798  6AF8     CLRF 0xFF8, ACCESS
1079A  0E00     MOVLW 0x0
1079C  22F8     ADDWFC 0xFF8, F, ACCESS
1079E  0009     TBLRD*+
107A0  C4F5     MOVFF TABLAT, 0x5E4
107A2  F5E4     NOP
107A4  0009     TBLRD*+
107A6  C4F5     MOVFF TABLAT, 0x5E5
107A8  F5E5     NOP
107AA  C5E4     MOVFF 0x5E4, TBLPTR
107AC  F4F6     NOP
107AE  C5E5     MOVFF 0x5E5, TBLPTRH
107B0  F4F7     NOP
107B2  0E00     MOVLW 0x0
107B4  6EF8     MOVWF 0xFF8, ACCESS
107B6  0008     TBLRD*
107B8  C4F5     MOVFF TABLAT, data4
107BA  F528     NOP
107BC  EE20     LFSR 2, 0x4
107BE  F004     NOP
107C0  5046     MOVF NVMDAT, W, ACCESS
107C2  26D9     ADDWF 0xFD9, F, ACCESS
107C4  5047     MOVF NVMDATH, W, ACCESS
107C6  22DA     ADDWFC 0xFDA, F, ACCESS
107C8  50DF     MOVF 0xFDF, W, ACCESS
107CA  6FE6     MOVWF 0xE6, BANKED
107CC  6BE7     CLRF 0xE7, BANKED
107CE  90D8     BCF 0xFD8, 0, ACCESS
107D0  37E6     RLCF 0xE6, F, BANKED
107D2  37E7     RLCF 0xE7, F, BANKED
107D4  0EFE     MOVLW 0xFE
107D6  25E6     ADDWF 0xE6, W, BANKED
107D8  6FE8     MOVWF DMASELECT, BANKED
107DA  0EFF     MOVLW 0xFF
107DC  21E7     ADDWFC 0xE7, W, BANKED
107DE  6FE9     MOVWF DMAnBUF, BANKED
107E0  0E23     MOVLW 0x23
107E2  25E8     ADDWF DMASELECT, W, BANKED
107E4  6EF6     MOVWF 0xFF6, ACCESS
107E6  0EFF     MOVLW 0xFF
107E8  21E9     ADDWFC DMAnBUF, W, BANKED
107EA  6EF7     MOVWF 0xFF7, ACCESS
107EC  6AF8     CLRF 0xFF8, ACCESS
107EE  0E00     MOVLW 0x0
107F0  22F8     ADDWFC 0xFF8, F, ACCESS
107F2  0009     TBLRD*+
107F4  C4F5     MOVFF TABLAT, 0x5EA
107F6  F5EA     NOP
107F8  0009     TBLRD*+
107FA  C4F5     MOVFF TABLAT, 0x5EB
107FC  F5EB     NOP
107FE  0E0E     MOVLW 0xE
10800  27EA     ADDWF DMAnDCNT, F, BANKED
10802  0E00     MOVLW 0x0
10804  23EB     ADDWFC DMAnDCNTH, F, BANKED
10806  C5EA     MOVFF 0x5EA, TBLPTR
10808  F4F6     NOP
1080A  C5EB     MOVFF 0x5EB, TBLPTRH
1080C  F4F7     NOP
1080E  0E00     MOVLW 0x0
10810  6EF8     MOVWF 0xFF8, ACCESS
10812  D801     RCALL 0x816
10814  D00E     BRA 0x832
10816  0005     PUSH
10818  6EFA     MOVWF 0xFFA, ACCESS
1081A  0009     TBLRD*+
1081C  50F5     MOVF 0xFF5, W, ACCESS
1081E  6EFD     MOVWF 0xFFD, ACCESS
10820  0009     TBLRD*+
10822  50F5     MOVF 0xFF5, W, ACCESS
10824  6EFE     MOVWF 0xFFE, ACCESS
10826  0009     TBLRD*+
10828  50F5     MOVF 0xFF5, W, ACCESS
1082A  6EFF     MOVWF 0xFFF, ACCESS
1082C  50FA     MOVF 0xFFA, W, ACCESS
1082E  0E01     MOVLW 0x1
10830  0012     RETURN 0
10832  6E29     MOVWF 0x29, ACCESS
10834  EE20     LFSR 2, 0x4
10836  F004     NOP
10838  5046     MOVF NVMDAT, W, ACCESS
1083A  26D9     ADDWF 0xFD9, F, ACCESS
1083C  5047     MOVF NVMDATH, W, ACCESS
1083E  22DA     ADDWFC 0xFDA, F, ACCESS
10840  50DF     MOVF 0xFDF, W, ACCESS
10842  0105     MOVLB 0x5
10844  6FEC     MOVWF DMAnDPTR, BANKED
10846  6BED     CLRF DMAnDPTRH, BANKED
10848  90D8     BCF 0xFD8, 0, ACCESS
1084A  37EC     RLCF DMAnDPTR, F, BANKED
1084C  37ED     RLCF DMAnDPTRH, F, BANKED
1084E  0EFE     MOVLW 0xFE
10850  25EC     ADDWF DMAnDPTR, W, BANKED
10852  6FEE     MOVWF DMAnDSZ, BANKED
10854  0EFF     MOVLW 0xFF
10856  21ED     ADDWFC DMAnDPTRH, W, BANKED
10858  6FEF     MOVWF DMAnDSZH, BANKED
1085A  0E23     MOVLW 0x23
1085C  25EE     ADDWF DMAnDSZ, W, BANKED
1085E  6EF6     MOVWF 0xFF6, ACCESS
10860  0EFF     MOVLW 0xFF
10862  21EF     ADDWFC DMAnDSZH, W, BANKED
10864  6EF7     MOVWF 0xFF7, ACCESS
10866  6AF8     CLRF 0xFF8, ACCESS
10868  0E00     MOVLW 0x0
1086A  22F8     ADDWFC 0xFF8, F, ACCESS
1086C  0009     TBLRD*+
1086E  C4F5     MOVFF TABLAT, 0x5F0
10870  F5F0     NOP
10872  0009     TBLRD*+
10874  C4F5     MOVFF TABLAT, 0x5F1
10876  F5F1     NOP
10878  0E0E     MOVLW 0xE
1087A  27F0     ADDWF DMAnDSA, F, BANKED
1087C  0E00     MOVLW 0x0
1087E  23F1     ADDWFC DMAnDSAH, F, BANKED
10880  C5F0     MOVFF 0x5F0, TBLPTR
10882  F4F6     NOP
10884  C5F1     MOVFF 0x5F1, TBLPTRH
10886  F4F7     NOP
10888  0E00     MOVLW 0x0
1088A  6EF8     MOVWF 0xFF8, ACCESS
1088C  D801     RCALL 0x890
1088E  D00E     BRA 0x8AC
10890  0005     PUSH
10892  6EFA     MOVWF 0xFFA, ACCESS
10894  0009     TBLRD*+
10896  50F5     MOVF 0xFF5, W, ACCESS
10898  6EFD     MOVWF 0xFFD, ACCESS
1089A  0009     TBLRD*+
1089C  50F5     MOVF 0xFF5, W, ACCESS
1089E  6EFE     MOVWF 0xFFE, ACCESS
108A0  0009     TBLRD*+
108A2  50F5     MOVF 0xFF5, W, ACCESS
108A4  6EFF     MOVWF 0xFFF, ACCESS
108A6  50FA     MOVF 0xFFA, W, ACCESS
108A8  0E02     MOVLW 0x2
108AA  0012     RETURN 0
108AC  6E2A     MOVWF 0x2A, ACCESS
108AE  EE20     LFSR 2, 0x4
108B0  F004     NOP
108B2  5046     MOVF NVMDAT, W, ACCESS
108B4  26D9     ADDWF 0xFD9, F, ACCESS
108B6  5047     MOVF NVMDATH, W, ACCESS
108B8  22DA     ADDWFC 0xFDA, F, ACCESS
108BA  50DF     MOVF 0xFDF, W, ACCESS
108BC  0105     MOVLB 0x5
108BE  6FF2     MOVWF DMAnSCNT, BANKED
108C0  6BF3     CLRF DMAnSCNTH, BANKED
108C2  90D8     BCF 0xFD8, 0, ACCESS
108C4  37F2     RLCF DMAnSCNT, F, BANKED
108C6  37F3     RLCF DMAnSCNTH, F, BANKED
108C8  0EFE     MOVLW 0xFE
108CA  25F2     ADDWF DMAnSCNT, W, BANKED
108CC  6FF4     MOVWF DMAnSPTR, BANKED
108CE  0EFF     MOVLW 0xFF
108D0  21F3     ADDWFC DMAnSCNTH, W, BANKED
108D2  6FF5     MOVWF DMAnSPTRH, BANKED
108D4  0E23     MOVLW 0x23
108D6  25F4     ADDWF DMAnSPTR, W, BANKED
108D8  6EF6     MOVWF 0xFF6, ACCESS
108DA  0EFF     MOVLW 0xFF
108DC  21F5     ADDWFC DMAnSPTRH, W, BANKED
108DE  6EF7     MOVWF 0xFF7, ACCESS
108E0  6AF8     CLRF 0xFF8, ACCESS
108E2  0E00     MOVLW 0x0
108E4  22F8     ADDWFC 0xFF8, F, ACCESS
108E6  0009     TBLRD*+
108E8  C4F5     MOVFF TABLAT, 0x5F6
108EA  F5F6     NOP
108EC  0009     TBLRD*+
108EE  C4F5     MOVFF TABLAT, 0x5F7
108F0  F5F7     NOP
108F2  0E0E     MOVLW 0xE
108F4  27F6     ADDWF DMAnSPTRU, F, BANKED
108F6  0E00     MOVLW 0x0
108F8  23F7     ADDWFC DMAnSSZ, F, BANKED
108FA  C5F6     MOVFF 0x5F6, TBLPTR
108FC  F4F6     NOP
108FE  C5F7     MOVFF 0x5F7, TBLPTRH
10900  F4F7     NOP
10902  0E00     MOVLW 0x0
10904  6EF8     MOVWF 0xFF8, ACCESS
10906  D801     RCALL 0x90A
10908  D00E     BRA 0x926
1090A  0005     PUSH
1090C  6EFA     MOVWF 0xFFA, ACCESS
1090E  0009     TBLRD*+
10910  50F5     MOVF 0xFF5, W, ACCESS
10912  6EFD     MOVWF 0xFFD, ACCESS
10914  0009     TBLRD*+
10916  50F5     MOVF 0xFF5, W, ACCESS
10918  6EFE     MOVWF 0xFFE, ACCESS
1091A  0009     TBLRD*+
1091C  50F5     MOVF 0xFF5, W, ACCESS
1091E  6EFF     MOVWF 0xFFF, ACCESS
10920  50FA     MOVF 0xFFA, W, ACCESS
10922  0E03     MOVLW 0x3
10924  0012     RETURN 0
10926  6E2B     MOVWF 0x2B, ACCESS
10928  0EE7     MOVLW 0xE7
1092A  EC68     CALL 0x15ED0, 0
1092C  F0AF     NOP
1092E  EF4F     GOTO 0x1009E
10930  F080     NOP
526:                                       services[m->bytes[2]-1]->getESDdata(1),
527:                                       services[m->bytes[2]-1]->getESDdata(2),
528:                                       services[m->bytes[2]-1]->getESDdata(3));
529:                           }
530:                       }
531:                       return PROCESSED;
532:           #endif
533:           #ifdef VLCB_MODE
534:                   case OPC_MODE:  // set operating mode
535:                       if (m->len < 4) {
10932  C546     MOVFF m, FSR2
10934  F4D9     NOP
10936  C547     MOVFF 0x547, FSR2H
10938  F4DA     NOP
1093A  0E04     MOVLW 0x4
1093C  60DF     CPFSLT 0xFDF, ACCESS
1093E  D00F     BRA 0x95E
536:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, CMDERR_INV_CMD);
10940  C554     MOVFF 0x554, data1
10942  F525     NOP
10944  C553     MOVFF nn, data2
10946  F526     NOP
10948  0E76     MOVLW 0x76
1094A  6E27     MOVWF 0x27, ACCESS
1094C  0E01     MOVLW 0x1
1094E  6E28     MOVWF 0x28, ACCESS
10950  0E01     MOVLW 0x1
10952  6E29     MOVWF 0x29, ACCESS
10954  0EAF     MOVLW 0xAF
10956  EC7D     CALL 0x15EFA, 0
10958  F0AF     NOP
1095A  EF4F     GOTO 0x1009E
1095C  F080     NOP
537:                           return PROCESSED;
538:                       }
539:                       newMode = m->bytes[2];
1095E  EE20     LFSR 2, 0x4
10960  F004     NOP
10962  5046     MOVF NVMDAT, W, ACCESS
10964  26D9     ADDWF 0xFD9, F, ACCESS
10966  5047     MOVF NVMDATH, W, ACCESS
10968  22DA     ADDWFC 0xFDA, F, ACCESS
1096A  50DF     MOVF 0xFDF, W, ACCESS
1096C  6E4C     MOVWF ZCDCON, ACCESS
540:                       previousNN.word = nn.word;  // save the old NN
1096E  C553     MOVFF nn, previousNN
10970  F599     NOP
10972  C554     MOVFF 0x554, 0x59A
10974  F59A     NOP
541:                       // check current mode
542:                       if (mode_state == MODE_NORMAL) {
10976  05AB     DECF 0xAB, W, BANKED
10978  A4D8     BTFSS 0xFD8, 2, ACCESS
1097A  D048     BRA 0xA0C
543:                           if ((newMode == MODE_SETUP) || (newMode == MODE_UNINITIALISED)) {
1097C  504C     MOVF ZCDCON, W, ACCESS
1097E  B4D8     BTFSC 0xFD8, 2, ACCESS
10980  D003     BRA 0x988
10982  284C     INCF ZCDCON, W, ACCESS
10984  A4D8     BTFSS 0xFD8, 2, ACCESS
10986  D042     BRA 0xA0C
544:                               sendMessage2((newMode == MODE_SETUP) ? OPC_RQNN : OPC_NNREL, nn.bytes.hi, nn.bytes.lo);
10988  504C     MOVF ZCDCON, W, ACCESS
1098A  B4D8     BTFSC 0xFD8, 2, ACCESS
1098C  D002     BRA 0x992
1098E  0E51     MOVLW 0x51
10990  D001     BRA 0x994
10992  0E50     MOVLW 0x50
10994  6E49     MOVWF BORCON, ACCESS
10996  C554     MOVFF 0x554, data1
10998  F525     NOP
1099A  C553     MOVFF nn, data2
1099C  F526     NOP
1099E  5049     MOVF BORCON, W, ACCESS
109A0  EC53     CALL 0x15EA6, 0
109A2  F0AF     NOP
545:                               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, GRSP_OK);
109A4  C554     MOVFF 0x554, data1
109A6  F525     NOP
109A8  C553     MOVFF nn, data2
109AA  F526     NOP
109AC  0E76     MOVLW 0x76
109AE  6E27     MOVWF 0x27, ACCESS
109B0  0E01     MOVLW 0x1
109B2  6E28     MOVWF 0x28, ACCESS
109B4  0E00     MOVLW 0x0
109B6  6E29     MOVWF 0x29, ACCESS
109B8  0EAF     MOVLW 0xAF
109BA  EC7D     CALL 0x15EFA, 0
109BC  F0AF     NOP
546:                               nn.bytes.lo = nn.bytes.hi = 0;
109BE  0E00     MOVLW 0x0
109C0  6E54     MOVWF 0x54, ACCESS
109C2  C554     MOVFF 0x554, nn
109C4  F553     NOP
547:                               writeNVM(NN_NVM_TYPE, NN_ADDRESS+1, nn.bytes.hi);
109C6  0EFD     MOVLW 0xFD
109C8  6E10     MOVWF 0x10, ACCESS
109CA  0E03     MOVLW 0x3
109CC  6E11     MOVWF 0x11, ACCESS
109CE  0E00     MOVLW 0x0
109D0  6E12     MOVWF 0x12, ACCESS
109D2  C554     MOVFF 0x554, hi
109D4  F513     NOP
109D6  0E00     MOVLW 0x0
109D8  EC7E     CALL 0x156FC, 0
109DA  F0AB     NOP
548:                               writeNVM(NN_NVM_TYPE, NN_ADDRESS, nn.bytes.lo);
109DC  0EFC     MOVLW 0xFC
109DE  6E10     MOVWF 0x10, ACCESS
109E0  0E03     MOVLW 0x3
109E2  6E11     MOVWF 0x11, ACCESS
109E4  0E00     MOVLW 0x0
109E6  6E12     MOVWF 0x12, ACCESS
109E8  C553     MOVFF nn, hi
109EA  F513     NOP
109EC  0E00     MOVLW 0x0
109EE  EC7E     CALL 0x156FC, 0
109F0  F0AB     NOP
549:                               //return to setup
550:                               mode_state = (newMode == MODE_SETUP) ? MODE_SETUP : MODE_UNINITIALISED;
109F2  504C     MOVF ZCDCON, W, ACCESS
109F4  B4D8     BTFSC 0xFD8, 2, ACCESS
109F6  D003     BRA 0x9FE
109F8  0105     MOVLB 0x5
109FA  69AB     SETF 0xAB, BANKED
109FC  D003     BRA 0xA04
109FE  0E00     MOVLW 0x0
10A00  0105     MOVLB 0x5
10A02  6FAB     MOVWF 0xAB, BANKED
551:                               setupModePreviousMode = MODE_NORMAL;
10A04  0E01     MOVLW 0x1
10A06  6FA8     MOVWF 0xA8, BANKED
10A08  EF4D     GOTO 0x1009A
10A0A  F080     NOP
552:                               // Update the LEDs
553:                               setLEDsByMode();
554:                               return PROCESSED;
555:                           }
556:                       }
557:                       // Now do heartbeat change
558:                       if (newMode == MODE_HEARTBEAT_ON) {
10A0C  0E0C     MOVLW 0xC
10A0E  184C     XORWF ZCDCON, W, ACCESS
10A10  A4D8     BTFSS 0xFD8, 2, ACCESS
10A12  D010     BRA 0xA34
559:                           mode_flags |= FLAG_MODE_HEARTBEAT;
10A14  85B4     BSF PRLOCK, 2, BANKED
560:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, GRSP_OK);
10A16  C554     MOVFF 0x554, data1
10A18  F525     NOP
10A1A  C553     MOVFF nn, data2
10A1C  F526     NOP
10A1E  0E76     MOVLW 0x76
10A20  6E27     MOVWF 0x27, ACCESS
10A22  0E01     MOVLW 0x1
10A24  6E28     MOVWF 0x28, ACCESS
10A26  0E00     MOVLW 0x0
10A28  6E29     MOVWF 0x29, ACCESS
10A2A  0EAF     MOVLW 0xAF
10A2C  EC7D     CALL 0x15EFA, 0
10A2E  F0AF     NOP
10A30  EF4F     GOTO 0x1009E
10A32  F080     NOP
561:                           return PROCESSED;
562:                       } else if (newMode == MODE_HEARTBEAT_OFF) {
10A34  0E0D     MOVLW 0xD
10A36  184C     XORWF ZCDCON, W, ACCESS
10A38  A4D8     BTFSS 0xFD8, 2, ACCESS
10A3A  EFCF     GOTO 0x1019E
10A3C  F080     NOP
563:                           mode_flags &= ~FLAG_MODE_HEARTBEAT;
10A3E  95B4     BCF PRLOCK, 2, BANKED
564:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_MODE, SERVICE_ID_MNS, GRSP_OK);
10A40  C554     MOVFF 0x554, data1
10A42  F525     NOP
10A44  C553     MOVFF nn, data2
10A46  F526     NOP
10A48  0E76     MOVLW 0x76
10A4A  6E27     MOVWF 0x27, ACCESS
10A4C  0E01     MOVLW 0x1
10A4E  6E28     MOVWF 0x28, ACCESS
10A50  0E00     MOVLW 0x0
10A52  6E29     MOVWF 0x29, ACCESS
10A54  0EAF     MOVLW 0xAF
10A56  EC7D     CALL 0x15EFA, 0
10A58  F0AF     NOP
10A5A  EF4F     GOTO 0x1009E
10A5C  F080     NOP
565:                           return PROCESSED;
566:                       }
567:                       return NOT_PROCESSED;
568:           #endif
569:                   case OPC_NNRST: // reset CPU
570:                       RESET();
10A5E  00FF     RESET
10A60  EF4F     GOTO 0x1009E
10A62  F080     NOP
571:                       return PROCESSED;   // should never get here
572:                   default:
573:                       break;
574:               }
10A64  EE20     LFSR 2, 0x1
10A66  F001     NOP
10A68  5046     MOVF NVMDAT, W, ACCESS
10A6A  26D9     ADDWF 0xFD9, F, ACCESS
10A6C  5047     MOVF NVMDATH, W, ACCESS
10A6E  22DA     ADDWFC 0xFDA, F, ACCESS
10A70  50DF     MOVF 0xFDF, W, ACCESS
10A72  6FE0     MOVWF 0xE0, BANKED
10A74  6BE1     CLRF 0xE1, BANKED
10A76  51E1     MOVF 0xE1, W, BANKED
10A78  0A00     XORLW 0x0
10A7A  A4D8     BTFSS 0xFD8, 2, ACCESS
10A7C  EFCF     GOTO 0x1019E
10A7E  F080     NOP
10A80  51E0     MOVF 0xE0, W, BANKED
10A82  0A4F     XORLW 0x4F
10A84  B4D8     BTFSC 0xFD8, 2, ACCESS
10A86  D46F     BRA 0x366
10A88  0A11     XORLW 0x11
10A8A  B4D8     BTFSC 0xFD8, 2, ACCESS
10A8C  D7E8     BRA 0xA5E
10A8E  0A2D     XORLW 0x2D
10A90  B4D8     BTFSC 0xFD8, 2, ACCESS
10A92  D402     BRA 0x298
10A94  0A05     XORLW 0x5
10A96  B4D8     BTFSC 0xFD8, 2, ACCESS
10A98  D74C     BRA 0x932
10A9A  0A0E     XORLW 0xE
10A9C  B4D8     BTFSC 0xFD8, 2, ACCESS
10A9E  D597     BRA 0x5CE
10AA0  0AFF     XORLW 0xFF
10AA2  B4D8     BTFSC 0xFD8, 2, ACCESS
10AA2  B4D8     BTFSC 0xFD8, 2, ACCESS
10AA2  B4D8     BTFSC 0xFD8, 2, ACCESS
10AA2  B4D8     BTFSC 0xFD8, 2, ACCESS
575:               return NOT_PROCESSED;
576:           }
577:           
578:           /**
579:            * Get the current module status flags as reported by Parameter 8 and PNN.
580:            * @return the current module status flags
581:            */
582:           static uint8_t getParameterFlags() {
583:               uint8_t flags;
584:               flags = 0;
15982  0E00     MOVLW 0x0
15984  6E06     MOVWF 0x6, ACCESS
585:               if (have(SERVICE_ID_CONSUMER)) {
15986  0E06     MOVLW 0x6
15988  EC50     CALL 0x14CA0, 0
1598A  F0A6     NOP
1598C  0900     IORLW 0x0
1598E  A4D8     BTFSS 0xFD8, 2, ACCESS
586:                   flags |= PNN_FLAGS_CONSUMER;
15990  8006     BSF 0x6, 0, ACCESS
587:               }
588:               if (have(SERVICE_ID_PRODUCER)) {
15992  0E05     MOVLW 0x5
15994  EC50     CALL 0x14CA0, 0
15996  F0A6     NOP
15998  0900     IORLW 0x0
1599A  A4D8     BTFSS 0xFD8, 2, ACCESS
589:                   flags |= PNN_FLAGS_PRODUCER;
1599C  8206     BSF 0x6, 1, ACCESS
590:               }
591:               if (flags == (PNN_FLAGS_PRODUCER | PNN_FLAGS_CONSUMER)) flags |= PNN_FLAGS_COE;     // CoE
1599E  0E03     MOVLW 0x3
159A0  1806     XORWF 0x6, W, ACCESS
159A2  B4D8     BTFSC 0xFD8, 2, ACCESS
159A4  8806     BSF 0x6, 4, ACCESS
592:               if (have(SERVICE_ID_BOOT)) {
159A6  0E0A     MOVLW 0xA
159A8  EC50     CALL 0x14CA0, 0
159AA  F0A6     NOP
159AC  0900     IORLW 0x0
159AE  A4D8     BTFSS 0xFD8, 2, ACCESS
593:                   flags |= PNN_FLAGS_BOOT;
159B0  8606     BSF 0x6, 3, ACCESS
594:               }
595:               if (mode_flags & FLAG_MODE_LEARN) {
159B2  0105     MOVLB 0x5
159B4  B1B4     BTFSC PRLOCK, 0, BANKED
596:                   flags |= PNN_FLAGS_LEARN;
159B6  8A06     BSF 0x6, 5, ACCESS
597:               }
598:               if (mode_state == MODE_NORMAL) {
159B8  05AB     DECF 0xAB, W, BANKED
159BA  B4D8     BTFSC 0xFD8, 2, ACCESS
599:                   flags |= PNN_FLAGS_NORMAL;
159BC  8406     BSF 0x6, 2, ACCESS
600:               }
601:           #ifdef VLCB
602:               flags |= PNN_FLAGS_VLCB; // add VLCB compatability
159BE  8C06     BSF 0x6, 6, ACCESS
603:           #endif
604:               return flags;
159C0  5006     MOVF 0x6, W, ACCESS
605:           }
159C2  0012     RETURN 0
606:           
607:           #ifdef VLCB_DIAG
608:           /**
609:            * Update the module status with an error.
610:            * This is safe to be called from the CAN send function.
611:            */
612:           void updateModuleErrorStatus(void) {
613:               if (mnsDiagnostics[MNS_DIAGNOSTICS_STATUS].asBytes.lo < 0xFF) {
16246  0105     MOVLB 0x5
16248  29B9     INCF DMA4PR, W, BANKED
1624A  B4D8     BTFSC 0xFD8, 2, ACCESS
1624C  0012     RETURN 0
614:                   mnsDiagnostics[MNS_DIAGNOSTICS_STATUS].asBytes.lo++;
1624E  2BB9     INCF DMA4PR, F, BANKED
615:               }
616:           }
16250  0012     RETURN 0
617:           #endif
618:           
619:           /**
620:            * Called regularly, processing for LED flashing and mode state transition 
621:            * timeouts.
622:            */
623:           static void mnsPoll(void) {
624:           #ifdef VLCB_DIAG
625:               // Heartbeat message
626:               if (mode_state == MODE_NORMAL) {
11426  0105     MOVLB 0x5
11428  05AB     DECF 0xAB, W, BANKED
1142A  A4D8     BTFSS 0xFD8, 2, ACCESS
1142C  D038     BRA 0x149E
627:                   if (tickTimeSince(heartbeatTimer) > 5*ONE_SECOND) {
1142E  ECD8     CALL 0x153B0, 0
11430  F0A9     NOP
11432  0105     MOVLB 0x5
11434  5170     MOVF CM1CON0, W, BANKED
11436  5C02     SUBWF ___rparam_used, W, ACCESS
11438  6E2B     MOVWF 0x2B, ACCESS
1143A  5171     MOVF CM1CON1, W, BANKED
1143C  5803     SUBWFB __activetblptr, W, ACCESS
1143E  6E2C     MOVWF 0x2C, ACCESS
11440  5172     MOVF CM1NCH, W, BANKED
11442  5804     SUBWFB __activetblptr, W, ACCESS
11444  6E2D     MOVWF 0x2D, ACCESS
11446  5173     MOVF CM1PCH, W, BANKED
11448  5805     SUBWFB 0x5, W, ACCESS
1144A  6E2E     MOVWF 0x2E, ACCESS
1144C  502E     MOVF 0x2E, W, ACCESS
1144E  E108     BNZ 0x1460
11450  0EB5     MOVLW 0xB5
11452  5C2B     SUBWF 0x2B, W, ACCESS
11454  0EC4     MOVLW 0xC4
11456  582C     SUBWFB 0x2C, W, ACCESS
11458  0E04     MOVLW 0x4
1145A  582D     SUBWFB 0x2D, W, ACCESS
1145C  A0D8     BTFSS 0xFD8, 0, ACCESS
1145E  D01F     BRA 0x149E
628:                       if (mode_flags & FLAG_MODE_HEARTBEAT) {
11460  A5B4     BTFSS PRLOCK, 2, BANKED
11462  D00F     BRA 0x1482
629:                           sendMessage5(OPC_HEARTB, nn.bytes.hi,nn.bytes.lo,heartbeatSequence++,mnsDiagnostics[MNS_DIAGNOSTICS_STATUS].asBytes.lo,0);
11464  C554     MOVFF 0x554, data1
11466  F525     NOP
11468  C553     MOVFF nn, data2
1146A  F526     NOP
1146C  C5A7     MOVFF heartbeatSequence, data3
1146E  F527     NOP
11470  C5B9     MOVFF 0x5B9, data4
11472  F528     NOP
11474  0E00     MOVLW 0x0
11476  6E29     MOVWF 0x29, ACCESS
11478  0EAB     MOVLW 0xAB
1147A  EC7D     CALL 0x15EFA, 0
1147C  F0AF     NOP
1147E  0105     MOVLB 0x5
11480  2BA7     INCF 0xA7, F, BANKED
630:                       }
631:                       heartbeatTimer.val = tickGet();
11482  ECD8     CALL 0x153B0, 0
11484  F0A9     NOP
11486  C502     MOVFF i, heartbeatTimer
11488  F570     NOP
1148A  C503     MOVFF opc, 0x571
1148C  F571     NOP
1148E  C504     MOVFF s, 0x572
11490  F572     NOP
11492  C505     MOVFF i, 0x573
11494  F573     NOP
632:                       if (mnsDiagnostics[MNS_DIAGNOSTICS_STATUS].asBytes.lo > 0) {
11496  0105     MOVLB 0x5
11498  51B9     MOVF DMA4PR, W, BANKED
1149A  A4D8     BTFSS 0xFD8, 2, ACCESS
633:                           mnsDiagnostics[MNS_DIAGNOSTICS_STATUS].asBytes.lo--;
1149C  07B9     DECF DMA4PR, F, BANKED
634:                       }
635:                   }
636:               }
637:           #endif
638:               
639:               // Update mode if app or any service has changed them
640:               if (mode_flags != last_mode_flags) {
1149E  51A9     MOVF 0xA9, W, BANKED
114A0  19B4     XORWF PRLOCK, W, BANKED
114A2  B4D8     BTFSC 0xFD8, 2, ACCESS
114A4  D00D     BRA 0x14C0
641:                   writeNVM(MODE_FLAGS_NVM_TYPE, MODE_FLAGS_ADDRESS, mode_flags);
114A6  0EF9     MOVLW 0xF9
114A8  6E10     MOVWF 0x10, ACCESS
114AA  0E03     MOVLW 0x3
114AC  6E11     MOVWF 0x11, ACCESS
114AE  0E00     MOVLW 0x0
114B0  6E12     MOVWF 0x12, ACCESS
114B2  C5B4     MOVFF mode_flags, hi
114B4  F513     NOP
114B6  0E00     MOVLW 0x0
114B8  EC7E     CALL 0x156FC, 0
114BA  F0AB     NOP
642:                   last_mode_flags = mode_flags;
114BC  C5B4     MOVFF mode_flags, last_mode_flags
114BE  F5A9     NOP
643:               }
644:               if (mode_state != last_mode_state) {
114C0  0105     MOVLB 0x5
114C2  51AA     MOVF 0xAA, W, BANKED
114C4  19AB     XORWF 0xAB, W, BANKED
114C6  B4D8     BTFSC 0xFD8, 2, ACCESS
114C8  D013     BRA 0x14F0
645:                   // don't persist setup mode
646:                   if ((mode_state == MODE_UNINITIALISED) || (mode_state == MODE_NORMAL)) {
114CA  29AB     INCF 0xAB, W, BANKED
114CC  B4D8     BTFSC 0xFD8, 2, ACCESS
114CE  D003     BRA 0x14D6
114D0  05AB     DECF 0xAB, W, BANKED
114D2  A4D8     BTFSS 0xFD8, 2, ACCESS
114D4  D00B     BRA 0x14EC
647:                       writeNVM(MODE_FLAGS_NVM_TYPE, MODE_ADDRESS, mode_state);
114D6  0EFB     MOVLW 0xFB
114D8  6E10     MOVWF 0x10, ACCESS
114DA  0E03     MOVLW 0x3
114DC  6E11     MOVWF 0x11, ACCESS
114DE  0E00     MOVLW 0x0
114E0  6E12     MOVWF 0x12, ACCESS
114E2  C5AB     MOVFF mode_state, hi
114E4  F513     NOP
114E6  0E00     MOVLW 0x0
114E8  EC7E     CALL 0x156FC, 0
114EA  F0AB     NOP
648:                   }
649:                   last_mode_state = mode_state;
114EC  C5AB     MOVFF mode_state, last_mode_state
114EE  F5AA     NOP
650:               }
651:           #ifdef VLCB_DIAG
652:               // Module uptime
653:               if (tickTimeSince(uptimeTimer) > ONE_SECOND) {
114F0  ECD8     CALL 0x153B0, 0
114F2  F0A9     NOP
114F4  0105     MOVLB 0x5
114F6  516C     MOVF MD1SRC, W, BANKED
114F8  5C02     SUBWF ___rparam_used, W, ACCESS
114FA  6E2B     MOVWF 0x2B, ACCESS
114FC  516D     MOVF MD1CARL, W, BANKED
114FE  5803     SUBWFB __activetblptr, W, ACCESS
11500  6E2C     MOVWF 0x2C, ACCESS
11502  516E     MOVF MD1CARH, W, BANKED
11504  5804     SUBWFB __activetblptr, W, ACCESS
11506  6E2D     MOVWF 0x2D, ACCESS
11508  516F     MOVF CMOUT, W, BANKED
1150A  5805     SUBWFB 0x5, W, ACCESS
1150C  6E2E     MOVWF 0x2E, ACCESS
1150E  502E     MOVF 0x2E, W, ACCESS
11510  102D     IORWF 0x2D, W, ACCESS
11512  E106     BNZ 0x1520
11514  0E25     MOVLW 0x25
11516  5C2B     SUBWF 0x2B, W, ACCESS
11518  0EF4     MOVLW 0xF4
1151A  582C     SUBWFB 0x2C, W, ACCESS
1151C  A0D8     BTFSS 0xFD8, 0, ACCESS
1151E  D130     BRA 0x1780
654:                   uptimeTimer.val = tickGet();
11520  ECD8     CALL 0x153B0, 0
11522  F0A9     NOP
11524  C502     MOVFF i, uptimeTimer
11526  F56C     NOP
11528  C503     MOVFF opc, 0x56D
1152A  F56D     NOP
1152C  C504     MOVFF s, 0x56E
1152E  F56E     NOP
11530  C505     MOVFF i, 0x56F
11532  F56F     NOP
655:                   mnsDiagnostics[MNS_DIAGNOSTICS_UPTIMEL].asUint++;
11534  0105     MOVLB 0x5
11536  4BBD     INFSNZ DMA8PR, F, BANKED
11538  2BBE     INCF MAINPR, F, BANKED
656:                   if (mnsDiagnostics[MNS_DIAGNOSTICS_UPTIMEL].asUint == 0) {
1153A  51BD     MOVF DMA8PR, W, BANKED
1153C  11BE     IORWF MAINPR, W, BANKED
1153E  A4D8     BTFSS 0xFD8, 2, ACCESS
11540  D11F     BRA 0x1780
657:                       mnsDiagnostics[MNS_DIAGNOSTICS_UPTIMEH].asUint++;
11542  4BBB     INFSNZ DMA6PR, F, BANKED
11544  2BBC     INCF DMA7PR, F, BANKED
11546  D11C     BRA 0x1780
658:                   }
659:               }
660:           #endif
661:               
662:               // Do the mode changes by push button
663:               switch(mode_state) {
664:                   case MODE_UNINITIALISED:
665:                       // check the PB status
666:                       if (APP_pbPressed() == 0) {
11548  A6CE     BTFSS 0xFCE, 3, ACCESS
1154A  D00B     BRA 0x1562
667:                           // pb has been released
668:                           pbTimer.val = tickGet();
1154C  ECD8     CALL 0x153B0, 0
1154E  F0A9     NOP
11550  C502     MOVFF i, pbTimer
11552  F574     NOP
11554  C503     MOVFF opc, 0x575
11556  F575     NOP
11558  C504     MOVFF s, 0x576
1155A  F576     NOP
1155C  C505     MOVFF i, 0x577
1155E  F577     NOP
669:                       } else {
11560  0012     RETURN 0
670:                           // No need to release the PB
671:                           if (tickTimeSince(pbTimer) > 4*ONE_SECOND) {
11562  ECD8     CALL 0x153B0, 0
11564  F0A9     NOP
11566  0105     MOVLB 0x5
11568  5174     MOVF CM2CON0, W, BANKED
1156A  5C02     SUBWF ___rparam_used, W, ACCESS
1156C  6E2B     MOVWF 0x2B, ACCESS
1156E  5175     MOVF CM2CON1, W, BANKED
11570  5803     SUBWFB __activetblptr, W, ACCESS
11572  6E2C     MOVWF 0x2C, ACCESS
11574  5176     MOVF CM2NCH, W, BANKED
11576  5804     SUBWFB __activetblptr, W, ACCESS
11578  6E2D     MOVWF 0x2D, ACCESS
1157A  5177     MOVF CM2PCH, W, BANKED
1157C  5805     SUBWFB 0x5, W, ACCESS
1157E  6E2E     MOVWF 0x2E, ACCESS
11580  502E     MOVF 0x2E, W, ACCESS
11582  E108     BNZ 0x1594
11584  0E91     MOVLW 0x91
11586  5C2B     SUBWF 0x2B, W, ACCESS
11588  0ED0     MOVLW 0xD0
1158A  582C     SUBWFB 0x2C, W, ACCESS
1158C  0E03     MOVLW 0x3
1158E  582D     SUBWFB 0x2D, W, ACCESS
11590  A0D8     BTFSS 0xFD8, 0, ACCESS
11592  0012     RETURN 0
672:                               // Do state transition from Uninitialised to Setup
673:                               mode_state = MODE_PRESETUP;
11594  0EFD     MOVLW 0xFD
11596  6FAB     MOVWF 0xAB, BANKED
674:                               setupModePreviousMode = MODE_UNINITIALISED;
11598  69A8     SETF 0xA8, BANKED
675:                               setLEDsByMode();
1159A  EC5B     CALL 0x15CB6, 0
1159C  F0AE     NOP
1159E  0012     RETURN 0
676:                           }
677:                       }
678:                       break;
679:                   case MODE_PRESETUP:
680:                       if (APP_pbPressed() == 0) {
115A0  A6CE     BTFSS 0xFCE, 3, ACCESS
115A2  D7D4     BRA 0x154C
681:                           // pb has been released
682:                           
683:                           // Do state transition from Uninitialised to Setup
684:                           mode_state = MODE_SETUP;
115A4  0E00     MOVLW 0x0
115A6  6FAB     MOVWF 0xAB, BANKED
685:                           setupModePreviousMode = MODE_UNINITIALISED;
115A8  69A8     SETF 0xA8, BANKED
686:                           pbTimer.val = tickGet();    // reset the timer ready for Setup mode
115AA  ECD8     CALL 0x153B0, 0
115AC  F0A9     NOP
115AE  C502     MOVFF i, pbTimer
115B0  F574     NOP
115B2  C503     MOVFF opc, 0x575
115B4  F575     NOP
115B6  C504     MOVFF s, 0x576
115B8  F576     NOP
115BA  C505     MOVFF i, 0x577
115BC  F577     NOP
687:                           //start the request for NN
688:                           sendMessage2(OPC_RQNN, nn.bytes.hi, nn.bytes.lo);
115BE  C554     MOVFF 0x554, data1
115C0  F525     NOP
115C2  C553     MOVFF nn, data2
115C4  F526     NOP
115C6  0E50     MOVLW 0x50
115C8  EC53     CALL 0x15EA6, 0
115CA  F0AF     NOP
689:                           setLEDsByMode();
115CC  EC5B     CALL 0x15CB6, 0
115CE  F0AE     NOP
115D0  D7BD     BRA 0x154C
690:                       }
691:                       pbTimer.val = tickGet();
692:                       break;
693:                   case MODE_SETUP:
694:                       if (APP_pbPressed() == 0) {
115D2  A6CE     BTFSS 0xFCE, 3, ACCESS
115D4  0012     RETURN 0
695:                           // PB has been released
696:           
697:                           if ((tickTimeSince(pbTimer) > ONE_SECOND) && (tickTimeSince(pbTimer) < 2*ONE_SECOND)) {
115D6  ECD8     CALL 0x153B0, 0
115D8  F0A9     NOP
115DA  0105     MOVLB 0x5
115DC  5174     MOVF CM2CON0, W, BANKED
115DE  5C02     SUBWF ___rparam_used, W, ACCESS
115E0  6E2B     MOVWF 0x2B, ACCESS
115E2  5175     MOVF CM2CON1, W, BANKED
115E4  5803     SUBWFB __activetblptr, W, ACCESS
115E6  6E2C     MOVWF 0x2C, ACCESS
115E8  5176     MOVF CM2NCH, W, BANKED
115EA  5804     SUBWFB __activetblptr, W, ACCESS
115EC  6E2D     MOVWF 0x2D, ACCESS
115EE  5177     MOVF CM2PCH, W, BANKED
115F0  5805     SUBWFB 0x5, W, ACCESS
115F2  6E2E     MOVWF 0x2E, ACCESS
115F4  502E     MOVF 0x2E, W, ACCESS
115F6  102D     IORWF 0x2D, W, ACCESS
115F8  E106     BNZ 0x1606
115FA  0E25     MOVLW 0x25
115FC  5C2B     SUBWF 0x2B, W, ACCESS
115FE  0EF4     MOVLW 0xF4
11600  582C     SUBWFB 0x2C, W, ACCESS
11602  A0D8     BTFSS 0xFD8, 0, ACCESS
11604  D02E     BRA 0x1662
11606  ECD8     CALL 0x153B0, 0
11608  F0A9     NOP
1160A  0105     MOVLB 0x5
1160C  5174     MOVF CM2CON0, W, BANKED
1160E  5C02     SUBWF ___rparam_used, W, ACCESS
11610  6E2B     MOVWF 0x2B, ACCESS
11612  5175     MOVF CM2CON1, W, BANKED
11614  5803     SUBWFB __activetblptr, W, ACCESS
11616  6E2C     MOVWF 0x2C, ACCESS
11618  5176     MOVF CM2NCH, W, BANKED
1161A  5804     SUBWFB __activetblptr, W, ACCESS
1161C  6E2D     MOVWF 0x2D, ACCESS
1161E  5177     MOVF CM2PCH, W, BANKED
11620  5805     SUBWFB 0x5, W, ACCESS
11622  6E2E     MOVWF 0x2E, ACCESS
11624  502E     MOVF 0x2E, W, ACCESS
11626  E11D     BNZ 0x1662
11628  0E48     MOVLW 0x48
1162A  5C2B     SUBWF 0x2B, W, ACCESS
1162C  0EE8     MOVLW 0xE8
1162E  582C     SUBWFB 0x2C, W, ACCESS
11630  0E01     MOVLW 0x1
11632  582D     SUBWFB 0x2D, W, ACCESS
11634  B0D8     BTFSC 0xFD8, 0, ACCESS
11636  D015     BRA 0x1662
698:                               // a short press returns to previous mode
699:                               mode_state = setupModePreviousMode;
11638  C5A8     MOVFF setupModePreviousMode, mode_state
1163A  F5AB     NOP
700:                               if (mode_state == MODE_NORMAL) {
1163C  05AB     DECF 0xAB, W, BANKED
1163E  A4D8     BTFSS 0xFD8, 2, ACCESS
11640  D00E     BRA 0x165E
701:                                   // restore the NN
702:                                   nn.word = previousNN.word;
11642  C599     MOVFF previousNN, nn
11644  F553     NOP
11646  C59A     MOVFF 0x59A, 0x554
11648  F554     NOP
703:                                   sendMessage2(OPC_NNACK, nn.bytes.hi, nn.bytes.lo);
1164A  C554     MOVFF 0x554, data1
1164C  F525     NOP
1164E  C553     MOVFF nn, data2
11650  F526     NOP
11652  0E52     MOVLW 0x52
11654  EC53     CALL 0x15EA6, 0
11656  F0AF     NOP
704:           #ifdef VLCB_DIAG
705:                                   mnsDiagnostics[MNS_DIAGNOSTICS_NNCHANGE].asUint++;
11658  0105     MOVLB 0x5
1165A  4BC1     INFSNZ 0xC1, F, BANKED
1165C  2BC2     INCF 0xC2, F, BANKED
706:           #endif
707:                               }
708:                               setLEDsByMode();
1165E  EC5B     CALL 0x15CB6, 0
11660  F0AE     NOP
709:                           }
710:                           if (tickTimeSince(pbTimer) > 4*ONE_SECOND) {
11662  ECD8     CALL 0x153B0, 0
11664  F0A9     NOP
11666  0105     MOVLB 0x5
11668  5174     MOVF CM2CON0, W, BANKED
1166A  5C02     SUBWF ___rparam_used, W, ACCESS
1166C  6E2B     MOVWF 0x2B, ACCESS
1166E  5175     MOVF CM2CON1, W, BANKED
11670  5803     SUBWFB __activetblptr, W, ACCESS
11672  6E2C     MOVWF 0x2C, ACCESS
11674  5176     MOVF CM2NCH, W, BANKED
11676  5804     SUBWFB __activetblptr, W, ACCESS
11678  6E2D     MOVWF 0x2D, ACCESS
1167A  5177     MOVF CM2PCH, W, BANKED
1167C  5805     SUBWFB 0x5, W, ACCESS
1167E  6E2E     MOVWF 0x2E, ACCESS
11680  502E     MOVF 0x2E, W, ACCESS
11682  E108     BNZ 0x1694
11684  0E91     MOVLW 0x91
11686  5C2B     SUBWF 0x2B, W, ACCESS
11688  0ED0     MOVLW 0xD0
1168A  582C     SUBWFB 0x2C, W, ACCESS
1168C  0E03     MOVLW 0x3
1168E  582D     SUBWFB 0x2D, W, ACCESS
11690  A0D8     BTFSS 0xFD8, 0, ACCESS
11692  D75C     BRA 0x154C
711:                               mode_state = MODE_UNINITIALISED;
11694  69AB     SETF 0xAB, BANKED
11696  D79A     BRA 0x15CC
712:                               setLEDsByMode();
713:                           }
714:                           pbTimer.val = tickGet();
715:                       }
716:                       break;
717:                   default:    // Normal mode
718:                       // check the PB status
719:                       if (APP_pbPressed() == 0) {
11698  A6CE     BTFSS 0xFCE, 3, ACCESS
1169A  0012     RETURN 0
720:                           // PB has been released
721:                           if ((tickTimeSince(pbTimer) > 1*ONE_SECOND) && (tickTimeSince(pbTimer) < 2*ONE_SECOND)) {
1169C  ECD8     CALL 0x153B0, 0
1169E  F0A9     NOP
116A0  0105     MOVLB 0x5
116A2  5174     MOVF CM2CON0, W, BANKED
116A4  5C02     SUBWF ___rparam_used, W, ACCESS
116A6  6E2B     MOVWF 0x2B, ACCESS
116A8  5175     MOVF CM2CON1, W, BANKED
116AA  5803     SUBWFB __activetblptr, W, ACCESS
116AC  6E2C     MOVWF 0x2C, ACCESS
116AE  5176     MOVF CM2NCH, W, BANKED
116B0  5804     SUBWFB __activetblptr, W, ACCESS
116B2  6E2D     MOVWF 0x2D, ACCESS
116B4  5177     MOVF CM2PCH, W, BANKED
116B6  5805     SUBWFB 0x5, W, ACCESS
116B8  6E2E     MOVWF 0x2E, ACCESS
116BA  502E     MOVF 0x2E, W, ACCESS
116BC  102D     IORWF 0x2D, W, ACCESS
116BE  E106     BNZ 0x16CC
116C0  0E25     MOVLW 0x25
116C2  5C2B     SUBWF 0x2B, W, ACCESS
116C4  0EF4     MOVLW 0xF4
116C6  582C     SUBWFB 0x2C, W, ACCESS
116C8  A0D8     BTFSS 0xFD8, 0, ACCESS
116CA  D02E     BRA 0x1728
116CC  ECD8     CALL 0x153B0, 0
116CE  F0A9     NOP
116D0  0105     MOVLB 0x5
116D2  5174     MOVF CM2CON0, W, BANKED
116D4  5C02     SUBWF ___rparam_used, W, ACCESS
116D6  6E2B     MOVWF 0x2B, ACCESS
116D8  5175     MOVF CM2CON1, W, BANKED
116DA  5803     SUBWFB __activetblptr, W, ACCESS
116DC  6E2C     MOVWF 0x2C, ACCESS
116DE  5176     MOVF CM2NCH, W, BANKED
116E0  5804     SUBWFB __activetblptr, W, ACCESS
116E2  6E2D     MOVWF 0x2D, ACCESS
116E4  5177     MOVF CM2PCH, W, BANKED
116E6  5805     SUBWFB 0x5, W, ACCESS
116E8  6E2E     MOVWF 0x2E, ACCESS
116EA  502E     MOVF 0x2E, W, ACCESS
116EC  E11D     BNZ 0x1728
116EE  0E48     MOVLW 0x48
116F0  5C2B     SUBWF 0x2B, W, ACCESS
116F2  0EE8     MOVLW 0xE8
116F4  582C     SUBWFB 0x2C, W, ACCESS
116F6  0E01     MOVLW 0x1
116F8  582D     SUBWFB 0x2D, W, ACCESS
116FA  B0D8     BTFSC 0xFD8, 0, ACCESS
116FC  D015     BRA 0x1728
722:                               // Do State transition from Normal to Setup
723:                               previousNN.word = nn.word;  // save the old NN
116FE  C553     MOVFF nn, previousNN
11700  F599     NOP
11702  C554     MOVFF 0x554, 0x59A
11704  F59A     NOP
724:                               nn.bytes.lo = nn.bytes.hi = 0;
11706  0E00     MOVLW 0x0
11708  6E54     MOVWF 0x54, ACCESS
1170A  C554     MOVFF 0x554, nn
1170C  F553     NOP
725:                               //return to setup
726:                               mode_state = MODE_SETUP;
1170E  0E00     MOVLW 0x0
11710  6FAB     MOVWF 0xAB, BANKED
727:                               setupModePreviousMode = MODE_NORMAL;
11712  0E01     MOVLW 0x1
11714  6FA8     MOVWF 0xA8, BANKED
728:                               //start the request for NN
729:                               sendMessage2(OPC_RQNN, previousNN.bytes.hi, previousNN.bytes.lo);
11716  C59A     MOVFF 0x59A, data1
11718  F525     NOP
1171A  C599     MOVFF previousNN, data2
1171C  F526     NOP
1171E  0E50     MOVLW 0x50
11720  EC53     CALL 0x15EA6, 0
11722  F0AF     NOP
730:                               setLEDsByMode();
11724  EC5B     CALL 0x15CB6, 0
11726  F0AE     NOP
731:                           }
732:                           if (tickTimeSince(pbTimer) >= 4*ONE_SECOND) {
11728  ECD8     CALL 0x153B0, 0
1172A  F0A9     NOP
1172C  0105     MOVLB 0x5
1172E  5174     MOVF CM2CON0, W, BANKED
11730  5C02     SUBWF ___rparam_used, W, ACCESS
11732  6E2B     MOVWF 0x2B, ACCESS
11734  5175     MOVF CM2CON1, W, BANKED
11736  5803     SUBWFB __activetblptr, W, ACCESS
11738  6E2C     MOVWF 0x2C, ACCESS
1173A  5176     MOVF CM2NCH, W, BANKED
1173C  5804     SUBWFB __activetblptr, W, ACCESS
1173E  6E2D     MOVWF 0x2D, ACCESS
11740  5177     MOVF CM2PCH, W, BANKED
11742  5805     SUBWFB 0x5, W, ACCESS
11744  6E2E     MOVWF 0x2E, ACCESS
11746  502E     MOVF 0x2E, W, ACCESS
11748  E108     BNZ 0x175A
1174A  0E90     MOVLW 0x90
1174C  5C2B     SUBWF 0x2B, W, ACCESS
1174E  0ED0     MOVLW 0xD0
11750  582C     SUBWFB 0x2C, W, ACCESS
11752  0E03     MOVLW 0x3
11754  582D     SUBWFB 0x2D, W, ACCESS
11756  A0D8     BTFSS 0xFD8, 0, ACCESS
11758  D6F9     BRA 0x154C
733:                               // was down for more than 4 sec, Move to Uninitialised
734:                               previousNN.word = nn.word;  // save the old NN
1175A  C553     MOVFF nn, previousNN
1175C  F599     NOP
1175E  C554     MOVFF 0x554, 0x59A
11760  F59A     NOP
735:                               nn.bytes.lo = nn.bytes.hi = 0;
11762  0E00     MOVLW 0x0
11764  6E54     MOVWF 0x54, ACCESS
11766  C554     MOVFF 0x554, nn
11768  F553     NOP
736:                               //go to uninitialised
737:                               mode_state = MODE_UNINITIALISED;
1176A  69AB     SETF 0xAB, BANKED
738:                               setupModePreviousMode = MODE_NORMAL;
1176C  0E01     MOVLW 0x1
1176E  6FA8     MOVWF 0xA8, BANKED
739:                               //start the request for NN
740:                               sendMessage2(OPC_NNREL, previousNN.bytes.hi, previousNN.bytes.lo);
11770  C59A     MOVFF 0x59A, data1
11772  F525     NOP
11774  C599     MOVFF previousNN, data2
11776  F526     NOP
11778  0E51     MOVLW 0x51
1177A  EC53     CALL 0x15EA6, 0
1177C  F0AF     NOP
1177E  D726     BRA 0x15CC
741:                               setLEDsByMode();
742:                           }
743:                           pbTimer.val = tickGet();
744:                       }
745:               }
11780  51AB     MOVF 0xAB, W, BANKED
11782  0A00     XORLW 0x0
11784  B4D8     BTFSC 0xFD8, 2, ACCESS
11786  D725     BRA 0x15D2
11788  0AFD     XORLW 0xFD
1178A  B4D8     BTFSC 0xFD8, 2, ACCESS
1178C  D709     BRA 0x15A0
1178E  0A02     XORLW 0x2
11790  B4D8     BTFSC 0xFD8, 2, ACCESS
11790  B4D8     BTFSC 0xFD8, 2, ACCESS
11790  B4D8     BTFSC 0xFD8, 2, ACCESS
746:           }
747:           
748:           #if defined(_18F66K80_FAMILY_)
749:           /**
750:            * The MNS interrupt service routine. Handles the tickTime overflow to update
751:            * the extension bytes.
752:            */
753:           static void mnsLowIsr(void) {
754:               // Tick Timer interrupt
755:               //check to see if the symbol timer overflowed
756:               if(TMR_IF) {
757:                   /* there was a timer overflow */
758:                   TMR_IF = 0;
759:                   timerExtension1++;
760:                   if(timerExtension1 == 0) {
761:                       timerExtension2++;
762:                   }
763:               }
764:               return;
765:           }
766:           #endif
767:           
768:           #ifdef VLCB_DIAG
769:           /**
770:            * Get the MNS diagnostic values.
771:            * @param index the index indicating which diagnostic is required. 0..NUM_MNS_DIAGNOSTICS
772:            * @return the Diagnostic value or NULL if the value does not exist.
773:            */
774:           static DiagnosticVal * mnsGetDiagnostic(uint8_t index) {
1602E  6E0A     MOVWF 0xA, ACCESS
775:               if (index > NUM_MNS_DIAGNOSTICS) {
16030  0E06     MOVLW 0x6
16032  640A     CPFSGT 0xA, ACCESS
16034  D005     BRA 0x6040
776:                   return NULL;
16036  0E00     MOVLW 0x0
16038  6E08     MOVWF 0x8, ACCESS
1603A  0E00     MOVLW 0x0
1603C  6E09     MOVWF 0x9, ACCESS
1603E  0012     RETURN 0
777:               }
778:               return &(mnsDiagnostics[index]);
16040  500A     MOVF 0xA, W, ACCESS
16042  0D02     MULLW 0x2
16044  0EB7     MOVLW 0xB7
16046  24F3     ADDWF 0xFF3, W, ACCESS
16048  6E08     MOVWF 0x8, ACCESS
1604A  0E05     MOVLW 0x5
1604C  20F4     ADDWFC 0xFF4, W, ACCESS
1604E  6E09     MOVWF 0x9, ACCESS
779:           }
16050  0012     RETURN 0
780:           #endif
781:           
782:           /**
783:            * Set the LEDs according to the current mode.
784:            */
785:           void setLEDsByMode(void) {
786:                  switch (mode_state) {
15CB6  D00C     BRA 0x5CD0
787:                   case MODE_UNINITIALISED:
788:                       showStatus(STATUS_UNINITIALISED);
15CB8  0E01     MOVLW 0x1
15CBA  ECCD     CALL 0x1379A, 0
15CBC  F09B     NOP
789:                       break;
15CBE  0012     RETURN 0
790:                   case MODE_SETUP:
791:                   case MODE_PRESETUP:
792:                       showStatus(STATUS_SETUP);
15CC0  0E02     MOVLW 0x2
15CC2  ECCD     CALL 0x1379A, 0
15CC4  F09B     NOP
793:                       break;
15CC6  0012     RETURN 0
794:                   default:
795:                       showStatus(STATUS_NORMAL);
15CC8  0E03     MOVLW 0x3
15CCA  ECCD     CALL 0x1379A, 0
15CCC  F09B     NOP
796:                       break;
15CCE  0012     RETURN 0
797:               }
15CD0  0105     MOVLB 0x5
15CD2  51AB     MOVF 0xAB, W, BANKED
15CD4  0A00     XORLW 0x0
15CD6  B4D8     BTFSC 0xFD8, 2, ACCESS
15CD8  D7F3     BRA 0x5CC0
15CDA  0AFD     XORLW 0xFD
15CDC  B4D8     BTFSC 0xFD8, 2, ACCESS
15CDE  D7F0     BRA 0x5CC0
15CE0  0A02     XORLW 0x2
15CE2  B4D8     BTFSC 0xFD8, 2, ACCESS
15CE2  B4D8     BTFSC 0xFD8, 2, ACCESS
15CE2  B4D8     BTFSC 0xFD8, 2, ACCESS
798:           }
799:           
800:           /**
801:            * Return the parameter specified by idx. 
802:            * @param idx the parameter number
803:            * @return parameter value
804:            */
805:           static uint8_t getParameter(uint8_t idx) {
1347A  6E07     MOVWF 0x7, ACCESS
806:               uint8_t i;
807:               switch(idx) {
1347C  D045     BRA 0x3508
808:               case PAR_NUM:       // 0 Number of parameters
809:                   return 20;
1347E  0E14     MOVLW 0x14
13480  0012     RETURN 0
810:               case PAR_MANU:      // 1 Manufacturer id
811:                   return PARAM_MANU;
13482  0EA5     MOVLW 0xA5
13484  0012     RETURN 0
812:               case PAR_MINVER:	// 2 Minor version letter
813:                   return PARAM_MINOR_VERSION;
13486  0E63     MOVLW 0x63
13488  0012     RETURN 0
814:               case PAR_MTYP:	 	// 3 Module type code
815:                   return PARAM_MODULE_ID;
1348A  0E1D     MOVLW 0x1D
1348C  0012     RETURN 0
816:               case PAR_EVTNUM:	// 4 Number of events supported
817:                   return PARAM_NUM_EVENTS;
1348E  0EFE     MOVLW 0xFE
13490  0012     RETURN 0
818:               case PAR_EVNUM:		// 5 Event variables per event
819:                   return PARAM_NUM_EV_EVENT;
13492  0E0D     MOVLW 0xD
13494  0012     RETURN 0
820:               case PAR_NVNUM:		// 6 Number of Node variables
821:                   return PARAM_NUM_NV;
13496  0E01     MOVLW 0x1
13498  0012     RETURN 0
822:               case PAR_MAJVER:	// 7 Major version number
823:                   return PARAM_MAJOR_VERSION;
1349A  0E04     MOVLW 0x4
1349C  0012     RETURN 0
824:               case PAR_FLAGS:		// 8 Node flags
825:                   return getParameterFlags();
1349E  ECC1     CALL 0x15982, 0
134A0  F0AC     NOP
134A2  0012     RETURN 0
826:               case PAR_CPUID:		// 9 Processor type
827:                   return CPU;
134A4  0E17     MOVLW 0x17
134A6  0012     RETURN 0
828:               case PAR_BUSTYPE:	// 10 Bus type
829:                   if (have(SERVICE_ID_CAN)) {
134A8  0E03     MOVLW 0x3
134AA  EC50     CALL 0x14CA0, 0
134AC  F0A6     NOP
134AE  0900     IORLW 0x0
134B0  A4D8     BTFSS 0xFD8, 2, ACCESS
134B2  D7F1     BRA 0x3496
830:                       return PB_CAN;
831:                   }
832:                   return 0;
134B4  0E00     MOVLW 0x0
134B6  0012     RETURN 0
833:               case PAR_LOAD1:		// 11 load address, 4 bytes
834:                   return 0x00;
835:               case PAR_LOAD2:		// 12 load address, 4 bytes
836:                   return 0x08;
134B8  0E08     MOVLW 0x8
134BA  0012     RETURN 0
837:               case PAR_LOAD3:		// 13 load address, 4 bytes
838:                   return 0x00;
839:               case PAR_LOAD4:		// 14 load address, 4 bytes
840:                   return 0x00;
841:           #if defined(_18FXXQ83_FAMILY_)
842:               case PAR_CPUMID:	// 15 CPU manufacturer's id as read from the chip config space, 4 bytes (note - read from cpu at runtime, so not included in checksum)
843:                   return *(const uint8_t*)0x3FFFFC; // Device revision byte 0
134BC  0EFC     MOVLW 0xFC
134BE  6EF6     MOVWF 0xFF6, ACCESS
134C0  0EFF     MOVLW 0xFF
134C2  6EF7     MOVWF 0xFF7, ACCESS
134C4  0E3F     MOVLW 0x3F
134C6  6EF8     MOVWF 0xFF8, ACCESS
134C8  0008     TBLRD*
134CA  50F5     MOVF 0xFF5, W, ACCESS
134CC  0012     RETURN 0
844:               case PAR_CPUMID+1:  // 16
845:                   return *(const uint8_t*)0x3FFFFD; // Device recision byte 1
134CE  0EFD     MOVLW 0xFD
134D0  6EF6     MOVWF 0xFF6, ACCESS
134D2  0EFF     MOVLW 0xFF
134D4  6EF7     MOVWF 0xFF7, ACCESS
134D6  0E3F     MOVLW 0x3F
134D8  6EF8     MOVWF 0xFF8, ACCESS
134DA  0008     TBLRD*
134DC  50F5     MOVF 0xFF5, W, ACCESS
134DE  0012     RETURN 0
846:           #endif
847:               case PAR_CPUMID+2:  // 17
848:                   return *(const uint8_t*)0x3FFFFE;  // Device ID byte 0
134E0  0EFE     MOVLW 0xFE
134E2  6EF6     MOVWF 0xFF6, ACCESS
134E4  0EFF     MOVLW 0xFF
134E6  6EF7     MOVWF 0xFF7, ACCESS
134E8  0E3F     MOVLW 0x3F
134EA  6EF8     MOVWF 0xFF8, ACCESS
134EC  0008     TBLRD*
134EE  50F5     MOVF 0xFF5, W, ACCESS
134F0  0012     RETURN 0
849:               case PAR_CPUMID+3:  // 18
850:                   return *(const uint8_t*)0x3FFFFF;  // Device ID byte 1
134F2  0EFF     MOVLW 0xFF
134F4  6EF6     MOVWF 0xFF6, ACCESS
134F6  0EFF     MOVLW 0xFF
134F8  6EF7     MOVWF 0xFF7, ACCESS
134FA  0E3F     MOVLW 0x3F
134FC  6EF8     MOVWF 0xFF8, ACCESS
134FE  0008     TBLRD*
13500  50F5     MOVF 0xFF5, W, ACCESS
13502  0012     RETURN 0
851:               case PAR_CPUMAN:	// 19 CPU manufacturer code
852:                   return CPUM_MICROCHIP;
853:               case PAR_BETA:		// 20 Beta revision (numeric), or 0 if release
854:                   return PARAM_BUILD_VERSION;
13504  0E6B     MOVLW 0x6B
13506  0012     RETURN 0
855:               default:
856:                   return 0;
857:               }
13508  5007     MOVF 0x7, W, ACCESS
1350A  0A00     XORLW 0x0
1350C  B4D8     BTFSC 0xFD8, 2, ACCESS
1350E  D7B7     BRA 0x347E
13510  0A01     XORLW 0x1
13512  B4D8     BTFSC 0xFD8, 2, ACCESS
13514  D7B6     BRA 0x3482
13516  0A03     XORLW 0x3
13518  B4D8     BTFSC 0xFD8, 2, ACCESS
1351A  D7B5     BRA 0x3486
1351C  0A01     XORLW 0x1
1351E  B4D8     BTFSC 0xFD8, 2, ACCESS
13520  D7B4     BRA 0x348A
13522  0A07     XORLW 0x7
13524  B4D8     BTFSC 0xFD8, 2, ACCESS
13526  D7B3     BRA 0x348E
13528  0A01     XORLW 0x1
1352A  B4D8     BTFSC 0xFD8, 2, ACCESS
1352C  D7B2     BRA 0x3492
1352E  0A03     XORLW 0x3
13530  B4D8     BTFSC 0xFD8, 2, ACCESS
13532  D7B1     BRA 0x3496
13534  0A01     XORLW 0x1
13536  B4D8     BTFSC 0xFD8, 2, ACCESS
13538  D7B0     BRA 0x349A
1353A  0A0F     XORLW 0xF
1353C  B4D8     BTFSC 0xFD8, 2, ACCESS
1353E  D7AF     BRA 0x349E
13540  0A01     XORLW 0x1
13542  B4D8     BTFSC 0xFD8, 2, ACCESS
13544  D7AF     BRA 0x34A4
13546  0A03     XORLW 0x3
13548  B4D8     BTFSC 0xFD8, 2, ACCESS
1354A  D7AE     BRA 0x34A8
1354C  0A01     XORLW 0x1
1354E  B4D8     BTFSC 0xFD8, 2, ACCESS
13550  D7B1     BRA 0x34B4
13552  0A07     XORLW 0x7
13554  B4D8     BTFSC 0xFD8, 2, ACCESS
13556  D7B0     BRA 0x34B8
13558  0A01     XORLW 0x1
1355A  B4D8     BTFSC 0xFD8, 2, ACCESS
1355C  D7AB     BRA 0x34B4
1355E  0A03     XORLW 0x3
13560  B4D8     BTFSC 0xFD8, 2, ACCESS
13562  D7A8     BRA 0x34B4
13564  0A01     XORLW 0x1
13566  B4D8     BTFSC 0xFD8, 2, ACCESS
13568  D7A9     BRA 0x34BC
1356A  0A1F     XORLW 0x1F
1356C  B4D8     BTFSC 0xFD8, 2, ACCESS
1356E  D7AF     BRA 0x34CE
13570  0A01     XORLW 0x1
13572  B4D8     BTFSC 0xFD8, 2, ACCESS
13574  D7B5     BRA 0x34E0
13576  0A03     XORLW 0x3
13578  B4D8     BTFSC 0xFD8, 2, ACCESS
1357A  D7BB     BRA 0x34F2
1357C  0A01     XORLW 0x1
1357E  B4D8     BTFSC 0xFD8, 2, ACCESS
13580  D78A     BRA 0x3496
13582  0A07     XORLW 0x7
13584  B4D8     BTFSC 0xFD8, 2, ACCESS
13584  B4D8     BTFSC 0xFD8, 2, ACCESS
13584  B4D8     BTFSC 0xFD8, 2, ACCESS
858:           }
859:           
860:           #ifdef VLCB_SERVICE
861:           /**
862:            * This is the callback used by the service discovery responses.
863:            * @param type always set to TIMED_RESPONSE_RQSD
864:            * @param serviceIndex indicates the service requesting the responses
865:            * @param step loops through each service to be discovered
866:            * @return whether all of the responses have been sent yet.
867:            */
868:           TimedResponseResult mnsTRserviceDiscoveryCallback(uint8_t type, uint8_t serviceIndex, uint8_t step) {
869:               if (step >= NUM_SERVICES) {
14442  0E08     MOVLW 0x8
14444  6433     CPFSGT 0x33, ACCESS
14446  D002     BRA 0x444C
870:                   return TIMED_RESPONSE_RESULT_FINISHED;
14448  0E00     MOVLW 0x0
1444A  0012     RETURN 0
871:               }
872:           //    if (services[step] != NULL) {
873:                   sendMessage5(OPC_SD, nn.bytes.hi, nn.bytes.lo, step+1, services[step]->serviceNo, services[step]->version);
1444C  C554     MOVFF 0x554, data1
1444E  F525     NOP
14450  C553     MOVFF nn, data2
14452  F526     NOP
14454  2833     INCF 0x33, W, ACCESS
14456  6E27     MOVWF 0x27, ACCESS
14458  5033     MOVF 0x33, W, ACCESS
1445A  0D02     MULLW 0x2
1445C  0E23     MOVLW 0x23
1445E  24F3     ADDWF 0xFF3, W, ACCESS
14460  6EF6     MOVWF 0xFF6, ACCESS
14462  0EFF     MOVLW 0xFF
14464  20F4     ADDWFC 0xFF4, W, ACCESS
14466  6EF7     MOVWF 0xFF7, ACCESS
14468  6AF8     CLRF 0xFF8, ACCESS
1446A  0E00     MOVLW 0x0
1446C  22F8     ADDWFC 0xFF8, F, ACCESS
1446E  0009     TBLRD*+
14470  C4F5     MOVFF TABLAT, nodeNumber
14472  F534     NOP
14474  0009     TBLRD*+
14476  C4F5     MOVFF TABLAT, error
14478  F535     NOP
1447A  C534     MOVFF nodeNumber, TBLPTR
1447C  F4F6     NOP
1447E  C535     MOVFF error, TBLPTRH
14480  F4F7     NOP
14482  0E00     MOVLW 0x0
14484  6EF8     MOVWF 0xFF8, ACCESS
14486  0008     TBLRD*
14488  C4F5     MOVFF TABLAT, data4
1448A  F528     NOP
1448C  5033     MOVF 0x33, W, ACCESS
1448E  0D02     MULLW 0x2
14490  0E23     MOVLW 0x23
14492  24F3     ADDWF 0xFF3, W, ACCESS
14494  6EF6     MOVWF 0xFF6, ACCESS
14496  0EFF     MOVLW 0xFF
14498  20F4     ADDWFC 0xFF4, W, ACCESS
1449A  6EF7     MOVWF 0xFF7, ACCESS
1449C  6AF8     CLRF 0xFF8, ACCESS
1449E  0E00     MOVLW 0x0
144A0  22F8     ADDWFC 0xFF8, F, ACCESS
144A2  0009     TBLRD*+
144A4  C4F5     MOVFF TABLAT, eventNumber
144A6  F536     NOP
144A8  0009     TBLRD*+
144AA  C4F5     MOVFF TABLAT, tableIndex
144AC  F537     NOP
144AE  0E01     MOVLW 0x1
144B0  2636     ADDWF 0x36, F, ACCESS
144B2  0E00     MOVLW 0x0
144B4  2237     ADDWFC 0x37, F, ACCESS
144B6  C536     MOVFF eventNumber, TBLPTR
144B8  F4F6     NOP
144BA  C537     MOVFF tableIndex, TBLPTRH
144BC  F4F7     NOP
144BE  0E00     MOVLW 0x0
144C0  6EF8     MOVWF 0xFF8, ACCESS
144C2  0008     TBLRD*
144C4  C4F5     MOVFF TABLAT, data5
144C6  F529     NOP
144C8  0EAC     MOVLW 0xAC
144CA  EC7D     CALL 0x15EFA, 0
144CC  F0AF     NOP
874:           //    }
875:               return TIMED_RESPONSE_RESULT_NEXT;
144CE  0E02     MOVLW 0x2
876:           }
144D0  0012     RETURN 0
877:           #endif
878:           
879:           #ifdef VLCB_DIAG
880:           /**
881:            * This is the callback used by the diagnostic responses. 
882:            * @param type always set to TIMED_RESPONSE_RDNG
883:            * @param serviceIndex indicates the service requesting the responses
884:            * @param step loops through each of the diagnostics
885:            * @return whether all of the responses have been sent yet.
886:            */
887:           TimedResponseResult mnsTRallDiagnosticsCallback(uint8_t type, uint8_t serviceIndex, uint8_t step) {
888:               if (services[serviceIndex]->getDiagnostic == NULL) {
13696  5032     MOVF 0x32, W, ACCESS
13698  0D02     MULLW 0x2
1369A  0E23     MOVLW 0x23
1369C  24F3     ADDWF 0xFF3, W, ACCESS
1369E  6EF6     MOVWF 0xFF6, ACCESS
136A0  0EFF     MOVLW 0xFF
136A2  20F4     ADDWFC 0xFF4, W, ACCESS
136A4  6EF7     MOVWF 0xFF7, ACCESS
136A6  6AF8     CLRF 0xFF8, ACCESS
136A8  0E00     MOVLW 0x0
136AA  22F8     ADDWFC 0xFF8, F, ACCESS
136AC  0009     TBLRD*+
136AE  C4F5     MOVFF TABLAT, nodeNumber
136B0  F534     NOP
136B2  0009     TBLRD*+
136B4  C4F5     MOVFF TABLAT, error
136B6  F535     NOP
136B8  0E11     MOVLW 0x11
136BA  2634     ADDWF 0x34, F, ACCESS
136BC  0E00     MOVLW 0x0
136BE  2235     ADDWFC 0x35, F, ACCESS
136C0  C534     MOVFF nodeNumber, TBLPTR
136C2  F4F6     NOP
136C4  C535     MOVFF error, TBLPTRH
136C6  F4F7     NOP
136C8  0E00     MOVLW 0x0
136CA  6EF8     MOVWF 0xFF8, ACCESS
136CC  0009     TBLRD*+
136CE  50F5     MOVF 0xFF5, W, ACCESS
136D0  0009     TBLRD*+
136D2  10F5     IORWF 0xFF5, W, ACCESS
136D4  0009     TBLRD*+
136D6  10F5     IORWF 0xFF5, W, ACCESS
136D8  A4D8     BTFSS 0xFD8, 2, ACCESS
136DA  D011     BRA 0x36FE
889:                   sendMessage6(OPC_DGN, nn.bytes.hi, nn.bytes.lo, serviceIndex+1, 0, 0, 0);
136DC  C554     MOVFF 0x554, data1
136DE  F525     NOP
136E0  C553     MOVFF nn, data2
136E2  F526     NOP
136E4  2832     INCF 0x32, W, ACCESS
136E6  6E27     MOVWF 0x27, ACCESS
136E8  0E00     MOVLW 0x0
136EA  6E28     MOVWF 0x28, ACCESS
136EC  0E00     MOVLW 0x0
136EE  6E29     MOVWF 0x29, ACCESS
136F0  0E00     MOVLW 0x0
136F2  6E2A     MOVWF 0x2A, ACCESS
136F4  0EC7     MOVLW 0xC7
136F6  EC29     CALL 0x15E52, 0
136F8  F0AF     NOP
890:                   return TIMED_RESPONSE_RESULT_FINISHED;
136FA  0E00     MOVLW 0x0
136FC  0012     RETURN 0
891:               }
892:               DiagnosticVal * d = services[serviceIndex]->getDiagnostic(step);   // get the actual diagnostic value
136FE  5032     MOVF 0x32, W, ACCESS
13700  0D02     MULLW 0x2
13702  0E23     MOVLW 0x23
13704  24F3     ADDWF 0xFF3, W, ACCESS
13706  6EF6     MOVWF 0xFF6, ACCESS
13708  0EFF     MOVLW 0xFF
1370A  20F4     ADDWFC 0xFF4, W, ACCESS
1370C  6EF7     MOVWF 0xFF7, ACCESS
1370E  6AF8     CLRF 0xFF8, ACCESS
13710  0E00     MOVLW 0x0
13712  22F8     ADDWFC 0xFF8, F, ACCESS
13714  0009     TBLRD*+
13716  C4F5     MOVFF TABLAT, nodeNumber
13718  F534     NOP
1371A  0009     TBLRD*+
1371C  C4F5     MOVFF TABLAT, error
1371E  F535     NOP
13720  0E11     MOVLW 0x11
13722  2634     ADDWF 0x34, F, ACCESS
13724  0E00     MOVLW 0x0
13726  2235     ADDWFC 0x35, F, ACCESS
13728  C534     MOVFF nodeNumber, TBLPTR
1372A  F4F6     NOP
1372C  C535     MOVFF error, TBLPTRH
1372E  F4F7     NOP
13730  0E00     MOVLW 0x0
13732  6EF8     MOVWF 0xFF8, ACCESS
13734  D801     RCALL 0x3738
13736  D00E     BRA 0x3754
13738  0005     PUSH
1373A  6EFA     MOVWF 0xFFA, ACCESS
1373C  0009     TBLRD*+
1373E  50F5     MOVF 0xFF5, W, ACCESS
13740  6EFD     MOVWF 0xFFD, ACCESS
13742  0009     TBLRD*+
13744  50F5     MOVF 0xFF5, W, ACCESS
13746  6EFE     MOVWF 0xFFE, ACCESS
13748  0009     TBLRD*+
1374A  50F5     MOVF 0xFF5, W, ACCESS
1374C  6EFF     MOVWF 0xFFF, ACCESS
1374E  50FA     MOVF 0xFFA, W, ACCESS
13750  5033     MOVF 0x33, W, ACCESS
13752  0012     RETURN 0
13754  C508     MOVFF index, eventNumber
13756  F536     NOP
13758  C509     MOVFF d, tableIndex
1375A  F537     NOP
893:               if (d == NULL) {
1375C  5036     MOVF 0x36, W, ACCESS
1375E  1037     IORWF 0x37, W, ACCESS
13760  B4D8     BTFSC 0xFD8, 2, ACCESS
13762  D7CB     BRA 0x36FA
894:                   // the requested diagnostic doesn't exist
895:                   return TIMED_RESPONSE_RESULT_FINISHED;
896:               }
897:               // return the diagnostic
898:               sendMessage6(OPC_DGN, nn.bytes.hi, nn.bytes.lo, serviceIndex+1, step, d->asBytes.hi, d->asBytes.lo);
13764  C554     MOVFF 0x554, data1
13766  F525     NOP
13768  C553     MOVFF nn, data2
1376A  F526     NOP
1376C  2832     INCF 0x32, W, ACCESS
1376E  6E27     MOVWF 0x27, ACCESS
13770  C533     MOVFF learn, data4
13772  F528     NOP
13774  EE20     LFSR 2, 0x1
13776  F001     NOP
13778  5036     MOVF 0x36, W, ACCESS
1377A  26D9     ADDWF 0xFD9, F, ACCESS
1377C  5037     MOVF 0x37, W, ACCESS
1377E  22DA     ADDWFC 0xFDA, F, ACCESS
13780  50DF     MOVF 0xFDF, W, ACCESS
13782  6E29     MOVWF 0x29, ACCESS
13784  C536     MOVFF eventNumber, FSR2
13786  F4D9     NOP
13788  C537     MOVFF tableIndex, FSR2H
1378A  F4DA     NOP
1378C  50DF     MOVF 0xFDF, W, ACCESS
1378E  6E2A     MOVWF 0x2A, ACCESS
13790  0EC7     MOVLW 0xC7
13792  EC29     CALL 0x15E52, 0
13794  F0AF     NOP
899:               return TIMED_RESPONSE_RESULT_NEXT;
13796  0E02     MOVLW 0x2
900:           }
13798  0012     RETURN 0
901:           #endif
902:           
903:           #ifdef VLCB_ZERO_RESPONSES
904:           /**
905:            * This is the callback used by the RQNPN Parameter responses. 
906:            * @param type always set to TIMED_RESPONSE_RQNPN
907:            * @param serviceIndex indicates the service requesting the responses
908:            * @param step loops through each of the parameters
909:            * @return whether all of the responses have been sent yet.
910:            */
911:           TimedResponseResult  mnsTRrqnpnCallback(uint8_t type, uint8_t serviceIndex, uint8_t step) {
912:               if (step >= 20) {
15F76  0E13     MOVLW 0x13
15F78  6433     CPFSGT 0x33, ACCESS
15F7A  D002     BRA 0x5F80
913:                   return TIMED_RESPONSE_RESULT_FINISHED;
15F7C  0E00     MOVLW 0x0
15F7E  0012     RETURN 0
914:               }
915:               sendMessage4(OPC_PARAN, nn.bytes.hi, nn.bytes.lo, step+1, getParameter(step+1));
15F80  C554     MOVFF 0x554, data1
15F82  F525     NOP
15F84  C553     MOVFF nn, data2
15F86  F526     NOP
15F88  2833     INCF 0x33, W, ACCESS
15F8A  6E27     MOVWF 0x27, ACCESS
15F8C  2833     INCF 0x33, W, ACCESS
15F8E  EC3D     CALL 0x1347A, 0
15F90  F09A     NOP
15F92  6E28     MOVWF 0x28, ACCESS
15F94  0E9B     MOVLW 0x9B
15F96  EC92     CALL 0x15F24, 0
15F98  F0AF     NOP
916:               return TIMED_RESPONSE_RESULT_NEXT;
15F9A  0E02     MOVLW 0x2
917:           }
15F9C  0012     RETURN 0
918:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/messageQueue.c  --------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:            */
36:            /**
37:             * @author Ian Hogg 
38:             * @date Dec 2022
39:             * 
40:             */
41:            
42:            /**
43:             * @file
44:             * @brief
45:             * Implementation of message queues used for receive and transmit buffers.
46:             */
47:            #include <xc.h>
48:            #include "vlcb.h"
49:            #include "messageQueue.h"
50:            
51:            #pragma warning disable 1498
52:            /**
53:             * Push a message onto the message queue.
54:             * @param q the queue
55:             * @param m the message
56:             * @return QUEUE_SUCCESS for success QUEUE_FAIL for buffer full
57:             */
58:            Qresult push(MessageQueue * q, Message * m) {
59:                if (((q->writeIndex+1)&((q->size)-1)) == q->readIndex) return QUEUE_FAIL;	// buffer full
60:                (q->messages[q->writeIndex]).opc = m->opc;
61:                (q->messages[q->writeIndex]).bytes[0] = m->bytes[0];
62:                (q->messages[q->writeIndex]).bytes[1] = m->bytes[1];
63:                (q->messages[q->writeIndex]).bytes[2] = m->bytes[2];
64:                (q->messages[q->writeIndex]).bytes[3] = m->bytes[3];
65:                (q->messages[q->writeIndex]).bytes[4] = m->bytes[4];
66:                (q->messages[q->writeIndex]).bytes[5] = m->bytes[5];
67:                (q->messages[q->writeIndex]).bytes[6] = m->bytes[6];
68:                (q->messages[q->writeIndex]).len = m->len;
69:                q->writeIndex++;
70:                
71:                if (q->writeIndex >= q->size) q->writeIndex = 0;
72:                return QUEUE_SUCCESS;
73:            }
74:            /**
75:             * A bit like a pop but doesn't copy the message and instead returns a pointer to
76:             * the buffer to which the message can be copied by the caller.
77:             * @param q the queue
78:             * @return a message pointer
79:             */
80:            Message * getNextWriteMessage(MessageQueue * q) {
81:                uint8_t wr;
82:                if (((q->writeIndex+1)&((q->size)-1)) == q->readIndex) return NULL;	// buffer full
1396E  EE20     LFSR 2, 0x2
13970  F002     NOP
13972  5002     MOVF ___rparam_used, W, ACCESS
13974  26D9     ADDWF 0xFD9, F, ACCESS
13976  5003     MOVF __activetblptr, W, ACCESS
13978  22DA     ADDWFC 0xFDA, F, ACCESS
1397A  50DF     MOVF 0xFDF, W, ACCESS
1397C  6E04     MOVWF __activetblptr, ACCESS
1397E  6A05     CLRF 0x5, ACCESS
13980  EE20     LFSR 2, 0x4
13982  F004     NOP
13984  5002     MOVF ___rparam_used, W, ACCESS
13986  26D9     ADDWF 0xFD9, F, ACCESS
13988  5003     MOVF __activetblptr, W, ACCESS
1398A  22DA     ADDWFC 0xFDA, F, ACCESS
1398C  50DF     MOVF 0xFDF, W, ACCESS
1398E  6E06     MOVWF 0x6, ACCESS
13990  0EFF     MOVLW 0xFF
13992  2406     ADDWF 0x6, W, ACCESS
13994  6E07     MOVWF 0x7, ACCESS
13996  6A08     CLRF 0x8, ACCESS
13998  0EFF     MOVLW 0xFF
1399A  2208     ADDWFC 0x8, F, ACCESS
1399C  EE20     LFSR 2, 0x3
1399E  F003     NOP
139A0  5002     MOVF ___rparam_used, W, ACCESS
139A2  26D9     ADDWF 0xFD9, F, ACCESS
139A4  5003     MOVF __activetblptr, W, ACCESS
139A6  22DA     ADDWFC 0xFDA, F, ACCESS
139A8  50DF     MOVF 0xFDF, W, ACCESS
139AA  6E09     MOVWF 0x9, ACCESS
139AC  6A0A     CLRF 0xA, ACCESS
139AE  0E01     MOVLW 0x1
139B0  2609     ADDWF 0x9, F, ACCESS
139B2  0E00     MOVLW 0x0
139B4  220A     ADDWFC 0xA, F, ACCESS
139B6  5007     MOVF 0x7, W, ACCESS
139B8  1409     ANDWF 0x9, W, ACCESS
139BA  6E0B     MOVWF 0xB, ACCESS
139BC  5008     MOVF 0x8, W, ACCESS
139BE  140A     ANDWF 0xA, W, ACCESS
139C0  6E0C     MOVWF 0xC, ACCESS
139C2  5004     MOVF __activetblptr, W, ACCESS
139C4  180B     XORWF 0xB, W, ACCESS
139C6  E109     BNZ 0x39DA
139C8  5005     MOVF 0x5, W, ACCESS
139CA  180C     XORWF 0xC, W, ACCESS
139CC  A4D8     BTFSS 0xFD8, 2, ACCESS
139CE  D005     BRA 0x39DA
139D0  0E00     MOVLW 0x0
139D2  6E02     MOVWF ___rparam_used, ACCESS
139D4  0E00     MOVLW 0x0
139D6  6E03     MOVWF __activetblptr, ACCESS
139D8  0012     RETURN 0
83:                wr = q->writeIndex;
139DA  EE20     LFSR 2, 0x3
139DC  F003     NOP
139DE  5002     MOVF ___rparam_used, W, ACCESS
139E0  26D9     ADDWF 0xFD9, F, ACCESS
139E2  5003     MOVF __activetblptr, W, ACCESS
139E4  22DA     ADDWFC 0xFDA, F, ACCESS
139E6  50DF     MOVF 0xFDF, W, ACCESS
139E8  6E0D     MOVWF 0xD, ACCESS
84:                q->writeIndex++;
139EA  EE20     LFSR 2, 0x3
139EC  F003     NOP
139EE  5002     MOVF ___rparam_used, W, ACCESS
139F0  26D9     ADDWF 0xFD9, F, ACCESS
139F2  5003     MOVF __activetblptr, W, ACCESS
139F4  22DA     ADDWFC 0xFDA, F, ACCESS
139F6  2ADF     INCF 0xFDF, F, ACCESS
85:                if (q->writeIndex >= q->size) q->writeIndex = 0;
139F8  EE20     LFSR 2, 0x4
139FA  F004     NOP
139FC  5002     MOVF ___rparam_used, W, ACCESS
139FE  26D9     ADDWF 0xFD9, F, ACCESS
13A00  5003     MOVF __activetblptr, W, ACCESS
13A02  22DA     ADDWFC 0xFDA, F, ACCESS
13A04  EE10     LFSR 1, 0x3
13A06  F003     NOP
13A08  5002     MOVF ___rparam_used, W, ACCESS
13A0A  26E1     ADDWF 0xFE1, F, ACCESS
13A0C  5003     MOVF __activetblptr, W, ACCESS
13A0E  22E2     ADDWFC 0xFE2, F, ACCESS
13A10  50DE     MOVF 0xFDE, W, ACCESS
13A12  5CE6     SUBWF 0xFE6, W, ACCESS
13A14  A0D8     BTFSS 0xFD8, 0, ACCESS
13A16  D007     BRA 0x3A26
13A18  EE20     LFSR 2, 0x3
13A1A  F003     NOP
13A1C  5002     MOVF ___rparam_used, W, ACCESS
13A1E  26D9     ADDWF 0xFD9, F, ACCESS
13A20  5003     MOVF __activetblptr, W, ACCESS
13A22  22DA     ADDWFC 0xFDA, F, ACCESS
13A24  6ADF     CLRF 0xFDF, ACCESS
86:                return &(q->messages[wr]);
13A26  500D     MOVF 0xD, W, ACCESS
13A28  0D09     MULLW 0x9
13A2A  C4F3     MOVFF PROD, s
13A2C  F504     NOP
13A2E  C4F4     MOVFF PRODH, i
13A30  F505     NOP
13A32  C502     MOVFF i, FSR2
13A34  F4D9     NOP
13A36  C503     MOVFF opc, FSR2H
13A38  F4DA     NOP
13A3A  C4DE     MOVFF POSTINC2, id
13A3C  F506     NOP
13A3E  C4DD     MOVFF POSTDEC2, i
13A40  F507     NOP
13A42  5004     MOVF __activetblptr, W, ACCESS
13A44  2406     ADDWF 0x6, W, ACCESS
13A46  6E02     MOVWF ___rparam_used, ACCESS
13A48  5005     MOVF 0x5, W, ACCESS
13A4A  2007     ADDWFC 0x7, W, ACCESS
13A4C  6E03     MOVWF __activetblptr, ACCESS
87:            }
13A4E  0012     RETURN 0
88:            
89:            
90:            /**
91:             * Pull and return the next message from the queue.
92:             *
93:             * @param q the queue
94:             * @return the next message
95:             */
96:            Message * pop(MessageQueue * q) {
97:                Message * ret;
98:            	if (q->writeIndex == q->readIndex) {
1413E  EE20     LFSR 2, 0x2
14140  F002     NOP
14142  5002     MOVF ___rparam_used, W, ACCESS
14144  26D9     ADDWF 0xFD9, F, ACCESS
14146  5003     MOVF __activetblptr, W, ACCESS
14148  22DA     ADDWFC 0xFDA, F, ACCESS
1414A  EE10     LFSR 1, 0x3
1414C  F003     NOP
1414E  5002     MOVF ___rparam_used, W, ACCESS
14150  26E1     ADDWF 0xFE1, F, ACCESS
14152  5003     MOVF __activetblptr, W, ACCESS
14154  22E2     ADDWFC 0xFE2, F, ACCESS
14156  50DE     MOVF 0xFDE, W, ACCESS
14158  18E6     XORWF 0xFE6, W, ACCESS
1415A  A4D8     BTFSS 0xFD8, 2, ACCESS
1415C  D005     BRA 0x4168
99:                    return NULL;	// buffer empty
1415E  0E00     MOVLW 0x0
14160  6E02     MOVWF ___rparam_used, ACCESS
14162  0E00     MOVLW 0x0
14164  6E03     MOVWF __activetblptr, ACCESS
14166  0012     RETURN 0
100:               }
101:           	ret = &(q->messages[q->readIndex++]);
14168  EE20     LFSR 2, 0x2
1416A  F002     NOP
1416C  5002     MOVF ___rparam_used, W, ACCESS
1416E  26D9     ADDWF 0xFD9, F, ACCESS
14170  5003     MOVF __activetblptr, W, ACCESS
14172  22DA     ADDWFC 0xFDA, F, ACCESS
14174  50DF     MOVF 0xFDF, W, ACCESS
14176  6E04     MOVWF __activetblptr, ACCESS
14178  5004     MOVF __activetblptr, W, ACCESS
1417A  0D09     MULLW 0x9
1417C  C4F3     MOVFF PROD, i
1417E  F505     NOP
14180  C4F4     MOVFF PRODH, id
14182  F506     NOP
14184  C502     MOVFF i, FSR2
14186  F4D9     NOP
14188  C503     MOVFF opc, FSR2H
1418A  F4DA     NOP
1418C  C4DE     MOVFF POSTINC2, i
1418E  F507     NOP
14190  C4DD     MOVFF POSTDEC2, index
14192  F508     NOP
14194  5005     MOVF 0x5, W, ACCESS
14196  2407     ADDWF 0x7, W, ACCESS
14198  6E09     MOVWF 0x9, ACCESS
1419A  5006     MOVF 0x6, W, ACCESS
1419C  2008     ADDWFC 0x8, W, ACCESS
1419E  6E0A     MOVWF 0xA, ACCESS
141A0  EE20     LFSR 2, 0x2
141A2  F002     NOP
141A4  5002     MOVF ___rparam_used, W, ACCESS
141A6  26D9     ADDWF 0xFD9, F, ACCESS
141A8  5003     MOVF __activetblptr, W, ACCESS
141AA  22DA     ADDWFC 0xFDA, F, ACCESS
141AC  2ADF     INCF 0xFDF, F, ACCESS
102:           	if (q->readIndex >= q->size) q->readIndex = 0;
141AE  EE20     LFSR 2, 0x4
141B0  F004     NOP
141B2  5002     MOVF ___rparam_used, W, ACCESS
141B4  26D9     ADDWF 0xFD9, F, ACCESS
141B6  5003     MOVF __activetblptr, W, ACCESS
141B8  22DA     ADDWFC 0xFDA, F, ACCESS
141BA  EE10     LFSR 1, 0x2
141BC  F002     NOP
141BE  5002     MOVF ___rparam_used, W, ACCESS
141C0  26E1     ADDWF 0xFE1, F, ACCESS
141C2  5003     MOVF __activetblptr, W, ACCESS
141C4  22E2     ADDWFC 0xFE2, F, ACCESS
141C6  50DE     MOVF 0xFDE, W, ACCESS
141C8  5CE6     SUBWF 0xFE6, W, ACCESS
141CA  A0D8     BTFSS 0xFD8, 0, ACCESS
141CC  D007     BRA 0x41DC
141CE  EE20     LFSR 2, 0x2
141D0  F002     NOP
141D2  5002     MOVF ___rparam_used, W, ACCESS
141D4  26D9     ADDWF 0xFD9, F, ACCESS
141D6  5003     MOVF __activetblptr, W, ACCESS
141D8  22DA     ADDWFC 0xFDA, F, ACCESS
141DA  6ADF     CLRF 0xFDF, ACCESS
103:           	return ret;
141DC  C509     MOVFF d, i
141DE  F502     NOP
141E0  C50A     MOVFF index, opc
141E2  F503     NOP
104:           }
141E4  0012     RETURN 0
105:           
106:           /**
107:            * Peek into the buffer.
108:            *
109:            * @param q the queue
110:            * @param index the position into the queue
111:            * @return the message
112:            */
113:           Message * peek(MessageQueue * q, uint8_t index) {
114:               if (q->readIndex == q->writeIndex) return NULL;    // empty
115:               index += q->readIndex;
116:           //    index -= 1;
117:               if (index >= q->size) {
118:                   index -= q->size;
119:               }
120:               if (index == q->writeIndex) return NULL; // at end
121:               return &(q->messages[index]);
122:           }
123:           
124:           
125:           /**
126:            * Return number of items in the queue.
127:            * @param q the queue
128:            * @return the number of items
129:            */
130:           uint8_t quantity(MessageQueue * q) {
131:               return (q->writeIndex - q->readIndex) & (q->size -1);
132:           }
133:           
---  C:/Users/ianwh/github/VLCBlib_PIC/event_teach_simple.c  --------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:             */
36:            
37:            /**
38:             * @author Ian Hogg 
39:             * @date May 2024
40:             * 
41:             */ 
42:            /*
43:             *  History for this file:
44:             *  30/05/24    Ian Hogg        - Created a simple events implementation
45:             * 
46:             * Currently written for:
47:             *  XC8 compiler
48:             * 
49:             * This file used the following PIC peripherals:
50:             * * none
51:             */
52:            #include <xc.h>
53:            #include "vlcb.h"
54:            #include "nvm.h"
55:            #include "mns.h"
56:            #include "timedResponse.h"
57:            #include "event_teach.h"
58:            
59:            /**
60:             * @file
61:             * @brief
62:             * Simple implementation of the VLCB Event Teach Service.
63:             * @details
64:             * Event teaching service
65:             * The service definition object is called eventTeachService.
66:             *
67:             * The events are stored as a hash table in NVM (flash is faster to read than EEPROM)
68:             * There can be up to 255 events. 
69:             *
70:             * This generic code needs no knowledge of specific EV usage.
71:             *
72:             * @warning
73:             * BEWARE must set NUM_EVENTS to a maximum of 255!
74:             * If set to 256 then the for (uint8_t i=0; i<NUM_EVENTS; i++) loops will never end
75:             * as they use an uint8_t instead of int for space/performance reasons.
76:             *
77:             * @warning
78:             * BEWARE Concurrency: The functions which use the eventtable and hash/lookup must not be used
79:             * whilst there is a chance of the functions which modify the eventtable of RAM based 
80:             * hash/lookup tables being called. These functions should therefore either be called
81:             * from the same thread or disable interrupts. 
82:             */
83:            
84:            /*
85:             * Events are stored in the EventTable which consists of rows containing the following 
86:             * fields:
87:             * * Event event                      4 bytes
88:             * * uint8_t flags
89:             * * uint8_t evs[PARAM_NUM_EV_EVENT]  PARAM_NUM_EV_EVENT bytes
90:             * 
91:             * The number of table entries is defined by NUM_EVENTS.
92:             * The 'event' field contains the NN/EN of the event.
93:             * 
94:             * Unused entries in the table have the event.EN set to zero.
95:             */
96:            
97:            // forward definitions
98:            static void teachFactoryReset(void);
99:            static void teachPowerUp(void);
100:           static Processed teachProcessMessage(Message * m);
101:           static uint8_t teachGetESDdata(uint8_t id);
102:           static void clearAllEvents(void);
103:           Processed checkLen(Message * m, uint8_t needed, uint8_t service);
104:           static Processed teachCheckLen(Message * m, uint8_t needed, uint8_t learn);
105:           static uint8_t evtIdxToTableIndex(uint8_t evtIdx);
106:           TimedResponseResult nerdCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
107:           TimedResponseResult reqevCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
108:           uint16_t getNN(uint8_t tableIndex);
109:           uint16_t getEN(uint8_t tableIndex);
110:           uint8_t numEv(uint8_t tableIndex);
111:           int16_t getEv(uint8_t tableIndex, uint8_t evNum);
112:           static uint8_t tableIndexToEvtIdx(uint8_t tableIndex);
113:           uint8_t findEvent(uint16_t nodeNumber, uint16_t eventNumber);
114:           static uint8_t removeTableEntry(uint8_t tableIndex);
115:           uint8_t removeEvent(uint16_t nodeNumber, uint16_t eventNumber);
116:           void checkRemoveTableEntry(uint8_t tableIndex);
117:           static void doNnclr(void);
118:           static void doNerd(void);
119:           static void doNnevn(void);
120:           static void doRqevn(void);
121:           static void doNenrd(uint8_t index);
122:           static void doReval(uint8_t enNum, uint8_t evNum);
123:           static void doEvuln(uint16_t nodeNumber, uint16_t eventNumber);
124:           static void doReqev(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum);
125:           static void doEvlrn(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum, uint8_t evVal);
126:           
127:           #ifdef VLCB_DIAG
128:           static DiagnosticVal * teachGetDiagnostic(uint8_t code);
129:           /**
130:            * The diagnostic values supported by the MNS service.
131:            */
132:           static DiagnosticVal teachDiagnostics[NUM_TEACH_DIAGNOSTICS+1];
133:           #endif
134:           
135:           /*
136:            * Each row in the event table consists of:
137:            * Event + flags + ev[PARAM_NUM_EV_EVENT] i.e. a total of 5 + PARAM_NUM_EV_EVENT bytes 
138:            */
139:           
140:           #define EVENTTABLE_WIDTH (sizeof(Event) + 1 + PARAM_NUM_EV_EVENT)
141:           #define EVENTTABLE_OFFSET_NNH   0
142:           #define EVENTTABLE_OFFSET_NNL   1
143:           #define EVENTTABLE_OFFSET_ENH   2
144:           #define EVENTTABLE_OFFSET_ENL   3
145:           #define EVENTTABLE_OFFSET_FLAGS 4
146:           #define EVENTTABLE_OFFSET_EVS   5
147:           // The flags
148:           #define EVENT_FLAG_DEFAULT      1
149:           
150:           /**
151:            * The service descriptor for the event teach service. The application must include this
152:            * descriptor within the const Service * const services[] array and include the
153:            * necessary settings within module.h in order to make use of the event teach
154:            * service.
155:            */
156:           const Service eventTeachService = {
157:               SERVICE_ID_OLD_TEACH,      // id
158:               1,                  // version
159:               teachFactoryReset,  // factoryReset
160:               teachPowerUp,       // powerUp
161:               teachProcessMessage,// processMessage
162:               NULL,               // poll
163:           #if defined(_18F66K80_FAMILY_)
164:               NULL,               // highIsr
165:               NULL,               // lowIsr
166:           #endif
167:           #ifdef VLCB_SERVICE
168:               teachGetESDdata,    // get ESD data
169:           #endif
170:           #ifdef VLCB_DIAG
171:               teachGetDiagnostic, // getDiagnostic
172:           #endif
173:           };
174:           
175:           //
176:           // SERVICE FUNCTIONS
177:           //
178:           
179:           /**
180:            * Factory reset clears the event table.
181:            */
182:           static void teachFactoryReset(void) {
183:               clearAllEvents();
16290  ECF8     CALL 0x161F0, 0
16292  F0B0     NOP
184:           }
16294  0012     RETURN 0
185:           
186:           /**
187:            * Power up loads the RAM based hash tables from the non volatile event table.
188:            */
189:           static void teachPowerUp(void) {
190:               uint8_t i;
191:           
192:           #ifdef VLCB_DIAG
193:               // Clear the diagnostics
194:               for (i=1; i<= NUM_TEACH_DIAGNOSTICS; i++) {
15D18  0E01     MOVLW 0x1
15D1A  6E02     MOVWF ___rparam_used, ACCESS
195:                   teachDiagnostics[i].asUint = 0;
15D1C  5002     MOVF ___rparam_used, W, ACCESS
15D1E  0D02     MULLW 0x2
15D20  0ED4     MOVLW 0xD4
15D22  24F3     ADDWF 0xFF3, W, ACCESS
15D24  6ED9     MOVWF 0xFD9, ACCESS
15D26  0E05     MOVLW 0x5
15D28  20F4     ADDWFC 0xFF4, W, ACCESS
15D2A  6EDA     MOVWF 0xFDA, ACCESS
15D2C  6ADE     CLRF 0xFDE, ACCESS
15D2E  6ADD     CLRF 0xFDD, ACCESS
196:               }
15D30  2A02     INCF ___rparam_used, F, ACCESS
15D32  0E01     MOVLW 0x1
15D34  6402     CPFSGT ___rparam_used, ACCESS
15D36  D7F2     BRA 0x5D1C
197:               teachDiagnostics[TEACH_DIAG_COUNT].asUint = NUM_TEACH_DIAGNOSTICS;
15D38  0E00     MOVLW 0x0
15D3A  0105     MOVLB 0x5
15D3C  6FD5     MOVWF CLCSELECT, BANKED
15D3E  0E01     MOVLW 0x1
15D40  6FD4     MOVWF CLCDATA, BANKED
198:           #endif
199:               mode_flags &= ~FLAG_MODE_LEARN; // revert to learn OFF on power up
15D42  91B4     BCF PRLOCK, 0, BANKED
200:           }
15D44  0012     RETURN 0
201:           
202:           /**
203:            * Process the event teaching messages. There are many messages to be handles such as
204:            * ones to enter Learn mode, returning information about the number of slots in
205:            * the event table. The main functionality manages the Events and EVs.
206:            * @param m the message to be processed
207:            * @return PROCESSED if the message need no further processing
208:            */
209:           static Processed teachProcessMessage(Message* m) {
210:               switch(m->opc) {
10AAA  D2A8     BRA 0xFFC
211:                   /* First mode changes. Another check if we are going into Learn or another node is going to Learn */
212:                   case OPC_NNLRN:
213:                       if (teachCheckLen(m, 3, 0) == PROCESSED) return PROCESSED;
10AAC  C546     MOVFF m, m
10AAE  F530     NOP
10AB0  C547     MOVFF 0x547, evVal
10AB2  F531     NOP
10AB4  0E03     MOVLW 0x3
10AB6  6E32     MOVWF 0x32, ACCESS
10AB8  0E00     MOVLW 0x0
10ABA  6E33     MOVWF 0x33, ACCESS
10ABC  EC35     CALL 0x1506A, 0
10ABE  F0A8     NOP
10AC0  06E8     DECF 0xFE8, F, ACCESS
10AC2  A4D8     BTFSS 0xFD8, 2, ACCESS
10AC4  D002     BRA 0xACA
10AC6  0E01     MOVLW 0x1
10AC8  0012     RETURN 0
214:                       if ((m->bytes[0] == nn.bytes.hi) && (m->bytes[1] == nn.bytes.lo)) {
10ACA  EE20     LFSR 2, 0x2
10ACC  F002     NOP
10ACE  5046     MOVF NVMDAT, W, ACCESS
10AD0  26D9     ADDWF 0xFD9, F, ACCESS
10AD2  5047     MOVF NVMDATH, W, ACCESS
10AD4  22DA     ADDWFC 0xFDA, F, ACCESS
10AD6  50DE     MOVF 0xFDE, W, ACCESS
10AD8  1854     XORWF 0x54, W, ACCESS
10ADA  A4D8     BTFSS 0xFD8, 2, ACCESS
10ADC  D00D     BRA 0xAF8
10ADE  EE20     LFSR 2, 0x3
10AE0  F003     NOP
10AE2  5046     MOVF NVMDAT, W, ACCESS
10AE4  26D9     ADDWF 0xFD9, F, ACCESS
10AE6  5047     MOVF NVMDATH, W, ACCESS
10AE8  22DA     ADDWFC 0xFDA, F, ACCESS
10AEA  5053     MOVF 0x53, W, ACCESS
10AEC  18DE     XORWF 0xFDE, W, ACCESS
10AEE  A4D8     BTFSS 0xFD8, 2, ACCESS
10AF0  D003     BRA 0xAF8
215:                           mode_flags |= FLAG_MODE_LEARN;
10AF2  0105     MOVLB 0x5
10AF4  81B4     BSF PRLOCK, 0, BANKED
216:                       } else {
10AF6  D7E7     BRA 0xAC6
217:                           mode_flags &= ~FLAG_MODE_LEARN;
10AF8  0105     MOVLB 0x5
10AFA  91B4     BCF PRLOCK, 0, BANKED
10AFC  D7E4     BRA 0xAC6
218:                       }
219:                       return PROCESSED;
220:           #ifdef VLCB_MODE
221:                   case OPC_MODE:      // 76 MODE - NN, mode
222:                       if (teachCheckLen(m, 4, 0) == PROCESSED) return PROCESSED;
10AFE  C546     MOVFF m, m
10B00  F530     NOP
10B02  C547     MOVFF 0x547, evVal
10B04  F531     NOP
10B06  0E04     MOVLW 0x4
10B08  6E32     MOVWF 0x32, ACCESS
10B0A  0E00     MOVLW 0x0
10B0C  6E33     MOVWF 0x33, ACCESS
10B0E  EC35     CALL 0x1506A, 0
10B10  F0A8     NOP
10B12  06E8     DECF 0xFE8, F, ACCESS
10B14  B4D8     BTFSC 0xFD8, 2, ACCESS
10B16  D7D7     BRA 0xAC6
223:                       if ((m->bytes[0] == nn.bytes.hi) && (m->bytes[1] == nn.bytes.lo)) {
10B18  EE20     LFSR 2, 0x2
10B1A  F002     NOP
10B1C  5046     MOVF NVMDAT, W, ACCESS
10B1E  26D9     ADDWF 0xFD9, F, ACCESS
10B20  5047     MOVF NVMDATH, W, ACCESS
10B22  22DA     ADDWFC 0xFDA, F, ACCESS
10B24  50DE     MOVF 0xFDE, W, ACCESS
10B26  1854     XORWF 0x54, W, ACCESS
10B28  A4D8     BTFSS 0xFD8, 2, ACCESS
10B2A  D01F     BRA 0xB6A
10B2C  EE20     LFSR 2, 0x3
10B2E  F003     NOP
10B30  5046     MOVF NVMDAT, W, ACCESS
10B32  26D9     ADDWF 0xFD9, F, ACCESS
10B34  5047     MOVF NVMDATH, W, ACCESS
10B36  22DA     ADDWFC 0xFDA, F, ACCESS
10B38  5053     MOVF 0x53, W, ACCESS
10B3A  18DE     XORWF 0xFDE, W, ACCESS
10B3C  A4D8     BTFSS 0xFD8, 2, ACCESS
10B3E  D015     BRA 0xB6A
224:                           if (m->bytes[2] == MODE_LEARN_ON) {
10B40  EE20     LFSR 2, 0x4
10B42  F004     NOP
10B44  5046     MOVF NVMDAT, W, ACCESS
10B46  26D9     ADDWF 0xFD9, F, ACCESS
10B48  5047     MOVF NVMDATH, W, ACCESS
10B4A  22DA     ADDWFC 0xFDA, F, ACCESS
10B4C  0E08     MOVLW 0x8
10B4E  18DE     XORWF 0xFDE, W, ACCESS
10B50  B4D8     BTFSC 0xFD8, 2, ACCESS
10B52  D7CF     BRA 0xAF2
225:                               // Do enter Learn mode
226:                               mode_flags |= FLAG_MODE_LEARN;
227:                               return PROCESSED;
228:                           } else if (m->bytes[2] == MODE_LEARN_OFF) {
10B54  EE20     LFSR 2, 0x4
10B56  F004     NOP
10B58  5046     MOVF NVMDAT, W, ACCESS
10B5A  26D9     ADDWF 0xFD9, F, ACCESS
10B5C  5047     MOVF NVMDATH, W, ACCESS
10B5E  22DA     ADDWFC 0xFDA, F, ACCESS
10B60  0E09     MOVLW 0x9
10B62  18DE     XORWF 0xFDE, W, ACCESS
10B64  B4D8     BTFSC 0xFD8, 2, ACCESS
10B66  D7C8     BRA 0xAF8
10B68  D002     BRA 0xB6E
229:                               // Do exit Learn mode
230:                               mode_flags &= ~FLAG_MODE_LEARN;
231:                               return PROCESSED;
232:                           }
233:                       } else {
234:                           // Another module going to Learn so we must exit learn
235:                           mode_flags &= ~FLAG_MODE_LEARN;
10B6A  0105     MOVLB 0x5
10B6C  91B4     BCF PRLOCK, 0, BANKED
236:                       }
237:                       return NOT_PROCESSED;   // mode probably processed by other services
10B6E  0E00     MOVLW 0x0
10B70  0012     RETURN 0
238:           #endif
239:                   /* This block must be in Learn mode and NN doesn't need to match ours */
240:                   case OPC_EVLRN:     // D2 EVLRN - NN, EN, EV#, EVval
241:                       if (teachCheckLen(m, 7, 1) == PROCESSED) {
10B72  C546     MOVFF m, m
10B74  F530     NOP
10B76  C547     MOVFF 0x547, evVal
10B78  F531     NOP
10B7A  0E07     MOVLW 0x7
10B7C  6E32     MOVWF 0x32, ACCESS
10B7E  0E01     MOVLW 0x1
10B80  6E33     MOVWF 0x33, ACCESS
10B82  EC35     CALL 0x1506A, 0
10B84  F0A8     NOP
10B86  06E8     DECF 0xFE8, F, ACCESS
10B88  A4D8     BTFSS 0xFD8, 2, ACCESS
10B8A  D00A     BRA 0xBA0
242:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_CMD);
10B8C  C554     MOVFF 0x554, data1
10B8E  F525     NOP
10B90  C553     MOVFF nn, data2
10B92  F526     NOP
10B94  0E01     MOVLW 0x1
10B96  6E27     MOVWF 0x27, ACCESS
10B98  0E6F     MOVLW 0x6F
10B9A  EC3E     CALL 0x15E7C, 0
10B9C  F0AF     NOP
10B9E  D793     BRA 0xAC6
243:           //                sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVLRN, SERVICE_ID_OLD_TEACH, CMDERR_INV_CMD);
244:                           return PROCESSED;
245:                       }
246:                       if (! (mode_flags & FLAG_MODE_LEARN)) return PROCESSED;
10BA0  0105     MOVLB 0x5
10BA2  A1B4     BTFSS PRLOCK, 0, BANKED
10BA4  D790     BRA 0xAC6
247:                       // Do learn
248:                       doEvlrn((uint16_t)(m->bytes[0]<<8) | (m->bytes[1]), (uint16_t)(m->bytes[2]<<8) | (m->bytes[3]), m->bytes[4], m->bytes[5]);
10BA6  EE20     LFSR 2, 0x3
10BA8  F003     NOP
10BAA  5046     MOVF NVMDAT, W, ACCESS
10BAC  26D9     ADDWF 0xFD9, F, ACCESS
10BAE  5047     MOVF NVMDATH, W, ACCESS
10BB0  22DA     ADDWFC 0xFDA, F, ACCESS
10BB2  50DF     MOVF 0xFDF, W, ACCESS
10BB4  6E48     MOVWF VREGCON, ACCESS
10BB6  EE20     LFSR 2, 0x2
10BB8  F002     NOP
10BBA  5046     MOVF NVMDAT, W, ACCESS
10BBC  26D9     ADDWF 0xFD9, F, ACCESS
10BBE  5047     MOVF NVMDATH, W, ACCESS
10BC0  22DA     ADDWFC 0xFDA, F, ACCESS
10BC2  50DF     MOVF 0xFDF, W, ACCESS
10BC4  6E49     MOVWF BORCON, ACCESS
10BC6  5048     MOVF VREGCON, W, ACCESS
10BC8  6E3F     MOVWF 0x3F, ACCESS
10BCA  C549     MOVFF 0x549, tableIndex
10BCC  F540     NOP
10BCE  EE20     LFSR 2, 0x5
10BD0  F005     NOP
10BD2  5046     MOVF NVMDAT, W, ACCESS
10BD4  26D9     ADDWF 0xFD9, F, ACCESS
10BD6  5047     MOVF NVMDATH, W, ACCESS
10BD8  22DA     ADDWFC 0xFDA, F, ACCESS
10BDA  50DF     MOVF 0xFDF, W, ACCESS
10BDC  6E4B     MOVWF HLVDCON1, ACCESS
10BDE  EE20     LFSR 2, 0x4
10BE0  F004     NOP
10BE2  5046     MOVF NVMDAT, W, ACCESS
10BE4  26D9     ADDWF 0xFD9, F, ACCESS
10BE6  5047     MOVF NVMDATH, W, ACCESS
10BE8  22DA     ADDWFC 0xFDA, F, ACCESS
10BEA  50DF     MOVF 0xFDF, W, ACCESS
10BEC  6E4C     MOVWF ZCDCON, ACCESS
10BEE  504B     MOVF HLVDCON1, W, ACCESS
10BF0  6E41     MOVWF NVMCON1, ACCESS
10BF2  C54C     MOVFF eventIndex, 0x542
10BF4  F542     NOP
10BF6  EE20     LFSR 2, 0x6
10BF8  F006     NOP
10BFA  5046     MOVF NVMDAT, W, ACCESS
10BFC  26D9     ADDWF 0xFD9, F, ACCESS
10BFE  5047     MOVF NVMDATH, W, ACCESS
10C00  22DA     ADDWFC 0xFDA, F, ACCESS
10C02  50DF     MOVF 0xFDF, W, ACCESS
10C04  6E43     MOVWF NVMADR, ACCESS
10C06  EE20     LFSR 2, 0x7
10C08  F007     NOP
10C0A  5046     MOVF NVMDAT, W, ACCESS
10C0C  26D9     ADDWF 0xFD9, F, ACCESS
10C0E  5047     MOVF NVMDATH, W, ACCESS
10C10  22DA     ADDWFC 0xFDA, F, ACCESS
10C12  50DF     MOVF 0xFDF, W, ACCESS
10C14  6E44     MOVWF NVMADRH, ACCESS
10C16  EC3C     CALL 0x13E78, 0
10C18  F09F     NOP
10C1A  D755     BRA 0xAC6
249:                       return PROCESSED;
250:                   case OPC_EVULN:     // 95 EVULN - NN, EN
251:                       if (teachCheckLen(m, 5, 1) == PROCESSED) return PROCESSED;
10C1C  C546     MOVFF m, m
10C1E  F530     NOP
10C20  C547     MOVFF 0x547, evVal
10C22  F531     NOP
10C24  0E05     MOVLW 0x5
10C26  6E32     MOVWF 0x32, ACCESS
10C28  0E01     MOVLW 0x1
10C2A  6E33     MOVWF 0x33, ACCESS
10C2C  EC35     CALL 0x1506A, 0
10C2E  F0A8     NOP
10C30  06E8     DECF 0xFE8, F, ACCESS
10C32  B4D8     BTFSC 0xFD8, 2, ACCESS
10C34  D748     BRA 0xAC6
252:                       if (! (mode_flags & FLAG_MODE_LEARN)) return PROCESSED;
10C36  0105     MOVLB 0x5
10C38  A1B4     BTFSS PRLOCK, 0, BANKED
10C3A  D745     BRA 0xAC6
253:                       // do unlearn
254:                       doEvuln((uint16_t)(m->bytes[0]<<8) | (m->bytes[1]), (uint16_t)(m->bytes[2]<<8) | (m->bytes[3]));
10C3C  EE20     LFSR 2, 0x3
10C3E  F003     NOP
10C40  5046     MOVF NVMDAT, W, ACCESS
10C42  26D9     ADDWF 0xFD9, F, ACCESS
10C44  5047     MOVF NVMDATH, W, ACCESS
10C46  22DA     ADDWFC 0xFDA, F, ACCESS
10C48  50DF     MOVF 0xFDF, W, ACCESS
10C4A  6E48     MOVWF VREGCON, ACCESS
10C4C  EE20     LFSR 2, 0x2
10C4E  F002     NOP
10C50  5046     MOVF NVMDAT, W, ACCESS
10C52  26D9     ADDWF 0xFD9, F, ACCESS
10C54  5047     MOVF NVMDATH, W, ACCESS
10C56  22DA     ADDWFC 0xFDA, F, ACCESS
10C58  50DF     MOVF 0xFDF, W, ACCESS
10C5A  6E49     MOVWF BORCON, ACCESS
10C5C  5048     MOVF VREGCON, W, ACCESS
10C5E  6E2B     MOVWF 0x2B, ACCESS
10C60  C549     MOVFF 0x549, opc
10C62  F52C     NOP
10C64  EE20     LFSR 2, 0x5
10C66  F005     NOP
10C68  5046     MOVF NVMDAT, W, ACCESS
10C6A  26D9     ADDWF 0xFD9, F, ACCESS
10C6C  5047     MOVF NVMDATH, W, ACCESS
10C6E  22DA     ADDWFC 0xFDA, F, ACCESS
10C70  50DF     MOVF 0xFDF, W, ACCESS
10C72  6E4B     MOVWF HLVDCON1, ACCESS
10C74  EE20     LFSR 2, 0x4
10C76  F004     NOP
10C78  5046     MOVF NVMDAT, W, ACCESS
10C7A  26D9     ADDWF 0xFD9, F, ACCESS
10C7C  5047     MOVF NVMDATH, W, ACCESS
10C7E  22DA     ADDWFC 0xFDA, F, ACCESS
10C80  50DF     MOVF 0xFDF, W, ACCESS
10C82  6E4C     MOVWF ZCDCON, ACCESS
10C84  504B     MOVF HLVDCON1, W, ACCESS
10C86  6E2D     MOVWF 0x2D, ACCESS
10C88  C54C     MOVFF eventIndex, service
10C8A  F52E     NOP
10C8C  EC6B     CALL 0x14AD6, 0
10C8E  F0A5     NOP
10C90  D71A     BRA 0xAC6
255:                       return PROCESSED;
256:                   case OPC_REQEV:     // B2 REQEV - NN EN EV#
257:                       if (teachCheckLen(m, 6, 1) == PROCESSED) return PROCESSED;
10C92  C546     MOVFF m, m
10C94  F530     NOP
10C96  C547     MOVFF 0x547, evVal
10C98  F531     NOP
10C9A  0E06     MOVLW 0x6
10C9C  6E32     MOVWF 0x32, ACCESS
10C9E  0E01     MOVLW 0x1
10CA0  6E33     MOVWF 0x33, ACCESS
10CA2  EC35     CALL 0x1506A, 0
10CA4  F0A8     NOP
10CA6  06E8     DECF 0xFE8, F, ACCESS
10CA8  B4D8     BTFSC 0xFD8, 2, ACCESS
10CAA  D70D     BRA 0xAC6
258:                       if (! (mode_flags & FLAG_MODE_LEARN)) return PROCESSED;
10CAC  0105     MOVLB 0x5
10CAE  A1B4     BTFSS PRLOCK, 0, BANKED
10CB0  D70A     BRA 0xAC6
259:                       // do read EV
260:                       doReqev((uint16_t)(m->bytes[0]<<8) | (m->bytes[1]), (uint16_t)(m->bytes[2]<<8) | (m->bytes[3]), m->bytes[4]);
10CB2  EE20     LFSR 2, 0x3
10CB4  F003     NOP
10CB6  5046     MOVF NVMDAT, W, ACCESS
10CB8  26D9     ADDWF 0xFD9, F, ACCESS
10CBA  5047     MOVF NVMDATH, W, ACCESS
10CBC  22DA     ADDWFC 0xFDA, F, ACCESS
10CBE  50DF     MOVF 0xFDF, W, ACCESS
10CC0  6E48     MOVWF VREGCON, ACCESS
10CC2  EE20     LFSR 2, 0x2
10CC4  F002     NOP
10CC6  5046     MOVF NVMDAT, W, ACCESS
10CC8  26D9     ADDWF 0xFD9, F, ACCESS
10CCA  5047     MOVF NVMDATH, W, ACCESS
10CCC  22DA     ADDWFC 0xFDA, F, ACCESS
10CCE  50DF     MOVF 0xFDF, W, ACCESS
10CD0  6E49     MOVWF BORCON, ACCESS
10CD2  5048     MOVF VREGCON, W, ACCESS
10CD4  6E2C     MOVWF 0x2C, ACCESS
10CD6  C549     MOVFF 0x549, needed
10CD8  F52D     NOP
10CDA  EE20     LFSR 2, 0x5
10CDC  F005     NOP
10CDE  5046     MOVF NVMDAT, W, ACCESS
10CE0  26D9     ADDWF 0xFD9, F, ACCESS
10CE2  5047     MOVF NVMDATH, W, ACCESS
10CE4  22DA     ADDWFC 0xFDA, F, ACCESS
10CE6  50DF     MOVF 0xFDF, W, ACCESS
10CE8  6E4B     MOVWF HLVDCON1, ACCESS
10CEA  EE20     LFSR 2, 0x4
10CEC  F004     NOP
10CEE  5046     MOVF NVMDAT, W, ACCESS
10CF0  26D9     ADDWF 0xFD9, F, ACCESS
10CF2  5047     MOVF NVMDATH, W, ACCESS
10CF4  22DA     ADDWFC 0xFDA, F, ACCESS
10CF6  50DF     MOVF 0xFDF, W, ACCESS
10CF8  6E4C     MOVWF ZCDCON, ACCESS
10CFA  504B     MOVF HLVDCON1, W, ACCESS
10CFC  6E2E     MOVWF 0x2E, ACCESS
10CFE  C54C     MOVFF eventIndex, tableIndex
10D00  F52F     NOP
10D02  EE20     LFSR 2, 0x6
10D04  F006     NOP
10D06  5046     MOVF NVMDAT, W, ACCESS
10D08  26D9     ADDWF 0xFD9, F, ACCESS
10D0A  5047     MOVF NVMDATH, W, ACCESS
10D0C  22DA     ADDWFC 0xFDA, F, ACCESS
10D0E  50DF     MOVF 0xFDF, W, ACCESS
10D10  6E30     MOVWF 0x30, ACCESS
10D12  ECA8     CALL 0x13350, 0
10D14  F099     NOP
10D16  D6D7     BRA 0xAC6
261:                       return PROCESSED;
262:                   /* This block contain an NN which needs to match our NN */
263:                   case OPC_NNULN:     // 54 NNULN - NN
264:                       if (teachCheckLen(m, 3, 0) == PROCESSED) return PROCESSED;
10D18  C546     MOVFF m, m
10D1A  F530     NOP
10D1C  C547     MOVFF 0x547, evVal
10D1E  F531     NOP
10D20  0E03     MOVLW 0x3
10D22  6E32     MOVWF 0x32, ACCESS
10D24  0E00     MOVLW 0x0
10D26  6E33     MOVWF 0x33, ACCESS
10D28  EC35     CALL 0x1506A, 0
10D2A  F0A8     NOP
10D2C  06E8     DECF 0xFE8, F, ACCESS
10D2E  B4D8     BTFSC 0xFD8, 2, ACCESS
10D30  D6CA     BRA 0xAC6
265:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10D32  EE20     LFSR 2, 0x2
10D34  F002     NOP
10D36  5046     MOVF NVMDAT, W, ACCESS
10D38  26D9     ADDWF 0xFD9, F, ACCESS
10D3A  5047     MOVF NVMDATH, W, ACCESS
10D3C  22DA     ADDWFC 0xFDA, F, ACCESS
10D3E  50DE     MOVF 0xFDE, W, ACCESS
10D40  1854     XORWF 0x54, W, ACCESS
10D42  A4D8     BTFSS 0xFD8, 2, ACCESS
10D44  D6C0     BRA 0xAC6
10D46  EE20     LFSR 2, 0x3
10D48  F003     NOP
10D4A  5046     MOVF NVMDAT, W, ACCESS
10D4C  26D9     ADDWF 0xFD9, F, ACCESS
10D4E  5047     MOVF NVMDATH, W, ACCESS
10D50  22DA     ADDWFC 0xFDA, F, ACCESS
10D52  5053     MOVF 0x53, W, ACCESS
10D54  18DE     XORWF 0xFDE, W, ACCESS
10D56  A4D8     BTFSS 0xFD8, 2, ACCESS
10D58  D6B6     BRA 0xAC6
10D5A  D6CE     BRA 0xAF8
266:                       // Do exit Learn mode
267:                       mode_flags &= ~FLAG_MODE_LEARN;
268:                       return PROCESSED;
269:                   case OPC_NNCLR:     // 55 NNCLR - NN
270:                       if (teachCheckLen(m, 3, 1) == PROCESSED) return PROCESSED;
10D5C  C546     MOVFF m, m
10D5E  F530     NOP
10D60  C547     MOVFF 0x547, evVal
10D62  F531     NOP
10D64  0E03     MOVLW 0x3
10D66  6E32     MOVWF 0x32, ACCESS
10D68  0E01     MOVLW 0x1
10D6A  6E33     MOVWF 0x33, ACCESS
10D6C  EC35     CALL 0x1506A, 0
10D6E  F0A8     NOP
10D70  06E8     DECF 0xFE8, F, ACCESS
10D72  B4D8     BTFSC 0xFD8, 2, ACCESS
10D74  D6A8     BRA 0xAC6
271:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10D76  EE20     LFSR 2, 0x2
10D78  F002     NOP
10D7A  5046     MOVF NVMDAT, W, ACCESS
10D7C  26D9     ADDWF 0xFD9, F, ACCESS
10D7E  5047     MOVF NVMDATH, W, ACCESS
10D80  22DA     ADDWFC 0xFDA, F, ACCESS
10D82  50DE     MOVF 0xFDE, W, ACCESS
10D84  1854     XORWF 0x54, W, ACCESS
10D86  A4D8     BTFSS 0xFD8, 2, ACCESS
10D88  D69E     BRA 0xAC6
10D8A  EE20     LFSR 2, 0x3
10D8C  F003     NOP
10D8E  5046     MOVF NVMDAT, W, ACCESS
10D90  26D9     ADDWF 0xFD9, F, ACCESS
10D92  5047     MOVF NVMDATH, W, ACCESS
10D94  22DA     ADDWFC 0xFDA, F, ACCESS
10D96  5053     MOVF 0x53, W, ACCESS
10D98  18DE     XORWF 0xFDE, W, ACCESS
10D9A  A4D8     BTFSS 0xFD8, 2, ACCESS
10D9C  D694     BRA 0xAC6
272:                       /* Must be in Learn mode for this one */
273:                       if (! (mode_flags & FLAG_MODE_LEARN)) {
10D9E  0105     MOVLB 0x5
10DA0  B1B4     BTFSC PRLOCK, 0, BANKED
10DA2  D017     BRA 0xDD2
274:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_NOT_LRN);
10DA4  C554     MOVFF 0x554, data1
10DA6  F525     NOP
10DA8  C553     MOVFF nn, data2
10DAA  F526     NOP
10DAC  0E02     MOVLW 0x2
10DAE  6E27     MOVWF 0x27, ACCESS
10DB0  0E6F     MOVLW 0x6F
10DB2  EC3E     CALL 0x15E7C, 0
10DB4  F0AF     NOP
275:           #ifdef VLCB_GRSP
276:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NNCLR, SERVICE_ID_OLD_TEACH, CMDERR_NOT_LRN);
10DB6  C554     MOVFF 0x554, data1
10DB8  F525     NOP
10DBA  C553     MOVFF nn, data2
10DBC  F526     NOP
10DBE  0E55     MOVLW 0x55
10DC0  6E27     MOVWF 0x27, ACCESS
10DC2  0E04     MOVLW 0x4
10DC4  6E28     MOVWF 0x28, ACCESS
10DC6  0E02     MOVLW 0x2
10DC8  6E29     MOVWF 0x29, ACCESS
10DCA  0EAF     MOVLW 0xAF
10DCC  EC7D     CALL 0x15EFA, 0
10DCE  F0AF     NOP
10DD0  D67A     BRA 0xAC6
277:           #endif
278:                           return PROCESSED;
279:                       }
280:                       // do NNCLR
281:                       doNnclr();
10DD2  ECA3     CALL 0x15D46, 0
10DD4  F0AE     NOP
282:                       break;
10DD6  D6CB     BRA 0xB6E
283:                   case OPC_NERD:      // 57 NERD - NN
284:                       if (teachCheckLen(m, 3, 0) == PROCESSED) return PROCESSED;
10DD8  C546     MOVFF m, m
10DDA  F530     NOP
10DDC  C547     MOVFF 0x547, evVal
10DDE  F531     NOP
10DE0  0E03     MOVLW 0x3
10DE2  6E32     MOVWF 0x32, ACCESS
10DE4  0E00     MOVLW 0x0
10DE6  6E33     MOVWF 0x33, ACCESS
10DE8  EC35     CALL 0x1506A, 0
10DEA  F0A8     NOP
10DEC  06E8     DECF 0xFE8, F, ACCESS
10DEE  B4D8     BTFSC 0xFD8, 2, ACCESS
10DF0  D66A     BRA 0xAC6
285:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10DF2  EE20     LFSR 2, 0x2
10DF4  F002     NOP
10DF6  5046     MOVF NVMDAT, W, ACCESS
10DF8  26D9     ADDWF 0xFD9, F, ACCESS
10DFA  5047     MOVF NVMDATH, W, ACCESS
10DFC  22DA     ADDWFC 0xFDA, F, ACCESS
10DFE  50DE     MOVF 0xFDE, W, ACCESS
10E00  1854     XORWF 0x54, W, ACCESS
10E02  A4D8     BTFSS 0xFD8, 2, ACCESS
10E04  D660     BRA 0xAC6
10E06  EE20     LFSR 2, 0x3
10E08  F003     NOP
10E0A  5046     MOVF NVMDAT, W, ACCESS
10E0C  26D9     ADDWF 0xFD9, F, ACCESS
10E0E  5047     MOVF NVMDATH, W, ACCESS
10E10  22DA     ADDWFC 0xFDA, F, ACCESS
10E12  5053     MOVF 0x53, W, ACCESS
10E14  18DE     XORWF 0xFDE, W, ACCESS
10E16  A4D8     BTFSS 0xFD8, 2, ACCESS
10E18  D656     BRA 0xAC6
286:                       // do NERD
287:                       doNerd();
10E1A  EC9F     CALL 0x1613E, 0
10E1C  F0B0     NOP
10E1E  D653     BRA 0xAC6
288:                       return PROCESSED;
289:                   case OPC_NNEVN:     // 56 NNEVN - NN
290:                       if (teachCheckLen(m, 3, 0) == PROCESSED) return PROCESSED;
10E20  C546     MOVFF m, m
10E22  F530     NOP
10E24  C547     MOVFF 0x547, evVal
10E26  F531     NOP
10E28  0E03     MOVLW 0x3
10E2A  6E32     MOVWF 0x32, ACCESS
10E2C  0E00     MOVLW 0x0
10E2E  6E33     MOVWF 0x33, ACCESS
10E30  EC35     CALL 0x1506A, 0
10E32  F0A8     NOP
10E34  06E8     DECF 0xFE8, F, ACCESS
10E36  B4D8     BTFSC 0xFD8, 2, ACCESS
10E38  D646     BRA 0xAC6
291:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10E3A  EE20     LFSR 2, 0x2
10E3C  F002     NOP
10E3E  5046     MOVF NVMDAT, W, ACCESS
10E40  26D9     ADDWF 0xFD9, F, ACCESS
10E42  5047     MOVF NVMDATH, W, ACCESS
10E44  22DA     ADDWFC 0xFDA, F, ACCESS
10E46  50DE     MOVF 0xFDE, W, ACCESS
10E48  1854     XORWF 0x54, W, ACCESS
10E4A  A4D8     BTFSS 0xFD8, 2, ACCESS
10E4C  D63C     BRA 0xAC6
10E4E  EE20     LFSR 2, 0x3
10E50  F003     NOP
10E52  5046     MOVF NVMDAT, W, ACCESS
10E54  26D9     ADDWF 0xFD9, F, ACCESS
10E56  5047     MOVF NVMDATH, W, ACCESS
10E58  22DA     ADDWFC 0xFDA, F, ACCESS
10E5A  5053     MOVF 0x53, W, ACCESS
10E5C  18DE     XORWF 0xFDE, W, ACCESS
10E5E  A4D8     BTFSS 0xFD8, 2, ACCESS
10E60  D632     BRA 0xAC6
292:                       // do NNEVN
293:                       doNnevn();
10E62  EC9C     CALL 0x15B38, 0
10E64  F0AD     NOP
10E66  D62F     BRA 0xAC6
294:                       return PROCESSED;
295:                   case OPC_RQEVN:     // 58 RQEVN - NN
296:                       if (teachCheckLen(m, 3, 0) == PROCESSED) return PROCESSED;
10E68  C546     MOVFF m, m
10E6A  F530     NOP
10E6C  C547     MOVFF 0x547, evVal
10E6E  F531     NOP
10E70  0E03     MOVLW 0x3
10E72  6E32     MOVWF 0x32, ACCESS
10E74  0E00     MOVLW 0x0
10E76  6E33     MOVWF 0x33, ACCESS
10E78  EC35     CALL 0x1506A, 0
10E7A  F0A8     NOP
10E7C  06E8     DECF 0xFE8, F, ACCESS
10E7E  B4D8     BTFSC 0xFD8, 2, ACCESS
10E80  D622     BRA 0xAC6
297:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10E82  EE20     LFSR 2, 0x2
10E84  F002     NOP
10E86  5046     MOVF NVMDAT, W, ACCESS
10E88  26D9     ADDWF 0xFD9, F, ACCESS
10E8A  5047     MOVF NVMDATH, W, ACCESS
10E8C  22DA     ADDWFC 0xFDA, F, ACCESS
10E8E  50DE     MOVF 0xFDE, W, ACCESS
10E90  1854     XORWF 0x54, W, ACCESS
10E92  A4D8     BTFSS 0xFD8, 2, ACCESS
10E94  D618     BRA 0xAC6
10E96  EE20     LFSR 2, 0x3
10E98  F003     NOP
10E9A  5046     MOVF NVMDAT, W, ACCESS
10E9C  26D9     ADDWF 0xFD9, F, ACCESS
10E9E  5047     MOVF NVMDATH, W, ACCESS
10EA0  22DA     ADDWFC 0xFDA, F, ACCESS
10EA2  5053     MOVF 0x53, W, ACCESS
10EA4  18DE     XORWF 0xFDE, W, ACCESS
10EA6  A4D8     BTFSS 0xFD8, 2, ACCESS
10EA8  D60E     BRA 0xAC6
298:                       // do RQEVN
299:                       doRqevn();
10EAA  EC7F     CALL 0x15AFE, 0
10EAC  F0AD     NOP
10EAE  D60B     BRA 0xAC6
300:                       return PROCESSED;
301:                   case OPC_NENRD:     // 72 NENRD - NN, EN#
302:                       if (teachCheckLen(m, 4, 0) == PROCESSED) return PROCESSED;
10EB0  C546     MOVFF m, m
10EB2  F530     NOP
10EB4  C547     MOVFF 0x547, evVal
10EB6  F531     NOP
10EB8  0E04     MOVLW 0x4
10EBA  6E32     MOVWF 0x32, ACCESS
10EBC  0E00     MOVLW 0x0
10EBE  6E33     MOVWF 0x33, ACCESS
10EC0  EC35     CALL 0x1506A, 0
10EC2  F0A8     NOP
10EC4  06E8     DECF 0xFE8, F, ACCESS
10EC6  B4D8     BTFSC 0xFD8, 2, ACCESS
10EC8  D5FE     BRA 0xAC6
303:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10ECA  EE20     LFSR 2, 0x2
10ECC  F002     NOP
10ECE  5046     MOVF NVMDAT, W, ACCESS
10ED0  26D9     ADDWF 0xFD9, F, ACCESS
10ED2  5047     MOVF NVMDATH, W, ACCESS
10ED4  22DA     ADDWFC 0xFDA, F, ACCESS
10ED6  50DE     MOVF 0xFDE, W, ACCESS
10ED8  1854     XORWF 0x54, W, ACCESS
10EDA  A4D8     BTFSS 0xFD8, 2, ACCESS
10EDC  D5F4     BRA 0xAC6
10EDE  EE20     LFSR 2, 0x3
10EE0  F003     NOP
10EE2  5046     MOVF NVMDAT, W, ACCESS
10EE4  26D9     ADDWF 0xFD9, F, ACCESS
10EE6  5047     MOVF NVMDATH, W, ACCESS
10EE8  22DA     ADDWFC 0xFDA, F, ACCESS
10EEA  5053     MOVF 0x53, W, ACCESS
10EEC  18DE     XORWF 0xFDE, W, ACCESS
10EEE  A4D8     BTFSS 0xFD8, 2, ACCESS
10EF0  D5EA     BRA 0xAC6
304:                       // do NENRD
305:                       doNenrd(m->bytes[2]);
10EF2  EE20     LFSR 2, 0x4
10EF4  F004     NOP
10EF6  5046     MOVF NVMDAT, W, ACCESS
10EF8  26D9     ADDWF 0xFD9, F, ACCESS
10EFA  5047     MOVF NVMDATH, W, ACCESS
10EFC  22DA     ADDWFC 0xFDA, F, ACCESS
10EFE  50DF     MOVF 0xFDF, W, ACCESS
10F00  ECF5     CALL 0x149EA, 0
10F02  F0A4     NOP
10F04  D5E0     BRA 0xAC6
306:                       return PROCESSED;
307:                   case OPC_REVAL:     // 9C REVAL - NN, EN#, EV#
308:                       if (teachCheckLen(m, 5, 0) == PROCESSED) return PROCESSED;
10F06  C546     MOVFF m, m
10F08  F530     NOP
10F0A  C547     MOVFF 0x547, evVal
10F0C  F531     NOP
10F0E  0E05     MOVLW 0x5
10F10  6E32     MOVWF 0x32, ACCESS
10F12  0E00     MOVLW 0x0
10F14  6E33     MOVWF 0x33, ACCESS
10F16  EC35     CALL 0x1506A, 0
10F18  F0A8     NOP
10F1A  06E8     DECF 0xFE8, F, ACCESS
10F1C  B4D8     BTFSC 0xFD8, 2, ACCESS
10F1E  D5D3     BRA 0xAC6
309:                       if ((m->bytes[0] != nn.bytes.hi) || (m->bytes[1] != nn.bytes.lo)) return PROCESSED;  // not us
10F20  EE20     LFSR 2, 0x2
10F22  F002     NOP
10F24  5046     MOVF NVMDAT, W, ACCESS
10F26  26D9     ADDWF 0xFD9, F, ACCESS
10F28  5047     MOVF NVMDATH, W, ACCESS
10F2A  22DA     ADDWFC 0xFDA, F, ACCESS
10F2C  50DE     MOVF 0xFDE, W, ACCESS
10F2E  1854     XORWF 0x54, W, ACCESS
10F30  A4D8     BTFSS 0xFD8, 2, ACCESS
10F32  D5C9     BRA 0xAC6
10F34  EE20     LFSR 2, 0x3
10F36  F003     NOP
10F38  5046     MOVF NVMDAT, W, ACCESS
10F3A  26D9     ADDWF 0xFD9, F, ACCESS
10F3C  5047     MOVF NVMDATH, W, ACCESS
10F3E  22DA     ADDWFC 0xFDA, F, ACCESS
10F40  5053     MOVF 0x53, W, ACCESS
10F42  18DE     XORWF 0xFDE, W, ACCESS
10F44  A4D8     BTFSS 0xFD8, 2, ACCESS
10F46  D5BF     BRA 0xAC6
310:                       // do REVAL
311:                       doReval(m->bytes[2], m->bytes[3]);
10F48  EE20     LFSR 2, 0x5
10F4A  F005     NOP
10F4C  5046     MOVF NVMDAT, W, ACCESS
10F4E  26D9     ADDWF 0xFD9, F, ACCESS
10F50  5047     MOVF NVMDATH, W, ACCESS
10F52  22DA     ADDWFC 0xFDA, F, ACCESS
10F54  50DF     MOVF 0xFDF, W, ACCESS
10F56  6E2B     MOVWF 0x2B, ACCESS
10F58  EE20     LFSR 2, 0x4
10F5A  F004     NOP
10F5C  5046     MOVF NVMDAT, W, ACCESS
10F5E  26D9     ADDWF 0xFD9, F, ACCESS
10F60  5047     MOVF NVMDATH, W, ACCESS
10F62  22DA     ADDWFC 0xFDA, F, ACCESS
10F64  50DF     MOVF 0xFDF, W, ACCESS
10F66  ECF3     CALL 0x141E6, 0
10F68  F0A0     NOP
10F6A  D5AD     BRA 0xAC6
312:                       return PROCESSED;
313:                   case OPC_EVLRNI:    // F5 EVLRNI - NN, EN, EN#, EV#, EVval
314:                       if (teachCheckLen(m, 8, 1) == PROCESSED) return PROCESSED;
10F6C  C546     MOVFF m, m
10F6E  F530     NOP
10F70  C547     MOVFF 0x547, evVal
10F72  F531     NOP
10F74  0E08     MOVLW 0x8
10F76  6E32     MOVWF 0x32, ACCESS
10F78  0E01     MOVLW 0x1
10F7A  6E33     MOVWF 0x33, ACCESS
10F7C  EC35     CALL 0x1506A, 0
10F7E  F0A8     NOP
10F80  06E8     DECF 0xFE8, F, ACCESS
10F82  B4D8     BTFSC 0xFD8, 2, ACCESS
10F84  D5A0     BRA 0xAC6
315:                       // do EVLRNI
316:                       doEvlrn((uint16_t)(m->bytes[0]<<8) | (m->bytes[1]), (uint16_t)(m->bytes[2]<<8) | (m->bytes[3]), m->bytes[5], m->bytes[6]);
10F86  EE20     LFSR 2, 0x3
10F88  F003     NOP
10F8A  5046     MOVF NVMDAT, W, ACCESS
10F8C  26D9     ADDWF 0xFD9, F, ACCESS
10F8E  5047     MOVF NVMDATH, W, ACCESS
10F90  22DA     ADDWFC 0xFDA, F, ACCESS
10F92  50DF     MOVF 0xFDF, W, ACCESS
10F94  6E48     MOVWF VREGCON, ACCESS
10F96  EE20     LFSR 2, 0x2
10F98  F002     NOP
10F9A  5046     MOVF NVMDAT, W, ACCESS
10F9C  26D9     ADDWF 0xFD9, F, ACCESS
10F9E  5047     MOVF NVMDATH, W, ACCESS
10FA0  22DA     ADDWFC 0xFDA, F, ACCESS
10FA2  50DF     MOVF 0xFDF, W, ACCESS
10FA4  6E49     MOVWF BORCON, ACCESS
10FA6  5048     MOVF VREGCON, W, ACCESS
10FA8  6E3F     MOVWF 0x3F, ACCESS
10FAA  C549     MOVFF 0x549, tableIndex
10FAC  F540     NOP
10FAE  EE20     LFSR 2, 0x5
10FB0  F005     NOP
10FB2  5046     MOVF NVMDAT, W, ACCESS
10FB4  26D9     ADDWF 0xFD9, F, ACCESS
10FB6  5047     MOVF NVMDATH, W, ACCESS
10FB8  22DA     ADDWFC 0xFDA, F, ACCESS
10FBA  50DF     MOVF 0xFDF, W, ACCESS
10FBC  6E4B     MOVWF HLVDCON1, ACCESS
10FBE  EE20     LFSR 2, 0x4
10FC0  F004     NOP
10FC2  5046     MOVF NVMDAT, W, ACCESS
10FC4  26D9     ADDWF 0xFD9, F, ACCESS
10FC6  5047     MOVF NVMDATH, W, ACCESS
10FC8  22DA     ADDWFC 0xFDA, F, ACCESS
10FCA  50DF     MOVF 0xFDF, W, ACCESS
10FCC  6E4C     MOVWF ZCDCON, ACCESS
10FCE  504B     MOVF HLVDCON1, W, ACCESS
10FD0  6E41     MOVWF NVMCON1, ACCESS
10FD2  C54C     MOVFF eventIndex, 0x542
10FD4  F542     NOP
10FD6  EE20     LFSR 2, 0x7
10FD8  F007     NOP
10FDA  5046     MOVF NVMDAT, W, ACCESS
10FDC  26D9     ADDWF 0xFD9, F, ACCESS
10FDE  5047     MOVF NVMDATH, W, ACCESS
10FE0  22DA     ADDWFC 0xFDA, F, ACCESS
10FE2  50DF     MOVF 0xFDF, W, ACCESS
10FE4  6E43     MOVWF NVMADR, ACCESS
10FE6  EE20     LFSR 2, 0x8
10FE8  F008     NOP
10FEA  5046     MOVF NVMDAT, W, ACCESS
10FEC  26D9     ADDWF 0xFD9, F, ACCESS
10FEE  5047     MOVF NVMDATH, W, ACCESS
10FF0  22DA     ADDWFC 0xFDA, F, ACCESS
10FF2  50DF     MOVF 0xFDF, W, ACCESS
10FF4  6E44     MOVWF NVMADRH, ACCESS
10FF6  EC3C     CALL 0x13E78, 0
10FF8  F09F     NOP
10FFA  D565     BRA 0xAC6
317:                       return PROCESSED;
318:                   default:
319:                       break;
320:               }
10FFC  EE20     LFSR 2, 0x1
10FFE  F001     NOP
11000  5046     MOVF NVMDAT, W, ACCESS
11002  26D9     ADDWF 0xFD9, F, ACCESS
11004  5047     MOVF NVMDATH, W, ACCESS
11006  22DA     ADDWFC 0xFDA, F, ACCESS
11008  50DF     MOVF 0xFDF, W, ACCESS
1100A  6E48     MOVWF VREGCON, ACCESS
1100C  6A49     CLRF BORCON, ACCESS
1100E  5049     MOVF BORCON, W, ACCESS
11010  0A00     XORLW 0x0
11012  A4D8     BTFSS 0xFD8, 2, ACCESS
11014  D5AC     BRA 0xB6E
11016  5048     MOVF VREGCON, W, ACCESS
11018  0A53     XORLW 0x53
1101A  B4D8     BTFSC 0xFD8, 2, ACCESS
1101C  D547     BRA 0xAAC
1101E  0A07     XORLW 0x7
11020  B4D8     BTFSC 0xFD8, 2, ACCESS
11022  D67A     BRA 0xD18
11024  0A01     XORLW 0x1
11026  B4D8     BTFSC 0xFD8, 2, ACCESS
11028  D699     BRA 0xD5C
1102A  0A03     XORLW 0x3
1102C  B4D8     BTFSC 0xFD8, 2, ACCESS
1102E  D6F8     BRA 0xE20
11030  0A01     XORLW 0x1
11032  B4D8     BTFSC 0xFD8, 2, ACCESS
11034  D6D1     BRA 0xDD8
11036  0A0F     XORLW 0xF
11038  B4D8     BTFSC 0xFD8, 2, ACCESS
1103A  D716     BRA 0xE68
1103C  0A2A     XORLW 0x2A
1103E  B4D8     BTFSC 0xFD8, 2, ACCESS
11040  D737     BRA 0xEB0
11042  0A04     XORLW 0x4
11044  B4D8     BTFSC 0xFD8, 2, ACCESS
11046  D55B     BRA 0xAFE
11048  0AE3     XORLW 0xE3
1104A  B4D8     BTFSC 0xFD8, 2, ACCESS
1104C  D5E7     BRA 0xC1C
1104E  0A09     XORLW 0x9
11050  B4D8     BTFSC 0xFD8, 2, ACCESS
11052  D759     BRA 0xF06
11054  0A2E     XORLW 0x2E
11056  B4D8     BTFSC 0xFD8, 2, ACCESS
11058  D61C     BRA 0xC92
1105A  0A60     XORLW 0x60
1105C  B4D8     BTFSC 0xFD8, 2, ACCESS
1105E  D589     BRA 0xB72
11060  0A27     XORLW 0x27
11062  B4D8     BTFSC 0xFD8, 2, ACCESS
11062  B4D8     BTFSC 0xFD8, 2, ACCESS
11062  B4D8     BTFSC 0xFD8, 2, ACCESS
321:               return NOT_PROCESSED;
322:           }
323:           
324:           /**
325:            * Check the message length to ensure it is valid.
326:            * @param m the message
327:            * @param needed the number of bytes needed
328:            * @param learn indicator whether to use Learn mode or NN
329:            * @return PROCESSED if there are insufficient bytes
330:            */
331:           static Processed teachCheckLen(Message * m, uint8_t needed, uint8_t learn) {
332:               if (learn) {
1506A  5033     MOVF 0x33, W, ACCESS
1506C  B4D8     BTFSC 0xFD8, 2, ACCESS
1506E  D022     BRA 0x50B4
333:                   // This is a message using Learn mode and therefore no NN
334:                   if (m->len < needed) {
15070  C530     MOVFF m, FSR2
15072  F4D9     NOP
15074  C531     MOVFF evVal, FSR2H
15076  F4DA     NOP
15078  5032     MOVF 0x32, W, ACCESS
1507A  5CDE     SUBWF 0xFDE, W, ACCESS
1507C  B0D8     BTFSC 0xFD8, 0, ACCESS
1507E  D018     BRA 0x50B0
335:                       // message is short
336:                       if (mode_flags & FLAG_MODE_LEARN) {
15080  0105     MOVLB 0x5
15082  A1B4     BTFSS PRLOCK, 0, BANKED
15084  D013     BRA 0x50AC
337:                           // This module is in Learn mode so we should indicate an error
338:           #ifdef VLCB_GRSP
339:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, m->opc, SERVICE_ID_OLD_TEACH, CMDERR_INV_CMD);
15086  C554     MOVFF 0x554, data1
15088  F525     NOP
1508A  C553     MOVFF nn, data2
1508C  F526     NOP
1508E  EE20     LFSR 2, 0x1
15090  F001     NOP
15092  5030     MOVF 0x30, W, ACCESS
15094  26D9     ADDWF 0xFD9, F, ACCESS
15096  5031     MOVF 0x31, W, ACCESS
15098  22DA     ADDWFC 0xFDA, F, ACCESS
1509A  50DF     MOVF 0xFDF, W, ACCESS
1509C  6E27     MOVWF 0x27, ACCESS
1509E  0E04     MOVLW 0x4
150A0  6E28     MOVWF 0x28, ACCESS
150A2  0E01     MOVLW 0x1
150A4  6E29     MOVWF 0x29, ACCESS
150A6  0EAF     MOVLW 0xAF
150A8  EC7D     CALL 0x15EFA, 0
150AA  F0AF     NOP
340:           #endif
341:                       }
342:                       return PROCESSED;
150AC  0E01     MOVLW 0x1
150AE  0012     RETURN 0
343:                   }
344:                   return NOT_PROCESSED;   // message length ok
150B0  0E00     MOVLW 0x0
150B2  0012     RETURN 0
345:               }
346:               return checkLen(m, needed, SERVICE_ID_OLD_TEACH);
150B4  C530     MOVFF m, opc
150B6  F52B     NOP
150B8  C531     MOVFF evVal, opc
150BA  F52C     NOP
150BC  C532     MOVFF needed, needed
150BE  F52D     NOP
150C0  0E04     MOVLW 0x4
150C2  6E2E     MOVWF 0x2E, ACCESS
150C4  ECA5     CALL 0x14B4A, 0
150C6  F0A5     NOP
347:           }
150C8  0012     RETURN 0
348:           
349:           #ifdef VLCB_SERVICE
350:           /**
351:            * The Teach service supports data in the ESD message.
352:            * @param id which of the ESD data bytes
353:            * @return the value to be returned in the data byte
354:            */
355:           static uint8_t teachGetESDdata(uint8_t id) {
160E0  6E02     MOVWF ___rparam_used, ACCESS
356:               switch (id) {
160E2  D006     BRA 0x60F0
357:                   case 1: return NUM_EVENTS;
160E4  0EFE     MOVLW 0xFE
160E6  0012     RETURN 0
358:                   case 2: return PARAM_NUM_EV_EVENT;
160E8  0E0D     MOVLW 0xD
160EA  0012     RETURN 0
359:                   default: return 0;
160EC  0E00     MOVLW 0x0
160EE  0012     RETURN 0
360:               }
160F0  5002     MOVF ___rparam_used, W, ACCESS
160F2  0A01     XORLW 0x1
160F4  B4D8     BTFSC 0xFD8, 2, ACCESS
160F6  D7F6     BRA 0x60E4
160F8  0A03     XORLW 0x3
160FA  B4D8     BTFSC 0xFD8, 2, ACCESS
160FA  B4D8     BTFSC 0xFD8, 2, ACCESS
160FA  B4D8     BTFSC 0xFD8, 2, ACCESS
361:           }
362:           #endif
363:           
364:           #ifdef VLCB_DIAG
365:           /**
366:            * Provide the means to return the diagnostic data.
367:            * @param index the diagnostic index 1..NUM_CAN_DIAGNOSTSICS
368:            * @return a pointer to the diagnostic data or NULL if the data isn't available
369:            */
370:           static DiagnosticVal * teachGetDiagnostic(uint8_t index) {
16076  6E0A     MOVWF 0xA, ACCESS
371:               if (index > NUM_TEACH_DIAGNOSTICS) {
16078  0E01     MOVLW 0x1
1607A  640A     CPFSGT 0xA, ACCESS
1607C  D005     BRA 0x6088
372:                   return NULL;
1607E  0E00     MOVLW 0x0
16080  6E08     MOVWF 0x8, ACCESS
16082  0E00     MOVLW 0x0
16084  6E09     MOVWF 0x9, ACCESS
16086  0012     RETURN 0
373:               }
374:               return &(teachDiagnostics[index]);
16088  500A     MOVF 0xA, W, ACCESS
1608A  0D02     MULLW 0x2
1608C  0ED4     MOVLW 0xD4
1608E  24F3     ADDWF 0xFF3, W, ACCESS
16090  6E08     MOVWF 0x8, ACCESS
16092  0E05     MOVLW 0x5
16094  20F4     ADDWFC 0xFF4, W, ACCESS
16096  6E09     MOVWF 0x9, ACCESS
375:           }
16098  0012     RETURN 0
376:           #endif
377:           
378:           //
379:           // FUNCTIONS TO DO THE ACTUAL WORK
380:           //
381:           
382:           /**
383:            * Removes all events including default events.
384:            */
385:           static void clearAllEvents(void) {
386:               uint8_t tableIndex;
387:           
388:               for (tableIndex=0; tableIndex<NUM_EVENTS; tableIndex++) {
161F0  0E00     MOVLW 0x0
161F2  6E21     MOVWF 0x21, ACCESS
389:                   removeTableEntry(tableIndex);
161F4  5021     MOVF 0x21, W, ACCESS
161F6  EC77     CALL 0x130EE, 0
161F8  F098     NOP
390:               }
161FA  2A21     INCF 0x21, F, ACCESS
161FA  2A21     INCF 0x21, F, ACCESS
161FA  2A21     INCF 0x21, F, ACCESS
161FA  2A21     INCF 0x21, F, ACCESS
161FA  2A21     INCF 0x21, F, ACCESS
391:           }
392:           
393:           /**
394:            * Read number of available event slots.
395:            * This returned the number of unused slots in the Consumed event Event2Action table.
396:            */
397:           static void doNnevn(void) {
398:               // count the number of unused slots.
399:               uint8_t count = 0;
15B38  0E00     MOVLW 0x0
15B3A  6E2B     MOVWF 0x2B, ACCESS
400:               uint8_t i;
401:               for (i=0; i<NUM_EVENTS; i++) {
15B3C  0E00     MOVLW 0x0
15B3E  6E2C     MOVWF 0x2C, ACCESS
402:                   uint16_t eventNumber;
403:                   eventNumber = getEN(i);
15B40  502C     MOVF 0x2C, W, ACCESS
15B42  ECC0     CALL 0x14D80, 0
15B44  F0A6     NOP
15B46  C50E     MOVFF evNum, data5
15B48  F529     NOP
15B4A  C50F     MOVFF interruptEnabled, data6
15B4C  F52A     NOP
404:                   if (eventNumber == 0) {
15B4E  5029     MOVF 0x29, W, ACCESS
15B50  102A     IORWF 0x2A, W, ACCESS
15B52  B4D8     BTFSC 0xFD8, 2, ACCESS
405:                       count++;
15B54  2A2B     INCF 0x2B, F, ACCESS
406:                   }
407:               }
15B56  2A2C     INCF 0x2C, F, ACCESS
15B58  0EFD     MOVLW 0xFD
15B5A  642C     CPFSGT 0x2C, ACCESS
15B5C  D7F1     BRA 0x5B40
408:               sendMessage3(OPC_EVNLF, nn.bytes.hi, nn.bytes.lo, count);
15B5E  C554     MOVFF 0x554, data1
15B60  F525     NOP
15B62  C553     MOVFF nn, data2
15B64  F526     NOP
15B66  C52B     MOVFF opc, data3
15B68  F527     NOP
15B6A  0E70     MOVLW 0x70
15B6C  EC3E     CALL 0x15E7C, 0
15B6E  F0AF     NOP
409:           } // doNnevn
15B70  0012     RETURN 0
410:           
411:           
412:           /**
413:            * Do the NERD. 
414:            * This sets things up so that timedResponse will do the right stuff.
415:            */
416:           static void doNerd(void) {
417:               startTimedResponse(TIMED_RESPONSE_NERD, findServiceIndex(SERVICE_ID_OLD_TEACH), nerdCallback);
1613E  0E04     MOVLW 0x4
16140  EC18     CALL 0x14C30, 0
16142  F0A6     NOP
16144  6E06     MOVWF 0x6, ACCESS
16146  0E0A     MOVLW 0xA
16148  6E07     MOVWF 0x7, ACCESS
1614A  0E54     MOVLW 0x54
1614C  6E08     MOVWF 0x8, ACCESS
1614E  0E01     MOVLW 0x1
16150  6E09     MOVWF 0x9, ACCESS
16152  0E02     MOVLW 0x2
16154  ECE2     CALL 0x159C4, 0
16156  F0AC     NOP
418:           }
16158  0012     RETURN 0
419:           
420:           /**
421:            * The callback to do the NERD responses.
422:            * @param type the type of the timedResponse
423:            * @param serviceIndex the service
424:            * @param step how far through the processing
425:            * @return whether to finish or continue processing
426:            */
427:           TimedResponseResult nerdCallback(uint8_t type, uint8_t serviceIndex, uint8_t step){
428:               Word nodeNumber, eventNumber;
429:               // The step is used to index through the event table
430:               if (step >= NUM_EVENTS) {  // finished?
1540A  0EFD     MOVLW 0xFD
1540C  6433     CPFSGT 0x33, ACCESS
1540E  D002     BRA 0x5414
431:                   return TIMED_RESPONSE_RESULT_FINISHED;
15410  0E00     MOVLW 0x0
15412  0012     RETURN 0
432:               }
433:           
434:               eventNumber.word = getEN(step);
15414  5033     MOVF 0x33, W, ACCESS
15416  ECC0     CALL 0x14D80, 0
15418  F0A6     NOP
1541A  C50E     MOVFF evNum, eventNumber
1541C  F536     NOP
1541E  C50F     MOVFF interruptEnabled, tableIndex
15420  F537     NOP
435:               if (eventNumber.word != 0) {
15422  5036     MOVF 0x36, W, ACCESS
15424  1037     IORWF 0x37, W, ACCESS
15426  B4D8     BTFSC 0xFD8, 2, ACCESS
15428  D01A     BRA 0x545E
436:                   nodeNumber.word = getNN(step);
1542A  5033     MOVF 0x33, W, ACCESS
1542C  EC9A     CALL 0x13F34, 0
1542E  F09F     NOP
15430  C50E     MOVFF evNum, nodeNumber
15432  F534     NOP
15434  C50F     MOVFF interruptEnabled, error
15436  F535     NOP
437:                   sendMessage7(OPC_ENRSP, nn.bytes.hi, nn.bytes.lo, nodeNumber.bytes.hi, nodeNumber.bytes.lo, eventNumber.bytes.hi, eventNumber.bytes.lo, tableIndexToEvtIdx(step));
15438  C554     MOVFF 0x554, data1
1543A  F525     NOP
1543C  C553     MOVFF nn, data2
1543E  F526     NOP
15440  C535     MOVFF error, data3
15442  F527     NOP
15444  C534     MOVFF nodeNumber, data4
15446  F528     NOP
15448  C537     MOVFF tableIndex, data5
1544A  F529     NOP
1544C  C536     MOVFF eventNumber, data6
1544E  F52A     NOP
15450  5033     MOVF 0x33, W, ACCESS
15452  EC42     CALL 0x16284, 0
15454  F0B1     NOP
15456  6E2B     MOVWF 0x2B, ACCESS
15458  0EF2     MOVLW 0xF2
1545A  EC68     CALL 0x15ED0, 0
1545C  F0AF     NOP
438:               }
439:           
440:               return TIMED_RESPONSE_RESULT_NEXT;
1545E  0E02     MOVLW 0x2
441:           }
15460  0012     RETURN 0
442:           
443:           
444:           /**
445:            * Read a single stored event by index and return a ENRSP response.
446:            * 
447:            * @param index index into event table
448:            */
449:           static void doNenrd(uint8_t index) {
149EA  6E2B     MOVWF 0x2B, ACCESS
450:               uint8_t tableIndex;
451:               uint16_t nodeNumber, eventNumber;
452:               
453:               tableIndex = evtIdxToTableIndex(index);
149EC  502B     MOVF 0x2B, W, ACCESS
149EE  EC3F     CALL 0x1627E, 0
149F0  F0B1     NOP
149F2  6E30     MOVWF 0x30, ACCESS
454:               // check this is a valid index
455:               if (tableIndex >= NUM_EVENTS) {
149F4  0EFD     MOVLW 0xFD
149F6  6430     CPFSGT 0x30, ACCESS
149F8  D017     BRA 0x4A28
456:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_EN_IDX);
149FA  C554     MOVFF 0x554, data1
149FC  F525     NOP
149FE  C553     MOVFF nn, data2
14A00  F526     NOP
14A02  0E08     MOVLW 0x8
14A04  6E27     MOVWF 0x27, ACCESS
14A06  0E6F     MOVLW 0x6F
14A08  EC3E     CALL 0x15E7C, 0
14A0A  F0AF     NOP
457:           #ifdef VLCB_GRSP
458:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NENRD, SERVICE_ID_OLD_TEACH, CMDERR_INV_EN_IDX);
14A0C  C554     MOVFF 0x554, data1
14A0E  F525     NOP
14A10  C553     MOVFF nn, data2
14A12  F526     NOP
14A14  0E72     MOVLW 0x72
14A16  6E27     MOVWF 0x27, ACCESS
14A18  0E04     MOVLW 0x4
14A1A  6E28     MOVWF 0x28, ACCESS
14A1C  0E08     MOVLW 0x8
14A1E  6E29     MOVWF 0x29, ACCESS
14A20  0EAF     MOVLW 0xAF
14A22  EC7D     CALL 0x15EFA, 0
14A24  F0AF     NOP
14A26  0012     RETURN 0
459:           #endif
460:                   return;
461:               }
462:               nodeNumber = getNN(tableIndex);
14A28  5030     MOVF 0x30, W, ACCESS
14A2A  EC9A     CALL 0x13F34, 0
14A2C  F09F     NOP
14A2E  C50E     MOVFF evNum, opc
14A30  F52C     NOP
14A32  C50F     MOVFF interruptEnabled, needed
14A34  F52D     NOP
463:               eventNumber = getEN(tableIndex);
14A36  5030     MOVF 0x30, W, ACCESS
14A38  ECC0     CALL 0x14D80, 0
14A3A  F0A6     NOP
14A3C  C50E     MOVFF evNum, service
14A3E  F52E     NOP
14A40  C50F     MOVFF interruptEnabled, tableIndex
14A42  F52F     NOP
464:               sendMessage5(OPC_ENRSP, nodeNumber>>8, nodeNumber&0xFF, eventNumber>>8, eventNumber&0xFF, index);
14A44  502D     MOVF 0x2D, W, ACCESS
14A46  6E25     MOVWF 0x25, ACCESS
14A48  C52C     MOVFF opc, data2
14A4A  F526     NOP
14A4C  502F     MOVF 0x2F, W, ACCESS
14A4E  6E27     MOVWF 0x27, ACCESS
14A50  C52E     MOVFF service, data4
14A52  F528     NOP
14A54  C52B     MOVFF opc, data5
14A56  F529     NOP
14A58  0EF2     MOVLW 0xF2
14A5A  EC7D     CALL 0x15EFA, 0
14A5C  F0AF     NOP
465:           
466:           } // doNenrd
14A5E  0012     RETURN 0
467:           
468:           /**
469:            * Read number of stored events.
470:            * This returns the number of events which is different to the number of used slots 
471:            * in the Event table.
472:            */
473:           static void doRqevn(void) {
474:               // Count the number of used slots.
475:               uint8_t count = 0;
15AFE  0E00     MOVLW 0x0
15B00  6E2B     MOVWF 0x2B, ACCESS
476:               uint8_t i;
477:               for (i=0; i<NUM_EVENTS; i++) {
15B02  0E00     MOVLW 0x0
15B04  6E2C     MOVWF 0x2C, ACCESS
478:                   uint16_t eventNumber;
479:                   eventNumber = getEN(i);
15B06  502C     MOVF 0x2C, W, ACCESS
15B08  ECC0     CALL 0x14D80, 0
15B0A  F0A6     NOP
15B0C  C50E     MOVFF evNum, data5
15B0E  F529     NOP
15B10  C50F     MOVFF interruptEnabled, data6
15B12  F52A     NOP
480:                   if (eventNumber != 0) {
15B14  5029     MOVF 0x29, W, ACCESS
15B16  102A     IORWF 0x2A, W, ACCESS
15B18  A4D8     BTFSS 0xFD8, 2, ACCESS
481:                       count++;
15B1A  2A2B     INCF 0x2B, F, ACCESS
482:                   }
483:               }
15B1C  2A2C     INCF 0x2C, F, ACCESS
15B1E  0EFD     MOVLW 0xFD
15B20  642C     CPFSGT 0x2C, ACCESS
15B22  D7F1     BRA 0x5B06
484:               sendMessage3(OPC_NUMEV, nn.bytes.hi, nn.bytes.lo, count);
15B24  C554     MOVFF 0x554, data1
15B26  F525     NOP
15B28  C553     MOVFF nn, data2
15B2A  F526     NOP
15B2C  C52B     MOVFF opc, data3
15B2E  F527     NOP
15B30  0E74     MOVLW 0x74
15B32  EC3E     CALL 0x15E7C, 0
15B34  F0AF     NOP
485:           } // doRqevn
15B36  0012     RETURN 0
486:           
487:           /**
488:            * Clear all Events.
489:            */
490:           static void doNnclr(void) {
491:               clearAllEvents();
15D46  ECF8     CALL 0x161F0, 0
15D48  F0B0     NOP
492:               sendMessage2(OPC_WRACK, nn.bytes.hi, nn.bytes.lo);
15D4A  C554     MOVFF 0x554, data1
15D4C  F525     NOP
15D4E  C553     MOVFF nn, data2
15D50  F526     NOP
15D52  0E59     MOVLW 0x59
15D54  EC53     CALL 0x15EA6, 0
15D56  F0AF     NOP
493:           #ifdef VLCB_GRSP
494:               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_NNCLR, SERVICE_ID_OLD_TEACH, GRSP_OK);
15D58  C554     MOVFF 0x554, data1
15D5A  F525     NOP
15D5C  C553     MOVFF nn, data2
15D5E  F526     NOP
15D60  0E55     MOVLW 0x55
15D62  6E27     MOVWF 0x27, ACCESS
15D64  0E04     MOVLW 0x4
15D66  6E28     MOVWF 0x28, ACCESS
15D68  0E00     MOVLW 0x0
15D6A  6E29     MOVWF 0x29, ACCESS
15D6C  0EAF     MOVLW 0xAF
15D6E  EC7D     CALL 0x15EFA, 0
15D70  F0AF     NOP
495:           #endif
496:           } //doNnclr
15D72  0012     RETURN 0
497:           
498:           /**
499:            * Teach event whilst in learn mode.
500:            * Teach or reteach an event associated with an action. 
501:           
502:            * @param nodeNumber event's NN
503:            * @param eventNumber the EN
504:            * @param evNum the EV number
505:            * @param evVal the EV value
506:            */
507:           static void doEvlrn(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum, uint8_t evVal) {
508:               uint8_t error;
509:               evNum--;    // convert VLCB message numbering (starts at 1) to internal numbering)
13E78  0643     DECF NVMADR, F, ACCESS
510:               if (evNum >= PARAM_NUM_EV_EVENT) {
13E7A  0E0C     MOVLW 0xC
13E7C  6443     CPFSGT NVMADR, ACCESS
13E7E  D017     BRA 0x3EAE
511:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_EV_IDX);
13E80  C554     MOVFF 0x554, data1
13E82  F525     NOP
13E84  C553     MOVFF nn, data2
13E86  F526     NOP
13E88  0E06     MOVLW 0x6
13E8A  6E27     MOVWF 0x27, ACCESS
13E8C  0E6F     MOVLW 0x6F
13E8E  EC3E     CALL 0x15E7C, 0
13E90  F0AF     NOP
512:           #ifdef VLCB_GRSP
513:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVLRN, SERVICE_ID_OLD_TEACH, CMDERR_INV_EV_IDX);
13E92  C554     MOVFF 0x554, data1
13E94  F525     NOP
13E96  C553     MOVFF nn, data2
13E98  F526     NOP
13E9A  0ED2     MOVLW 0xD2
13E9C  6E27     MOVWF 0x27, ACCESS
13E9E  0E04     MOVLW 0x4
13EA0  6E28     MOVWF 0x28, ACCESS
13EA2  0E06     MOVLW 0x6
13EA4  6E29     MOVWF 0x29, ACCESS
13EA6  0EAF     MOVLW 0xAF
13EA8  EC7D     CALL 0x15EFA, 0
13EAA  F0AF     NOP
13EAC  0012     RETURN 0
514:           #endif
515:                   return;
516:               }
517:               error = APP_addEvent(nodeNumber, eventNumber, evNum, evVal, FALSE);
13EAE  C53F     MOVFF nodeNumber, nodeNumber
13EB0  F538     NOP
13EB2  C540     MOVFF tableIndex, nEv
13EB4  F539     NOP
13EB6  C541     MOVFF eventNumber, ev
13EB8  F53A     NOP
13EBA  C542     MOVFF 0x542, buttonNo
13EBC  F53B     NOP
13EBE  C543     MOVFF evNum, nodeNumber
13EC0  F53C     NOP
13EC2  C544     MOVFF evVal, i
13EC4  F53D     NOP
13EC6  0E00     MOVLW 0x0
13EC8  6E3E     MOVWF 0x3E, ACCESS
13ECA  EC5F     CALL 0x160BE, 0
13ECC  F0B0     NOP
13ECE  6E45     MOVWF NVMADRU, ACCESS
518:               if (error) {
13ED0  5045     MOVF NVMADRU, W, ACCESS
13ED2  B4D8     BTFSC 0xFD8, 2, ACCESS
13ED4  D017     BRA 0x3F04
519:                   // validation error
520:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, error);
13ED6  C554     MOVFF 0x554, data1
13ED8  F525     NOP
13EDA  C553     MOVFF nn, data2
13EDC  F526     NOP
13EDE  C545     MOVFF error, data3
13EE0  F527     NOP
13EE2  0E6F     MOVLW 0x6F
13EE4  EC3E     CALL 0x15E7C, 0
13EE6  F0AF     NOP
521:           #ifdef VLCB_GRSP
522:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVLRN, SERVICE_ID_OLD_TEACH, error);
13EE8  C554     MOVFF 0x554, data1
13EEA  F525     NOP
13EEC  C553     MOVFF nn, data2
13EEE  F526     NOP
13EF0  0ED2     MOVLW 0xD2
13EF2  6E27     MOVWF 0x27, ACCESS
13EF4  0E04     MOVLW 0x4
13EF6  6E28     MOVWF 0x28, ACCESS
13EF8  C545     MOVFF error, data5
13EFA  F529     NOP
13EFC  0EAF     MOVLW 0xAF
13EFE  EC7D     CALL 0x15EFA, 0
13F00  F0AF     NOP
13F02  0012     RETURN 0
523:           #endif
524:                   return;
525:               }
526:           #ifdef VLCB_DIAG
527:               teachDiagnostics[TEACH_DIAG_NUM_TEACH].asUint++;
13F04  0105     MOVLB 0x5
13F06  4BD6     INFSNZ CLCnCON, F, BANKED
13F08  2BD7     INCF CLCnPOL, F, BANKED
528:           #endif
529:               sendMessage2(OPC_WRACK, nn.bytes.hi, nn.bytes.lo);
13F0A  C554     MOVFF 0x554, data1
13F0C  F525     NOP
13F0E  C553     MOVFF nn, data2
13F10  F526     NOP
13F12  0E59     MOVLW 0x59
13F14  EC53     CALL 0x15EA6, 0
13F16  F0AF     NOP
530:           #ifdef VLCB_GRSP
531:               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVLRN, SERVICE_ID_OLD_TEACH, GRSP_OK);
13F18  C554     MOVFF 0x554, data1
13F1A  F525     NOP
13F1C  C553     MOVFF nn, data2
13F1E  F526     NOP
13F20  0ED2     MOVLW 0xD2
13F22  6E27     MOVWF 0x27, ACCESS
13F24  0E04     MOVLW 0x4
13F26  6E28     MOVWF 0x28, ACCESS
13F28  0E00     MOVLW 0x0
13F2A  6E29     MOVWF 0x29, ACCESS
13F2C  0EAF     MOVLW 0xAF
13F2E  EC7D     CALL 0x15EFA, 0
13F30  F0AF     NOP
532:           #endif
533:               return;
534:           }
13F32  0012     RETURN 0
535:           
536:           /**
537:            * Read an event variable by index.
538:            * 
539:            * @param enNum index into event table
540:            * @param evNum EV number index
541:            */
542:           static void doReval(uint8_t enNum, uint8_t evNum) {
141E6  6E2E     MOVWF 0x2E, ACCESS
543:           	// Get event index and event variable number from message
544:           	// Send response with EV value
545:               uint8_t evIndex;
546:               uint8_t tableIndex = evtIdxToTableIndex(enNum);
141E8  502E     MOVF 0x2E, W, ACCESS
141EA  EC3F     CALL 0x1627E, 0
141EC  F0B1     NOP
141EE  6E2F     MOVWF 0x2F, ACCESS
547:               int evVal;
548:               
549:               if (tableIndex >= NUM_EVENTS) {
141F0  0EFD     MOVLW 0xFD
141F2  642F     CPFSGT 0x2F, ACCESS
141F4  D00A     BRA 0x420A
550:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_EV_IDX);
141F6  C554     MOVFF 0x554, data1
141F8  F525     NOP
141FA  C553     MOVFF nn, data2
141FC  F526     NOP
141FE  0E06     MOVLW 0x6
14200  6E27     MOVWF 0x27, ACCESS
14202  0E6F     MOVLW 0x6F
14204  EC3E     CALL 0x15E7C, 0
14206  F0AF     NOP
14208  0012     RETURN 0
551:                   return;
552:               }
553:           
554:               evIndex = evNum-1U;    // Convert from CBUS numbering (starts at 1 for produced action))
1420A  042B     DECF 0x2B, W, ACCESS
1420C  6E2D     MOVWF 0x2D, ACCESS
555:               if (evNum == 0) {
1420E  502B     MOVF 0x2B, W, ACCESS
14210  A4D8     BTFSS 0xFD8, 2, ACCESS
14212  D008     BRA 0x4224
556:                   evVal = numEv(tableIndex);
14214  502F     MOVF 0x2F, W, ACCESS
14216  EC4B     CALL 0x16296, 0
14218  F0B1     NOP
1421A  6E2C     MOVWF 0x2C, ACCESS
1421C  502C     MOVF 0x2C, W, ACCESS
1421E  6E30     MOVWF 0x30, ACCESS
14220  6A31     CLRF 0x31, ACCESS
557:               } else {
14222  D009     BRA 0x4236
558:                   evVal = getEv(tableIndex, evIndex);
14224  C52D     MOVFF needed, evNum
14226  F50E     NOP
14228  502F     MOVF 0x2F, W, ACCESS
1422A  ECCF     CALL 0x14F9E, 0
1422C  F0A7     NOP
1422E  C50E     MOVFF evNum, m
14230  F530     NOP
14232  C50F     MOVFF interruptEnabled, evVal
14234  F531     NOP
559:               }
560:               if (evVal < 0) {
14236  AE31     BTFSS 0x31, 7, ACCESS
14238  D019     BRA 0x426C
561:                   // a negative value is the error code
562:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(-evVal));
1423A  C554     MOVFF 0x554, data1
1423C  F525     NOP
1423E  C553     MOVFF nn, data2
14240  F526     NOP
14242  5030     MOVF 0x30, W, ACCESS
14244  0800     SUBLW 0x0
14246  6E27     MOVWF 0x27, ACCESS
14248  0E6F     MOVLW 0x6F
1424A  EC3E     CALL 0x15E7C, 0
1424C  F0AF     NOP
563:           #ifdef VLCB_GRSP
564:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_REVAL, SERVICE_ID_OLD_TEACH, (uint8_t)(-evVal));
1424E  C554     MOVFF 0x554, data1
14250  F525     NOP
14252  C553     MOVFF nn, data2
14254  F526     NOP
14256  0E9C     MOVLW 0x9C
14258  6E27     MOVWF 0x27, ACCESS
1425A  0E04     MOVLW 0x4
1425C  6E28     MOVWF 0x28, ACCESS
1425E  5030     MOVF 0x30, W, ACCESS
14260  0800     SUBLW 0x0
14262  6E29     MOVWF 0x29, ACCESS
14264  0EAF     MOVLW 0xAF
14266  EC7D     CALL 0x15EFA, 0
14268  F0AF     NOP
1426A  0012     RETURN 0
565:           #endif
566:                   return;
567:               }
568:               sendMessage5(OPC_NEVAL, nn.bytes.hi, nn.bytes.lo, enNum, evNum, (uint8_t)evVal);            
1426C  C554     MOVFF 0x554, data1
1426E  F525     NOP
14270  C553     MOVFF nn, data2
14272  F526     NOP
14274  C52E     MOVFF service, data3
14276  F527     NOP
14278  C52B     MOVFF opc, data4
1427A  F528     NOP
1427C  C530     MOVFF m, data5
1427E  F529     NOP
14280  0EB5     MOVLW 0xB5
14282  EC7D     CALL 0x15EFA, 0
14284  F0AF     NOP
569:           } // doReval
14286  0012     RETURN 0
570:           
571:           /**
572:            * Unlearn event.
573:            * @param nodeNumber Event NN
574:            * @param eventNumber Event EN
575:            */
576:           static void doEvuln(uint16_t nodeNumber, uint16_t eventNumber) {
577:               uint8_t result;
578:               result = removeEvent(nodeNumber, eventNumber);
14AD6  C52B     MOVFF opc, data5
14AD8  F521     NOP
14ADA  C52C     MOVFF opc, data6
14ADC  F522     NOP
14ADE  C52D     MOVFF needed, data7
14AE0  F523     NOP
14AE2  C52E     MOVFF service, opc
14AE4  F524     NOP
14AE6  ECA7     CALL 0x15F4E, 0
14AE8  F0AF     NOP
14AEA  6E2F     MOVWF 0x2F, ACCESS
579:               if (result) {
14AEC  502F     MOVF 0x2F, W, ACCESS
14AEE  B4D8     BTFSC 0xFD8, 2, ACCESS
14AF0  D017     BRA 0x4B20
580:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, result);
14AF2  C554     MOVFF 0x554, data1
14AF4  F525     NOP
14AF6  C553     MOVFF nn, data2
14AF8  F526     NOP
14AFA  C52F     MOVFF tableIndex, data3
14AFC  F527     NOP
14AFE  0E6F     MOVLW 0x6F
14B00  EC3E     CALL 0x15E7C, 0
14B02  F0AF     NOP
581:           #ifdef VLCB_GRSP
582:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVULN, SERVICE_ID_OLD_TEACH, result);
14B04  C554     MOVFF 0x554, data1
14B06  F525     NOP
14B08  C553     MOVFF nn, data2
14B0A  F526     NOP
14B0C  0E95     MOVLW 0x95
14B0E  6E27     MOVWF 0x27, ACCESS
14B10  0E04     MOVLW 0x4
14B12  6E28     MOVWF 0x28, ACCESS
14B14  C52F     MOVFF tableIndex, data5
14B16  F529     NOP
14B18  0EAF     MOVLW 0xAF
14B1A  EC7D     CALL 0x15EFA, 0
14B1C  F0AF     NOP
14B1E  0012     RETURN 0
583:           #endif
584:                   return;
585:               }
586:               // Send a WRACK - difference from CBUS
587:               sendMessage2(OPC_WRACK, nn.bytes.hi, nn.bytes.lo);
14B20  C554     MOVFF 0x554, data1
14B22  F525     NOP
14B24  C553     MOVFF nn, data2
14B26  F526     NOP
14B28  0E59     MOVLW 0x59
14B2A  EC53     CALL 0x15EA6, 0
14B2C  F0AF     NOP
588:           #ifdef VLCB_GRSP
589:               sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_EVULN, SERVICE_ID_OLD_TEACH, GRSP_OK);
14B2E  C554     MOVFF 0x554, data1
14B30  F525     NOP
14B32  C553     MOVFF nn, data2
14B34  F526     NOP
14B36  0E95     MOVLW 0x95
14B38  6E27     MOVWF 0x27, ACCESS
14B3A  0E04     MOVLW 0x4
14B3C  6E28     MOVWF 0x28, ACCESS
14B3E  0E00     MOVLW 0x0
14B40  6E29     MOVWF 0x29, ACCESS
14B42  0EAF     MOVLW 0xAF
14B44  EC7D     CALL 0x15EFA, 0
14B46  F0AF     NOP
590:           #endif
591:           }
14B48  0012     RETURN 0
592:           
593:           /**
594:            * Read an event variable by event id.
595:            * @param nodeNumber Event NN
596:            * @param eventNumber Event EN
597:            * @param evNum EV number/index
598:            */
599:           static void doReqev(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum) {
600:               int16_t evVal;
601:               // get the event
602:               uint8_t tableIndex = findEvent(nodeNumber, eventNumber);
13350  C52C     MOVFF opc, tableIndex
13352  F519     NOP
13354  C52D     MOVFF needed, txFifoObj
13356  F51A     NOP
13358  C52E     MOVFF service, eventNumber
1335A  F51B     NOP
1335C  C52F     MOVFF tableIndex, len
1335E  F51C     NOP
13360  ECA5     CALL 0x1574A, 0
13362  F0AB     NOP
13364  6E33     MOVWF 0x33, ACCESS
603:               if (tableIndex == NO_INDEX) {
13366  2833     INCF 0x33, W, ACCESS
13368  A4D8     BTFSS 0xFD8, 2, ACCESS
1336A  D017     BRA 0x339A
604:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INVALID_EVENT);
1336C  C554     MOVFF 0x554, data1
1336E  F525     NOP
13370  C553     MOVFF nn, data2
13372  F526     NOP
13374  0E07     MOVLW 0x7
13376  6E27     MOVWF 0x27, ACCESS
13378  0E6F     MOVLW 0x6F
1337A  EC3E     CALL 0x15E7C, 0
1337C  F0AF     NOP
605:           #ifdef VLCB_GRSP
606:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_REQEV, SERVICE_ID_OLD_TEACH, CMDERR_INVALID_EVENT);
1337E  C554     MOVFF 0x554, data1
13380  F525     NOP
13382  C553     MOVFF nn, data2
13384  F526     NOP
13386  0EB2     MOVLW 0xB2
13388  6E27     MOVWF 0x27, ACCESS
1338A  0E04     MOVLW 0x4
1338C  6E28     MOVWF 0x28, ACCESS
1338E  0E07     MOVLW 0x7
13390  6E29     MOVWF 0x29, ACCESS
13392  0EAF     MOVLW 0xAF
13394  EC7D     CALL 0x15EFA, 0
13396  F0AF     NOP
13398  0012     RETURN 0
607:           #endif
608:                   return;
609:               }
610:               if (evNum > PARAM_NUM_EV_EVENT) {
1339A  0E0D     MOVLW 0xD
1339C  6430     CPFSGT 0x30, ACCESS
1339E  D017     BRA 0x33CE
611:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_EV_IDX);
133A0  C554     MOVFF 0x554, data1
133A2  F525     NOP
133A4  C553     MOVFF nn, data2
133A6  F526     NOP
133A8  0E06     MOVLW 0x6
133AA  6E27     MOVWF 0x27, ACCESS
133AC  0E6F     MOVLW 0x6F
133AE  EC3E     CALL 0x15E7C, 0
133B0  F0AF     NOP
612:           #ifdef VLCB_GRSP
613:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_REQEV, SERVICE_ID_OLD_TEACH, CMDERR_INV_EV_IDX);
133B2  C554     MOVFF 0x554, data1
133B4  F525     NOP
133B6  C553     MOVFF nn, data2
133B8  F526     NOP
133BA  0EB2     MOVLW 0xB2
133BC  6E27     MOVWF 0x27, ACCESS
133BE  0E04     MOVLW 0x4
133C0  6E28     MOVWF 0x28, ACCESS
133C2  0E06     MOVLW 0x6
133C4  6E29     MOVWF 0x29, ACCESS
133C6  0EAF     MOVLW 0xAF
133C8  EC7D     CALL 0x15EFA, 0
133CA  F0AF     NOP
133CC  0012     RETURN 0
614:           #endif
615:                   return;
616:               }
617:               if (evNum == 0) {
133CE  5030     MOVF 0x30, W, ACCESS
133D0  A4D8     BTFSS 0xFD8, 2, ACCESS
133D2  D01F     BRA 0x3412
618:           #ifdef VLCB_ZERO_RESPONSES
619:                   sendMessage6(OPC_EVANS, nodeNumber>>8, nodeNumber&0xFF, eventNumber>>8, eventNumber&0xFF, 0, numEv(tableIndex));
133D4  502D     MOVF 0x2D, W, ACCESS
133D6  6E25     MOVWF 0x25, ACCESS
133D8  C52C     MOVFF opc, data2
133DA  F526     NOP
133DC  502F     MOVF 0x2F, W, ACCESS
133DE  6E27     MOVWF 0x27, ACCESS
133E0  C52E     MOVFF service, data4
133E2  F528     NOP
133E4  0E00     MOVLW 0x0
133E6  6E29     MOVWF 0x29, ACCESS
133E8  5033     MOVF 0x33, W, ACCESS
133EA  EC4B     CALL 0x16296, 0
133EC  F0B1     NOP
133EE  6E2A     MOVWF 0x2A, ACCESS
133F0  0ED3     MOVLW 0xD3
133F2  EC29     CALL 0x15E52, 0
133F4  F0AF     NOP
620:                   // send all of the EVs
621:                   // Note this somewhat abuses the type parameter
622:                   startTimedResponse(tableIndex, findServiceIndex(SERVICE_ID_OLD_TEACH), reqevCallback);
133F6  0E04     MOVLW 0x4
133F8  EC18     CALL 0x14C30, 0
133FA  F0A6     NOP
133FC  6E06     MOVWF 0x6, ACCESS
133FE  0ED2     MOVLW 0xD2
13400  6E07     MOVWF 0x7, ACCESS
13402  0E44     MOVLW 0x44
13404  6E08     MOVWF 0x8, ACCESS
13406  0E01     MOVLW 0x1
13408  6E09     MOVWF 0x9, ACCESS
1340A  5033     MOVF 0x33, W, ACCESS
1340C  ECE2     CALL 0x159C4, 0
1340E  F0AC     NOP
13410  0012     RETURN 0
623:                   return;
624:           #else
625:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_EV_IDX);
626:                   return;
627:           #endif
628:               } else {
629:                   evVal = getEv(tableIndex, evNum-1);
13412  0430     DECF 0x30, W, ACCESS
13414  6E0E     MOVWF 0xE, ACCESS
13416  5033     MOVF 0x33, W, ACCESS
13418  ECCF     CALL 0x14F9E, 0
1341A  F0A7     NOP
1341C  C50E     MOVFF evNum, evVal
1341E  F531     NOP
13420  C50F     MOVFF interruptEnabled, needed
13422  F532     NOP
630:               }
631:               if (evVal < 0) {
13424  AE32     BTFSS 0x32, 7, ACCESS
13426  D019     BRA 0x345A
632:                   // a negative value is the error code
633:                   sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, (uint8_t)(-evVal));
13428  C554     MOVFF 0x554, data1
1342A  F525     NOP
1342C  C553     MOVFF nn, data2
1342E  F526     NOP
13430  5031     MOVF 0x31, W, ACCESS
13432  0800     SUBLW 0x0
13434  6E27     MOVWF 0x27, ACCESS
13436  0E6F     MOVLW 0x6F
13438  EC3E     CALL 0x15E7C, 0
1343A  F0AF     NOP
634:           #ifdef VLCB_GRSP
635:                   sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_REQEV, SERVICE_ID_OLD_TEACH, (uint8_t)(-evVal));
1343C  C554     MOVFF 0x554, data1
1343E  F525     NOP
13440  C553     MOVFF nn, data2
13442  F526     NOP
13444  0EB2     MOVLW 0xB2
13446  6E27     MOVWF 0x27, ACCESS
13448  0E04     MOVLW 0x4
1344A  6E28     MOVWF 0x28, ACCESS
1344C  5031     MOVF 0x31, W, ACCESS
1344E  0800     SUBLW 0x0
13450  6E29     MOVWF 0x29, ACCESS
13452  0EAF     MOVLW 0xAF
13454  EC7D     CALL 0x15EFA, 0
13456  F0AF     NOP
13458  0012     RETURN 0
636:           #endif
637:                   return;
638:               }
639:           
640:               sendMessage6(OPC_EVANS, nodeNumber>>8, nodeNumber&0xFF, eventNumber>>8, eventNumber&0xFF, evNum, (uint8_t)evVal);
1345A  502D     MOVF 0x2D, W, ACCESS
1345C  6E25     MOVWF 0x25, ACCESS
1345E  C52C     MOVFF opc, data2
13460  F526     NOP
13462  502F     MOVF 0x2F, W, ACCESS
13464  6E27     MOVWF 0x27, ACCESS
13466  C52E     MOVFF service, data4
13468  F528     NOP
1346A  C530     MOVFF m, data5
1346C  F529     NOP
1346E  C531     MOVFF evVal, data6
13470  F52A     NOP
13472  0ED3     MOVLW 0xD3
13474  EC29     CALL 0x15E52, 0
13476  F0AF     NOP
641:               return;
642:           }
13478  0012     RETURN 0
643:           /**
644:            * The callback to do the REQEV responses.
645:            * @param tableIndex the index of the event in the eventTable
646:            * @param serviceIndex the service
647:            * @param step how far through the processing, considered to be an EV#-1
648:            * @return whether to finish or continue processing
649:            */
650:           TimedResponseResult reqevCallback(uint8_t tableIndex, uint8_t serviceIndex, uint8_t step){
144D2  6E40     MOVWF NVMCON0, ACCESS
651:               Word nodeNumber, eventNumber;
652:           
653:               uint8_t nEv = numEv(tableIndex);
144D4  5040     MOVF NVMCON0, W, ACCESS
144D6  EC4B     CALL 0x16296, 0
144D8  F0B1     NOP
144DA  6E39     MOVWF CLKRCON, ACCESS
654:               int16_t ev;
655:               // The step is used to index through the event table
656:               if (step+1 > nEv) {  // finished?
144DC  5033     MOVF 0x33, W, ACCESS
144DE  6E34     MOVWF 0x34, ACCESS
144E0  6A35     CLRF 0x35, ACCESS
144E2  0E01     MOVLW 0x1
144E4  2634     ADDWF 0x34, F, ACCESS
144E6  0E00     MOVLW 0x0
144E8  2235     ADDWFC 0x35, F, ACCESS
144EA  5039     MOVF CLKRCON, W, ACCESS
144EC  6E36     MOVWF 0x36, ACCESS
144EE  6A37     CLRF 0x37, ACCESS
144F0  5034     MOVF 0x34, W, ACCESS
144F2  5C36     SUBWF 0x36, W, ACCESS
144F4  5037     MOVF 0x37, W, ACCESS
144F6  0A80     XORLW 0x80
144F8  6E38     MOVWF BOOTREG, ACCESS
144FA  5035     MOVF 0x35, W, ACCESS
144FC  0A80     XORLW 0x80
144FE  5838     SUBWFB BOOTREG, W, ACCESS
14500  B0D8     BTFSC 0xFD8, 0, ACCESS
14502  D002     BRA 0x4508
657:                   return TIMED_RESPONSE_RESULT_FINISHED;
14504  0E00     MOVLW 0x0
14506  0012     RETURN 0
658:               }
659:               // if its not free and not a continuation then it is start of an event
660:               nodeNumber.word = getNN(tableIndex);
14508  5040     MOVF NVMCON0, W, ACCESS
1450A  EC9A     CALL 0x13F34, 0
1450C  F09F     NOP
1450E  C50E     MOVFF evNum, nodeNumber
14510  F53C     NOP
14512  C50F     MOVFF interruptEnabled, i
14514  F53D     NOP
661:               eventNumber.word = getEN(tableIndex);
14516  5040     MOVF NVMCON0, W, ACCESS
14518  ECC0     CALL 0x14D80, 0
1451A  F0A6     NOP
1451C  C50E     MOVFF evNum, i
1451E  F53E     NOP
14520  C50F     MOVFF interruptEnabled, nodeNumber
14522  F53F     NOP
662:               ev = getEv(tableIndex, step);
14524  C533     MOVFF learn, evNum
14526  F50E     NOP
14528  5040     MOVF NVMCON0, W, ACCESS
1452A  ECCF     CALL 0x14F9E, 0
1452C  F0A7     NOP
1452E  C50E     MOVFF evNum, ev
14530  F53A     NOP
14532  C50F     MOVFF interruptEnabled, buttonNo
14534  F53B     NOP
663:               if (ev >= 0) {
14536  BE3B     BTFSC 0x3B, 7, ACCESS
14538  D00F     BRA 0x4558
664:                   sendMessage6(OPC_EVANS, nodeNumber.bytes.hi, nodeNumber.bytes.lo, eventNumber.bytes.hi, eventNumber.bytes.lo, step+1, (uint8_t)ev);
1453A  C53D     MOVFF i, data1
1453C  F525     NOP
1453E  C53C     MOVFF nodeNumber, data2
14540  F526     NOP
14542  C53F     MOVFF nodeNumber, data3
14544  F527     NOP
14546  C53E     MOVFF i, data4
14548  F528     NOP
1454A  2833     INCF 0x33, W, ACCESS
1454C  6E29     MOVWF 0x29, ACCESS
1454E  C53A     MOVFF ev, data6
14550  F52A     NOP
14552  0ED3     MOVLW 0xD3
14554  EC29     CALL 0x15E52, 0
14556  F0AF     NOP
665:               }
666:               return TIMED_RESPONSE_RESULT_NEXT;
14558  0E02     MOVLW 0x2
667:           }
1455A  0012     RETURN 0
668:           
669:           
670:           /**
671:            * Remove event.
672:            * 
673:            * @param nodeNumber Event NN
674:            * @param eventNumber Event EN
675:            * @return error or 0 for success
676:            */
677:           uint8_t removeEvent(uint16_t nodeNumber, uint16_t eventNumber) {
678:               // need to delete this action from the Event table. 
679:               uint8_t tableIndex = findEvent(nodeNumber, eventNumber);
15F4E  C521     MOVFF data5, tableIndex
15F50  F519     NOP
15F52  C522     MOVFF data6, txFifoObj
15F54  F51A     NOP
15F56  C523     MOVFF data7, eventNumber
15F58  F51B     NOP
15F5A  C524     MOVFF opc, len
15F5C  F51C     NOP
15F5E  ECA5     CALL 0x1574A, 0
15F60  F0AB     NOP
15F62  6E25     MOVWF 0x25, ACCESS
680:               if (tableIndex == NO_INDEX) return CMDERR_INVALID_EVENT; // not found
15F64  2825     INCF 0x25, W, ACCESS
15F66  A4D8     BTFSS 0xFD8, 2, ACCESS
15F68  D002     BRA 0x5F6E
15F6A  0E07     MOVLW 0x7
15F6C  0012     RETURN 0
681:               // found the event to delete
682:               return removeTableEntry(tableIndex);
15F6E  5025     MOVF 0x25, W, ACCESS
15F70  EC77     CALL 0x130EE, 0
15F72  F098     NOP
683:           }
15F74  0012     RETURN 0
684:           
685:           /**
686:            * Remove an event from the event table clearing any continuation entries.
687:            * @param tableIndex which event to be cleared
688:            * @return error or 0 for success
689:            */
690:           static uint8_t removeTableEntry(uint8_t tableIndex) {
130EE  6E20     MOVWF 0x20, ACCESS
691:               uint8_t i;
692:           #ifdef SAFETY
693:               if (tableIndex >= NUM_EVENTS) return CMDERR_INV_EV_IDX;
694:           #endif
695:               // set the NN and EN to zero
696:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + EVENTTABLE_OFFSET_NNH, 0x00);
130F0  5020     MOVF 0x20, W, ACCESS
130F2  0D12     MULLW 0x12
130F4  C4F3     MOVFF PROD, tableIndex
130F6  F517     NOP
130F8  C4F4     MOVFF PRODH, evIdx
130FA  F518     NOP
130FC  6A19     CLRF 0x19, ACCESS
130FE  0E00     MOVLW 0x0
13100  2417     ADDWF 0x17, W, ACCESS
13102  6E10     MOVWF 0x10, ACCESS
13104  0EE8     MOVLW 0xE8
13106  2018     ADDWFC 0x18, W, ACCESS
13108  6E11     MOVWF 0x11, ACCESS
1310A  0E01     MOVLW 0x1
1310C  2019     ADDWFC 0x19, W, ACCESS
1310E  6E12     MOVWF 0x12, ACCESS
13110  0E00     MOVLW 0x0
13112  6E13     MOVWF 0x13, ACCESS
13114  0E01     MOVLW 0x1
13116  EC7E     CALL 0x156FC, 0
13118  F0AB     NOP
697:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + EVENTTABLE_OFFSET_NNL, 0x00);
1311A  5020     MOVF 0x20, W, ACCESS
1311C  0D12     MULLW 0x12
1311E  C4F3     MOVFF PROD, tableIndex
13120  F517     NOP
13122  C4F4     MOVFF PRODH, evIdx
13124  F518     NOP
13126  6A19     CLRF 0x19, ACCESS
13128  0E01     MOVLW 0x1
1312A  2417     ADDWF 0x17, W, ACCESS
1312C  6E10     MOVWF 0x10, ACCESS
1312E  0EE8     MOVLW 0xE8
13130  2018     ADDWFC 0x18, W, ACCESS
13132  6E11     MOVWF 0x11, ACCESS
13134  0E01     MOVLW 0x1
13136  2019     ADDWFC 0x19, W, ACCESS
13138  6E12     MOVWF 0x12, ACCESS
1313A  0E00     MOVLW 0x0
1313C  6E13     MOVWF 0x13, ACCESS
1313E  0E01     MOVLW 0x1
13140  EC7E     CALL 0x156FC, 0
13142  F0AB     NOP
698:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + EVENTTABLE_OFFSET_ENH, 0x00);
13144  5020     MOVF 0x20, W, ACCESS
13146  0D12     MULLW 0x12
13148  C4F3     MOVFF PROD, tableIndex
1314A  F517     NOP
1314C  C4F4     MOVFF PRODH, evIdx
1314E  F518     NOP
13150  6A19     CLRF 0x19, ACCESS
13152  0E02     MOVLW 0x2
13154  2417     ADDWF 0x17, W, ACCESS
13156  6E10     MOVWF 0x10, ACCESS
13158  0EE8     MOVLW 0xE8
1315A  2018     ADDWFC 0x18, W, ACCESS
1315C  6E11     MOVWF 0x11, ACCESS
1315E  0E01     MOVLW 0x1
13160  2019     ADDWFC 0x19, W, ACCESS
13162  6E12     MOVWF 0x12, ACCESS
13164  0E00     MOVLW 0x0
13166  6E13     MOVWF 0x13, ACCESS
13168  0E01     MOVLW 0x1
1316A  EC7E     CALL 0x156FC, 0
1316C  F0AB     NOP
699:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + EVENTTABLE_OFFSET_ENL, 0x00);
1316E  5020     MOVF 0x20, W, ACCESS
13170  0D12     MULLW 0x12
13172  C4F3     MOVFF PROD, tableIndex
13174  F517     NOP
13176  C4F4     MOVFF PRODH, evIdx
13178  F518     NOP
1317A  6A19     CLRF 0x19, ACCESS
1317C  0E03     MOVLW 0x3
1317E  2417     ADDWF 0x17, W, ACCESS
13180  6E10     MOVWF 0x10, ACCESS
13182  0EE8     MOVLW 0xE8
13184  2018     ADDWFC 0x18, W, ACCESS
13186  6E11     MOVWF 0x11, ACCESS
13188  0E01     MOVLW 0x1
1318A  2019     ADDWFC 0x19, W, ACCESS
1318C  6E12     MOVWF 0x12, ACCESS
1318E  0E00     MOVLW 0x0
13190  6E13     MOVWF 0x13, ACCESS
13192  0E01     MOVLW 0x1
13194  EC7E     CALL 0x156FC, 0
13196  F0AB     NOP
700:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + EVENTTABLE_OFFSET_FLAGS, 0x00);
13198  5020     MOVF 0x20, W, ACCESS
1319A  0D12     MULLW 0x12
1319C  C4F3     MOVFF PROD, tableIndex
1319E  F517     NOP
131A0  C4F4     MOVFF PRODH, evIdx
131A2  F518     NOP
131A4  6A19     CLRF 0x19, ACCESS
131A6  0E04     MOVLW 0x4
131A8  2417     ADDWF 0x17, W, ACCESS
131AA  6E10     MOVWF 0x10, ACCESS
131AC  0EE8     MOVLW 0xE8
131AE  2018     ADDWFC 0x18, W, ACCESS
131B0  6E11     MOVWF 0x11, ACCESS
131B2  0E01     MOVLW 0x1
131B4  2019     ADDWFC 0x19, W, ACCESS
131B6  6E12     MOVWF 0x12, ACCESS
131B8  0E00     MOVLW 0x0
131BA  6E13     MOVWF 0x13, ACCESS
131BC  0E01     MOVLW 0x1
131BE  EC7E     CALL 0x156FC, 0
131C0  F0AB     NOP
701:                   
702:               for (i=0; i<PARAM_NUM_EV_EVENT; i++) {
131C2  0E00     MOVLW 0x0
131C4  6E1F     MOVWF 0x1F, ACCESS
703:                   writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex + (EVENTTABLE_OFFSET_EVS + i), 0x00);
131C6  501F     MOVF 0x1F, W, ACCESS
131C8  6E17     MOVWF 0x17, ACCESS
131CA  6A18     CLRF 0x18, ACCESS
131CC  0E05     MOVLW 0x5
131CE  2617     ADDWF 0x17, F, ACCESS
131D0  0E00     MOVLW 0x0
131D2  2218     ADDWFC 0x18, F, ACCESS
131D4  5020     MOVF 0x20, W, ACCESS
131D6  0D12     MULLW 0x12
131D8  C4F3     MOVFF PROD, tableIndex
131DA  F519     NOP
131DC  C4F4     MOVFF PRODH, txFifoObj
131DE  F51A     NOP
131E0  6A1B     CLRF 0x1B, ACCESS
131E2  5017     MOVF 0x17, W, ACCESS
131E4  2419     ADDWF 0x19, W, ACCESS
131E6  6E1C     MOVWF 0x1C, ACCESS
131E8  5018     MOVF 0x18, W, ACCESS
131EA  201A     ADDWFC 0x1A, W, ACCESS
131EC  6E1D     MOVWF 0x1D, ACCESS
131EE  0E00     MOVLW 0x0
131F0  BE18     BTFSC 0x18, 7, ACCESS
131F2  0EFF     MOVLW 0xFF
131F4  201B     ADDWFC 0x1B, W, ACCESS
131F6  6E1E     MOVWF 0x1E, ACCESS
131F8  0E00     MOVLW 0x0
131FA  241C     ADDWF 0x1C, W, ACCESS
131FC  6E10     MOVWF 0x10, ACCESS
131FE  0EE8     MOVLW 0xE8
13200  201D     ADDWFC 0x1D, W, ACCESS
13202  6E11     MOVWF 0x11, ACCESS
13204  0E01     MOVLW 0x1
13206  201E     ADDWFC 0x1E, W, ACCESS
13208  6E12     MOVWF 0x12, ACCESS
1320A  0E00     MOVLW 0x0
1320C  6E13     MOVWF 0x13, ACCESS
1320E  0E01     MOVLW 0x1
13210  EC7E     CALL 0x156FC, 0
13212  F0AB     NOP
704:               }
13214  2A1F     INCF 0x1F, F, ACCESS
13216  0E0C     MOVLW 0xC
13218  641F     CPFSGT 0x1F, ACCESS
1321A  D7D5     BRA 0x31C6
705:               flushFlashBlock();
1321C  EC22     CALL 0x15244, 0
1321E  F0A9     NOP
706:               return 0;
13220  0E00     MOVLW 0x0
707:           }
13222  0012     RETURN 0
708:           
709:           /**
710:            * Add an event/EV.
711:            * Teach or re-teach an EV for an event. 
712:            * This may (optionally) need to create a new event and then optionally
713:            * create additional chained entries. All newly allocated table entries need
714:            * to be initialised.
715:            * 
716:            * @param nodeNumber Event NN
717:            * @param eventNumber Event NN
718:            * @param evNum the EV index (starts at 0 for the produced action)
719:            * @param evVal the EV value
720:            * @param forceOwnNN the value of the flag
721:            * @return error number or 0 for success
722:            */
723:           uint8_t addEvent(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum, uint8_t evVal, Boolean forceOwnNN) {
724:               uint8_t tableIndex;
725:               uint8_t error;
726:               // do we currently have an event
727:               tableIndex = findEvent(nodeNumber, eventNumber);
127A4  C523     MOVFF data7, tableIndex
127A6  F519     NOP
127A8  C524     MOVFF opc, txFifoObj
127AA  F51A     NOP
127AC  C525     MOVFF data1, eventNumber
127AE  F51B     NOP
127B0  C526     MOVFF data2, len
127B2  F51C     NOP
127B4  ECA5     CALL 0x1574A, 0
127B6  F0AB     NOP
127B8  6E37     MOVWF 0x37, ACCESS
728:               if (tableIndex == NO_INDEX) {
127BA  2837     INCF 0x37, W, ACCESS
127BC  A4D8     BTFSS 0xFD8, 2, ACCESS
127BE  D0C7     BRA 0x294E
729:                   error = 1;
127C0  0E01     MOVLW 0x1
127C2  6E35     MOVWF 0x35, ACCESS
730:                   // didn't find the event so find an empty slot and create one
731:                   for (tableIndex=0; tableIndex<NUM_EVENTS; tableIndex++) {
127C4  0E00     MOVLW 0x0
127C6  6E37     MOVWF 0x37, ACCESS
127C8  0EFD     MOVLW 0xFD
127CA  6437     CPFSGT 0x37, ACCESS
127CC  D001     BRA 0x27D0
127CE  D0BA     BRA 0x2944
732:                       uint16_t en = getEN(tableIndex);
127D0  5037     MOVF 0x37, W, ACCESS
127D2  ECC0     CALL 0x14D80, 0
127D4  F0A6     NOP
127D6  C50E     MOVFF evNum, learn
127D8  F533     NOP
127DA  C50F     MOVFF interruptEnabled, nodeNumber
127DC  F534     NOP
733:                       if (en == 0) {
127DE  5033     MOVF 0x33, W, ACCESS
127E0  1034     IORWF 0x34, W, ACCESS
127E2  A4D8     BTFSS 0xFD8, 2, ACCESS
127E4  D0AD     BRA 0x2940
734:                           uint8_t e;
735:                           // found a free slot, initialise it
736:                           writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_NNL, nodeNumber&0xFF);
127E6  5037     MOVF 0x37, W, ACCESS
127E8  0D12     MULLW 0x12
127EA  C4F3     MOVFF PROD, data6
127EC  F52A     NOP
127EE  C4F4     MOVFF PRODH, opc
127F0  F52B     NOP
127F2  6A2C     CLRF 0x2C, ACCESS
127F4  0E01     MOVLW 0x1
127F6  242A     ADDWF 0x2A, W, ACCESS
127F8  6E10     MOVWF 0x10, ACCESS
127FA  0EE8     MOVLW 0xE8
127FC  202B     ADDWFC 0x2B, W, ACCESS
127FE  6E11     MOVWF 0x11, ACCESS
12800  0E01     MOVLW 0x1
12802  202C     ADDWFC 0x2C, W, ACCESS
12804  6E12     MOVWF 0x12, ACCESS
12806  C523     MOVFF data7, hi
12808  F513     NOP
1280A  0E01     MOVLW 0x1
1280C  EC7E     CALL 0x156FC, 0
1280E  F0AB     NOP
737:                           writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_NNH, nodeNumber>>8);
12810  5037     MOVF 0x37, W, ACCESS
12812  0D12     MULLW 0x12
12814  C4F3     MOVFF PROD, data6
12816  F52A     NOP
12818  C4F4     MOVFF PRODH, opc
1281A  F52B     NOP
1281C  6A2C     CLRF 0x2C, ACCESS
1281E  0E00     MOVLW 0x0
12820  242A     ADDWF 0x2A, W, ACCESS
12822  6E10     MOVWF 0x10, ACCESS
12824  0EE8     MOVLW 0xE8
12826  202B     ADDWFC 0x2B, W, ACCESS
12828  6E11     MOVWF 0x11, ACCESS
1282A  0E01     MOVLW 0x1
1282C  202C     ADDWFC 0x2C, W, ACCESS
1282E  6E12     MOVWF 0x12, ACCESS
12830  5024     MOVF 0x24, W, ACCESS
12832  6E13     MOVWF 0x13, ACCESS
12834  0E01     MOVLW 0x1
12836  EC7E     CALL 0x156FC, 0
12838  F0AB     NOP
738:                           writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_ENL, eventNumber&0xFF);
1283A  5037     MOVF 0x37, W, ACCESS
1283C  0D12     MULLW 0x12
1283E  C4F3     MOVFF PROD, data6
12840  F52A     NOP
12842  C4F4     MOVFF PRODH, opc
12844  F52B     NOP
12846  6A2C     CLRF 0x2C, ACCESS
12848  0E03     MOVLW 0x3
1284A  242A     ADDWF 0x2A, W, ACCESS
1284C  6E10     MOVWF 0x10, ACCESS
1284E  0EE8     MOVLW 0xE8
12850  202B     ADDWFC 0x2B, W, ACCESS
12852  6E11     MOVWF 0x11, ACCESS
12854  0E01     MOVLW 0x1
12856  202C     ADDWFC 0x2C, W, ACCESS
12858  6E12     MOVWF 0x12, ACCESS
1285A  C525     MOVFF data1, hi
1285C  F513     NOP
1285E  0E01     MOVLW 0x1
12860  EC7E     CALL 0x156FC, 0
12862  F0AB     NOP
739:                           writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_ENH, eventNumber>>8);
12864  5037     MOVF 0x37, W, ACCESS
12866  0D12     MULLW 0x12
12868  C4F3     MOVFF PROD, data6
1286A  F52A     NOP
1286C  C4F4     MOVFF PRODH, opc
1286E  F52B     NOP
12870  6A2C     CLRF 0x2C, ACCESS
12872  0E02     MOVLW 0x2
12874  242A     ADDWF 0x2A, W, ACCESS
12876  6E10     MOVWF 0x10, ACCESS
12878  0EE8     MOVLW 0xE8
1287A  202B     ADDWFC 0x2B, W, ACCESS
1287C  6E11     MOVWF 0x11, ACCESS
1287E  0E01     MOVLW 0x1
12880  202C     ADDWFC 0x2C, W, ACCESS
12882  6E12     MOVWF 0x12, ACCESS
12884  5026     MOVF 0x26, W, ACCESS
12886  6E13     MOVWF 0x13, ACCESS
12888  0E01     MOVLW 0x1
1288A  EC7E     CALL 0x156FC, 0
1288C  F0AB     NOP
740:                           if (forceOwnNN) {
1288E  5029     MOVF 0x29, W, ACCESS
12890  B4D8     BTFSC 0xFD8, 2, ACCESS
12892  D016     BRA 0x28C0
741:                               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_FLAGS, EVENT_FLAG_DEFAULT);
12894  5037     MOVF 0x37, W, ACCESS
12896  0D12     MULLW 0x12
12898  C4F3     MOVFF PROD, data6
1289A  F52A     NOP
1289C  C4F4     MOVFF PRODH, opc
1289E  F52B     NOP
128A0  6A2C     CLRF 0x2C, ACCESS
128A2  0E04     MOVLW 0x4
128A4  242A     ADDWF 0x2A, W, ACCESS
128A6  6E10     MOVWF 0x10, ACCESS
128A8  0EE8     MOVLW 0xE8
128AA  202B     ADDWFC 0x2B, W, ACCESS
128AC  6E11     MOVWF 0x11, ACCESS
128AE  0E01     MOVLW 0x1
128B0  202C     ADDWFC 0x2C, W, ACCESS
128B2  6E12     MOVWF 0x12, ACCESS
128B4  0E01     MOVLW 0x1
128B6  6E13     MOVWF 0x13, ACCESS
128B8  0E01     MOVLW 0x1
128BA  EC7E     CALL 0x156FC, 0
128BC  F0AB     NOP
742:                           } else {
128BE  D015     BRA 0x28EA
743:                               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_FLAGS, 0);
128C0  5037     MOVF 0x37, W, ACCESS
128C2  0D12     MULLW 0x12
128C4  C4F3     MOVFF PROD, data6
128C6  F52A     NOP
128C8  C4F4     MOVFF PRODH, opc
128CA  F52B     NOP
128CC  6A2C     CLRF 0x2C, ACCESS
128CE  0E04     MOVLW 0x4
128D0  242A     ADDWF 0x2A, W, ACCESS
128D2  6E10     MOVWF 0x10, ACCESS
128D4  0EE8     MOVLW 0xE8
128D6  202B     ADDWFC 0x2B, W, ACCESS
128D8  6E11     MOVWF 0x11, ACCESS
128DA  0E01     MOVLW 0x1
128DC  202C     ADDWFC 0x2C, W, ACCESS
128DE  6E12     MOVWF 0x12, ACCESS
128E0  0E00     MOVLW 0x0
128E2  6E13     MOVWF 0x13, ACCESS
128E4  0E01     MOVLW 0x1
128E6  EC7E     CALL 0x156FC, 0
128E8  F0AB     NOP
744:                           }
745:                           for (e = 0; e < EVENT_TABLE_WIDTH; e++) {   // in this case EVENT_TABLE_WIDTH == EVperEvt
128EA  0E00     MOVLW 0x0
128EC  6E36     MOVWF 0x36, ACCESS
746:                               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_EVS+e, EV_FILL);
128EE  5036     MOVF 0x36, W, ACCESS
128F0  6E2A     MOVWF 0x2A, ACCESS
128F2  6A2B     CLRF 0x2B, ACCESS
128F4  6A2C     CLRF 0x2C, ACCESS
128F6  5037     MOVF 0x37, W, ACCESS
128F8  0D12     MULLW 0x12
128FA  C4F3     MOVFF PROD, needed
128FC  F52D     NOP
128FE  C4F4     MOVFF PRODH, service
12900  F52E     NOP
12902  6A2F     CLRF 0x2F, ACCESS
12904  502A     MOVF 0x2A, W, ACCESS
12906  242D     ADDWF 0x2D, W, ACCESS
12908  6E30     MOVWF 0x30, ACCESS
1290A  502B     MOVF 0x2B, W, ACCESS
1290C  202E     ADDWFC 0x2E, W, ACCESS
1290E  6E31     MOVWF 0x31, ACCESS
12910  502C     MOVF 0x2C, W, ACCESS
12912  202F     ADDWFC 0x2F, W, ACCESS
12914  6E32     MOVWF 0x32, ACCESS
12916  0E05     MOVLW 0x5
12918  2430     ADDWF 0x30, W, ACCESS
1291A  6E10     MOVWF 0x10, ACCESS
1291C  0EE8     MOVLW 0xE8
1291E  2031     ADDWFC 0x31, W, ACCESS
12920  6E11     MOVWF 0x11, ACCESS
12922  0E01     MOVLW 0x1
12924  2032     ADDWFC 0x32, W, ACCESS
12926  6E12     MOVWF 0x12, ACCESS
12928  0E00     MOVLW 0x0
1292A  6E13     MOVWF 0x13, ACCESS
1292C  0E01     MOVLW 0x1
1292E  EC7E     CALL 0x156FC, 0
12930  F0AB     NOP
747:                           }
12932  2A36     INCF 0x36, F, ACCESS
12934  0E0C     MOVLW 0xC
12936  6436     CPFSGT 0x36, ACCESS
12938  D7DA     BRA 0x28EE
748:                           error = 0;
1293A  0E00     MOVLW 0x0
1293C  6E35     MOVWF 0x35, ACCESS
749:                           break;
1293E  D002     BRA 0x2944
750:                       }
751:                   }
12940  2A37     INCF 0x37, F, ACCESS
12942  D742     BRA 0x27C8
752:                   if (error) {
12944  5035     MOVF 0x35, W, ACCESS
12946  B4D8     BTFSC 0xFD8, 2, ACCESS
12948  D002     BRA 0x294E
753:                       return CMDERR_TOO_MANY_EVENTS;
1294A  0E04     MOVLW 0x4
1294C  0012     RETURN 0
754:                   }
755:               }
756:            
757:               if (writeEv(tableIndex, evNum, evVal)) {
1294E  C527     MOVFF data3, tableIndex
12950  F517     NOP
12952  C528     MOVFF data4, evIdx
12954  F518     NOP
12956  5037     MOVF 0x37, W, ACCESS
12958  ECC4     CALL 0x15188, 0
1295A  F0A8     NOP
1295C  0900     IORLW 0x0
1295E  B4D8     BTFSC 0xFD8, 2, ACCESS
12960  D002     BRA 0x2966
758:                   // failed to write
759:                   return CMDERR_INV_EV_IDX;
12962  0E06     MOVLW 0x6
12964  0012     RETURN 0
760:               }
761:               // success
762:               flushFlashBlock();
12966  EC22     CALL 0x15244, 0
12968  F0A9     NOP
763:               return 0;
1296A  0E00     MOVLW 0x0
764:           }
1296C  0012     RETURN 0
765:           
766:           /**
767:            * Find an event in the event table and return its index.
768:            * 
769:            * @param nodeNumber event NN
770:            * @param eventNumber event EN
771:            * @return index into event table or NO_INDEX if not present
772:            */
773:           uint8_t findEvent(uint16_t nodeNumber, uint16_t eventNumber) {
774:               uint8_t tableIndex;
775:               for (tableIndex=0; tableIndex < NUM_EVENTS; tableIndex++) {
1574A  0E00     MOVLW 0x0
1574C  6E1F     MOVWF 0x1F, ACCESS
776:                   uint16_t b = getEN(tableIndex);
1574E  501F     MOVF 0x1F, W, ACCESS
15750  ECC0     CALL 0x14D80, 0
15752  F0A6     NOP
15754  C50E     MOVFF evNum, data1
15756  F51D     NOP
15758  C50F     MOVFF interruptEnabled, data2
1575A  F51E     NOP
777:                   if (b == eventNumber) {
1575C  501B     MOVF 0x1B, W, ACCESS
1575E  181D     XORWF 0x1D, W, ACCESS
15760  E114     BNZ 0x578A
15762  501C     MOVF 0x1C, W, ACCESS
15764  181E     XORWF 0x1E, W, ACCESS
15766  A4D8     BTFSS 0xFD8, 2, ACCESS
15768  D010     BRA 0x578A
778:                       b = getNN(tableIndex);
1576A  501F     MOVF 0x1F, W, ACCESS
1576C  EC9A     CALL 0x13F34, 0
1576E  F09F     NOP
15770  C50E     MOVFF evNum, data1
15772  F51D     NOP
15774  C50F     MOVFF interruptEnabled, data2
15776  F51E     NOP
779:                       if (b == nodeNumber) {
15778  5019     MOVF 0x19, W, ACCESS
1577A  181D     XORWF 0x1D, W, ACCESS
1577C  E106     BNZ 0x578A
1577E  501A     MOVF 0x1A, W, ACCESS
15780  181E     XORWF 0x1E, W, ACCESS
15782  A4D8     BTFSS 0xFD8, 2, ACCESS
15784  D002     BRA 0x578A
780:                           return tableIndex;
15786  501F     MOVF 0x1F, W, ACCESS
15788  0012     RETURN 0
781:                       }
782:                   }
783:               }
1578A  2A1F     INCF 0x1F, F, ACCESS
1578C  0EFD     MOVLW 0xFD
1578E  641F     CPFSGT 0x1F, ACCESS
15790  D7DE     BRA 0x574E
784:               return NO_INDEX;
15792  0EFF     MOVLW 0xFF
785:           }
15794  0012     RETURN 0
786:           
787:           /**
788:            * Write an EV value to an event.
789:            * 
790:            * @param tableIndex the index into the event table
791:            * @param evNum the EV number (0 for the produced action)
792:            * @param evVal the EV value
793:            * @return 0 if success otherwise the error
794:            */
795:           uint8_t writeEv(uint8_t tableIndex, uint8_t evNum, uint8_t evVal) {
15188  6E22     MOVWF 0x22, ACCESS
796:               if (evNum >= PARAM_NUM_EV_EVENT) {
1518A  0E0C     MOVLW 0xC
1518C  6417     CPFSGT 0x17, ACCESS
1518E  D002     BRA 0x5194
797:                   return CMDERR_INV_EV_IDX;
15190  0E06     MOVLW 0x6
15192  0012     RETURN 0
798:               }
799:               if (tableIndex >= NUM_EVENTS) {
15194  0EFD     MOVLW 0xFD
15196  6422     CPFSGT 0x22, ACCESS
15198  D002     BRA 0x519E
800:                   return CMDERR_INV_EN_IDX;
1519A  0E08     MOVLW 0x8
1519C  0012     RETURN 0
801:               }
802:               
803:               // now write the EV
804:               writeNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_EVS+evNum, evVal);
1519E  5017     MOVF 0x17, W, ACCESS
151A0  6E19     MOVWF 0x19, ACCESS
151A2  6A1A     CLRF 0x1A, ACCESS
151A4  6A1B     CLRF 0x1B, ACCESS
151A6  5022     MOVF 0x22, W, ACCESS
151A8  0D12     MULLW 0x12
151AA  C4F3     MOVFF PROD, len
151AC  F51C     NOP
151AE  C4F4     MOVFF PRODH, data1
151B0  F51D     NOP
151B2  6A1E     CLRF 0x1E, ACCESS
151B4  5019     MOVF 0x19, W, ACCESS
151B6  241C     ADDWF 0x1C, W, ACCESS
151B8  6E1F     MOVWF 0x1F, ACCESS
151BA  501A     MOVF 0x1A, W, ACCESS
151BC  201D     ADDWFC 0x1D, W, ACCESS
151BE  6E20     MOVWF 0x20, ACCESS
151C0  501B     MOVF 0x1B, W, ACCESS
151C2  201E     ADDWFC 0x1E, W, ACCESS
151C4  6E21     MOVWF 0x21, ACCESS
151C6  0E05     MOVLW 0x5
151C8  241F     ADDWF 0x1F, W, ACCESS
151CA  6E10     MOVWF 0x10, ACCESS
151CC  0EE8     MOVLW 0xE8
151CE  2020     ADDWFC 0x20, W, ACCESS
151D0  6E11     MOVWF 0x11, ACCESS
151D2  0E01     MOVLW 0x1
151D4  2021     ADDWFC 0x21, W, ACCESS
151D6  6E12     MOVWF 0x12, ACCESS
151D8  C518     MOVFF evIdx, hi
151DA  F513     NOP
151DC  0E01     MOVLW 0x1
151DE  EC7E     CALL 0x156FC, 0
151E0  F0AB     NOP
805:               return 0;
151E2  0E00     MOVLW 0x0
806:           }
151E4  0012     RETURN 0
807:            
808:           /**
809:            * Return an EV value for an event.
810:            * 
811:            * @param tableIndex the index of the start of an event
812:            * @param evNum ev number starts at 0 (Happening)
813:            * @return the ev value or -error code if error
814:            */
815:           int16_t getEv(uint8_t tableIndex, uint8_t evNum) {
14F9E  6E19     MOVWF 0x19, ACCESS
816:               if (tableIndex >= NUM_EVENTS) {
14FA0  0EFD     MOVLW 0xFD
14FA2  6419     CPFSGT 0x19, ACCESS
14FA4  D005     BRA 0x4FB0
817:                   return CMDERR_INV_EN_IDX;
14FA6  0E00     MOVLW 0x0
14FA8  6E0F     MOVWF 0xF, ACCESS
14FAA  0E08     MOVLW 0x8
14FAC  6E0E     MOVWF 0xE, ACCESS
14FAE  0012     RETURN 0
818:               }
819:               if (evNum >= PARAM_NUM_EV_EVENT) {
14FB0  0E0C     MOVLW 0xC
14FB2  640E     CPFSGT 0xE, ACCESS
14FB4  D005     BRA 0x4FC0
820:                   return -CMDERR_INV_EV_IDX;
14FB6  0EFF     MOVLW 0xFF
14FB8  6E0F     MOVWF 0xF, ACCESS
14FBA  0EFA     MOVLW 0xFA
14FBC  6E0E     MOVWF 0xE, ACCESS
14FBE  0012     RETURN 0
821:               }
822:               return (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_EVS+evNum);
14FC0  500E     MOVF 0xE, W, ACCESS
14FC2  6E10     MOVWF 0x10, ACCESS
14FC4  6A11     CLRF 0x11, ACCESS
14FC6  6A12     CLRF 0x12, ACCESS
14FC8  5019     MOVF 0x19, W, ACCESS
14FCA  0D12     MULLW 0x12
14FCC  C4F3     MOVFF PROD, hi
14FCE  F513     NOP
14FD0  C4F4     MOVFF PRODH, incomingCanId
14FD2  F514     NOP
14FD4  6A15     CLRF 0x15, ACCESS
14FD6  5010     MOVF 0x10, W, ACCESS
14FD8  2413     ADDWF 0x13, W, ACCESS
14FDA  6E16     MOVWF 0x16, ACCESS
14FDC  5011     MOVF 0x11, W, ACCESS
14FDE  2014     ADDWFC 0x14, W, ACCESS
14FE0  6E17     MOVWF 0x17, ACCESS
14FE2  5012     MOVF 0x12, W, ACCESS
14FE4  2015     ADDWFC 0x15, W, ACCESS
14FE6  6E18     MOVWF 0x18, ACCESS
14FE8  0E05     MOVLW 0x5
14FEA  2416     ADDWF 0x16, W, ACCESS
14FEC  6E08     MOVWF 0x8, ACCESS
14FEE  0EE8     MOVLW 0xE8
14FF0  2017     ADDWFC 0x17, W, ACCESS
14FF2  6E09     MOVWF 0x9, ACCESS
14FF4  0E01     MOVLW 0x1
14FF6  2018     ADDWFC 0x18, W, ACCESS
14FF8  6E0A     MOVWF 0xA, ACCESS
14FFA  0E01     MOVLW 0x1
14FFC  ECF3     CALL 0x151E6, 0
14FFE  F0A8     NOP
15000  5008     MOVF 0x8, W, ACCESS
15002  6E0E     MOVWF 0xE, ACCESS
15004  6A0F     CLRF 0xF, ACCESS
823:           }
15006  0012     RETURN 0
824:           
825:           /**
826:            * Return the number of EVs for an event.
827:            * 
828:            * @param tableIndex the index of the start of an event
829:            * @return the number of EVs
830:            */
831:           uint8_t numEv(uint8_t tableIndex) {
832:               return PARAM_NUM_EV_EVENT;
16296  0E0D     MOVLW 0xD
833:           }
16298  0012     RETURN 0
834:           
835:           /**
836:            * The EVs for an event after calling getEVs()
837:            */
838:           uint8_t evs[PARAM_NUM_EV_EVENT];
839:           /**
840:            * Return all the EV values for an event. EVs are put into the global evs array.
841:            * 
842:            * @param tableIndex the index of the start of an event
843:            * @return the error code or 0 for no error
844:            */
845:           uint8_t getEVs(uint8_t tableIndex) {
14E5A  6E17     MOVWF 0x17, ACCESS
846:           
847:               uint8_t evIdx;
848:               if (tableIndex >= NUM_EVENTS) {
14E5C  0EFD     MOVLW 0xFD
14E5E  6417     CPFSGT 0x17, ACCESS
14E60  D002     BRA 0x4E66
849:                   return CMDERR_INV_EN_IDX;
14E62  0E08     MOVLW 0x8
14E64  0012     RETURN 0
850:               }
851:           
852:               for (evIdx=0; evIdx < PARAM_NUM_EV_EVENT; evIdx++) {
14E66  0E00     MOVLW 0x0
14E68  6E18     MOVWF 0x18, ACCESS
853:                   evs[evIdx] = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_EVS+evIdx);
14E6A  5018     MOVF 0x18, W, ACCESS
14E6C  6E0E     MOVWF 0xE, ACCESS
14E6E  6A0F     CLRF 0xF, ACCESS
14E70  6A10     CLRF 0x10, ACCESS
14E72  5017     MOVF 0x17, W, ACCESS
14E74  0D12     MULLW 0x12
14E76  C4F3     MOVFF PROD, m
14E78  F511     NOP
14E7A  C4F4     MOVFF PRODH, i
14E7C  F512     NOP
14E7E  6A13     CLRF 0x13, ACCESS
14E80  500E     MOVF 0xE, W, ACCESS
14E82  2411     ADDWF 0x11, W, ACCESS
14E84  6E14     MOVWF 0x14, ACCESS
14E86  500F     MOVF 0xF, W, ACCESS
14E88  2012     ADDWFC 0x12, W, ACCESS
14E8A  6E15     MOVWF 0x15, ACCESS
14E8C  5010     MOVF 0x10, W, ACCESS
14E8E  2013     ADDWFC 0x13, W, ACCESS
14E90  6E16     MOVWF 0x16, ACCESS
14E92  0E05     MOVLW 0x5
14E94  2414     ADDWF 0x14, W, ACCESS
14E96  6E08     MOVWF 0x8, ACCESS
14E98  0EE8     MOVLW 0xE8
14E9A  2015     ADDWFC 0x15, W, ACCESS
14E9C  6E09     MOVWF 0x9, ACCESS
14E9E  0E01     MOVLW 0x1
14EA0  2016     ADDWFC 0x16, W, ACCESS
14EA2  6E0A     MOVWF 0xA, ACCESS
14EA4  0E01     MOVLW 0x1
14EA6  ECF3     CALL 0x151E6, 0
14EA8  F0A8     NOP
14EAA  0E50     MOVLW 0x50
14EAC  2418     ADDWF 0x18, W, ACCESS
14EAE  6ED9     MOVWF 0xFD9, ACCESS
14EB0  6ADA     CLRF 0xFDA, ACCESS
14EB2  0E06     MOVLW 0x6
14EB4  22DA     ADDWFC 0xFDA, F, ACCESS
14EB6  C508     MOVFF index, INDF2
14EB8  F4DF     NOP
854:               }
14EBA  2A18     INCF 0x18, F, ACCESS
14EBC  0E0C     MOVLW 0xC
14EBE  6418     CPFSGT 0x18, ACCESS
14EC0  D7D4     BRA 0x4E6A
855:               return 0;
14EC2  0E00     MOVLW 0x0
856:           }
14EC4  0012     RETURN 0
857:           
858:           /**
859:            * Return the NN for an event.
860:            * Getter so that the application code can obtain information about the event.
861:            * 
862:            * @param tableIndex the index of the start of an event
863:            * @return the Node Number
864:            */
865:           uint16_t getNN(uint8_t tableIndex) {
13F34  6E18     MOVWF 0x18, ACCESS
866:               uint16_t hi;
867:               uint16_t lo;
868:               uint8_t flags;
869:               if (tableIndex >= NUM_EVENTS) {
13F36  0EFD     MOVLW 0xFD
13F38  6418     CPFSGT 0x18, ACCESS
13F3A  D005     BRA 0x3F46
870:                   return CMDERR_INV_EN_IDX;
13F3C  0E00     MOVLW 0x0
13F3E  6E0F     MOVWF 0xF, ACCESS
13F40  0E08     MOVLW 0x8
13F42  6E0E     MOVWF 0xE, ACCESS
13F44  0012     RETURN 0
871:               }
872:               
873:               flags = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_FLAGS);
13F46  5018     MOVF 0x18, W, ACCESS
13F48  0D12     MULLW 0x12
13F4A  C4F3     MOVFF PROD, receivedCanId
13F4C  F510     NOP
13F4E  C4F4     MOVFF PRODH, m
13F50  F511     NOP
13F52  6A12     CLRF 0x12, ACCESS
13F54  0E04     MOVLW 0x4
13F56  2410     ADDWF 0x10, W, ACCESS
13F58  6E08     MOVWF 0x8, ACCESS
13F5A  0EE8     MOVLW 0xE8
13F5C  2011     ADDWFC 0x11, W, ACCESS
13F5E  6E09     MOVWF 0x9, ACCESS
13F60  0E01     MOVLW 0x1
13F62  2012     ADDWFC 0x12, W, ACCESS
13F64  6E0A     MOVWF 0xA, ACCESS
13F66  0E01     MOVLW 0x1
13F68  ECF3     CALL 0x151E6, 0
13F6A  F0A8     NOP
13F6C  5008     MOVF 0x8, W, ACCESS
13F6E  6E17     MOVWF 0x17, ACCESS
874:               if (flags & EVENT_FLAG_DEFAULT) {
13F70  A017     BTFSS 0x17, 0, ACCESS
13F72  D005     BRA 0x3F7E
875:                   return nn.word;
13F74  C553     MOVFF nn, evNum
13F76  F50E     NOP
13F78  C554     MOVFF 0x554, interruptEnabled
13F7A  F50F     NOP
13F7C  0012     RETURN 0
876:               }
877:               lo = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_NNL);
13F7E  5018     MOVF 0x18, W, ACCESS
13F80  0D12     MULLW 0x12
13F82  C4F3     MOVFF PROD, receivedCanId
13F84  F510     NOP
13F86  C4F4     MOVFF PRODH, m
13F88  F511     NOP
13F8A  6A12     CLRF 0x12, ACCESS
13F8C  0E01     MOVLW 0x1
13F8E  2410     ADDWF 0x10, W, ACCESS
13F90  6E08     MOVWF 0x8, ACCESS
13F92  0EE8     MOVLW 0xE8
13F94  2011     ADDWFC 0x11, W, ACCESS
13F96  6E09     MOVWF 0x9, ACCESS
13F98  0E01     MOVLW 0x1
13F9A  2012     ADDWFC 0x12, W, ACCESS
13F9C  6E0A     MOVWF 0xA, ACCESS
13F9E  0E01     MOVLW 0x1
13FA0  ECF3     CALL 0x151E6, 0
13FA2  F0A8     NOP
13FA4  5008     MOVF 0x8, W, ACCESS
13FA6  6E15     MOVWF 0x15, ACCESS
13FA8  6A16     CLRF 0x16, ACCESS
878:               hi = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_NNH);
13FAA  5018     MOVF 0x18, W, ACCESS
13FAC  0D12     MULLW 0x12
13FAE  C4F3     MOVFF PROD, receivedCanId
13FB0  F510     NOP
13FB2  C4F4     MOVFF PRODH, m
13FB4  F511     NOP
13FB6  6A12     CLRF 0x12, ACCESS
13FB8  0E00     MOVLW 0x0
13FBA  2410     ADDWF 0x10, W, ACCESS
13FBC  6E08     MOVWF 0x8, ACCESS
13FBE  0EE8     MOVLW 0xE8
13FC0  2011     ADDWFC 0x11, W, ACCESS
13FC2  6E09     MOVWF 0x9, ACCESS
13FC4  0E01     MOVLW 0x1
13FC6  2012     ADDWFC 0x12, W, ACCESS
13FC8  6E0A     MOVWF 0xA, ACCESS
13FCA  0E01     MOVLW 0x1
13FCC  ECF3     CALL 0x151E6, 0
13FCE  F0A8     NOP
13FD0  5008     MOVF 0x8, W, ACCESS
13FD2  6E13     MOVWF 0x13, ACCESS
13FD4  6A14     CLRF 0x14, ACCESS
879:               return lo | (hi << 8);
13FD6  5013     MOVF 0x13, W, ACCESS
13FD8  6E11     MOVWF 0x11, ACCESS
13FDA  6A10     CLRF 0x10, ACCESS
13FDC  5015     MOVF 0x15, W, ACCESS
13FDE  1010     IORWF 0x10, W, ACCESS
13FE0  6E0E     MOVWF 0xE, ACCESS
13FE2  5016     MOVF 0x16, W, ACCESS
13FE4  1011     IORWF 0x11, W, ACCESS
13FE6  6E0F     MOVWF 0xF, ACCESS
880:           }
13FE8  0012     RETURN 0
881:           
882:           /**
883:            * Return the EN for an event.
884:            * Getter so that the application code can obtain information about the event.
885:            * 
886:            * @param tableIndex the index of the start of an event
887:            * @return the Event Number
888:            */
889:           uint16_t getEN(uint8_t tableIndex) {
14D80  6E17     MOVWF 0x17, ACCESS
890:               uint16_t hi;
891:               uint16_t lo;
892:               
893:               lo = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_ENL);
14D82  5017     MOVF 0x17, W, ACCESS
14D84  0D12     MULLW 0x12
14D86  C4F3     MOVFF PROD, receivedCanId
14D88  F510     NOP
14D8A  C4F4     MOVFF PRODH, m
14D8C  F511     NOP
14D8E  6A12     CLRF 0x12, ACCESS
14D90  0E03     MOVLW 0x3
14D92  2410     ADDWF 0x10, W, ACCESS
14D94  6E08     MOVWF 0x8, ACCESS
14D96  0EE8     MOVLW 0xE8
14D98  2011     ADDWFC 0x11, W, ACCESS
14D9A  6E09     MOVWF 0x9, ACCESS
14D9C  0E01     MOVLW 0x1
14D9E  2012     ADDWFC 0x12, W, ACCESS
14DA0  6E0A     MOVWF 0xA, ACCESS
14DA2  0E01     MOVLW 0x1
14DA4  ECF3     CALL 0x151E6, 0
14DA6  F0A8     NOP
14DA8  5008     MOVF 0x8, W, ACCESS
14DAA  6E15     MOVWF 0x15, ACCESS
14DAC  6A16     CLRF 0x16, ACCESS
894:               hi = (uint8_t)readNVM(EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_WIDTH*tableIndex+EVENTTABLE_OFFSET_ENH);
14DAE  5017     MOVF 0x17, W, ACCESS
14DB0  0D12     MULLW 0x12
14DB2  C4F3     MOVFF PROD, receivedCanId
14DB4  F510     NOP
14DB6  C4F4     MOVFF PRODH, m
14DB8  F511     NOP
14DBA  6A12     CLRF 0x12, ACCESS
14DBC  0E02     MOVLW 0x2
14DBE  2410     ADDWF 0x10, W, ACCESS
14DC0  6E08     MOVWF 0x8, ACCESS
14DC2  0EE8     MOVLW 0xE8
14DC4  2011     ADDWFC 0x11, W, ACCESS
14DC6  6E09     MOVWF 0x9, ACCESS
14DC8  0E01     MOVLW 0x1
14DCA  2012     ADDWFC 0x12, W, ACCESS
14DCC  6E0A     MOVWF 0xA, ACCESS
14DCE  0E01     MOVLW 0x1
14DD0  ECF3     CALL 0x151E6, 0
14DD2  F0A8     NOP
14DD4  5008     MOVF 0x8, W, ACCESS
14DD6  6E13     MOVWF 0x13, ACCESS
14DD8  6A14     CLRF 0x14, ACCESS
895:               return lo | (hi << 8);
14DDA  5013     MOVF 0x13, W, ACCESS
14DDC  6E11     MOVWF 0x11, ACCESS
14DDE  6A10     CLRF 0x10, ACCESS
14DE0  5015     MOVF 0x15, W, ACCESS
14DE2  1010     IORWF 0x10, W, ACCESS
14DE4  6E0E     MOVWF 0xE, ACCESS
14DE6  5016     MOVF 0x16, W, ACCESS
14DE8  1011     IORWF 0x11, W, ACCESS
14DEA  6E0F     MOVWF 0xF, ACCESS
896:           }
14DEC  0012     RETURN 0
897:           
898:           /**
899:            * Convert an evtIdx from CBUS to an index into the EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_ROW_WIDTH*i+EVENTTABLE_OFFSET_.
900:            * The CBUS spec uses "EN#" as an index into an "Event Table". This is very implementation
901:            * specific. In this implementation we do actually have an event table behind the scenes
902:            * so we can have an EN#. However we may also wish to provide some kind of mapping between
903:            * the CBUS index and out actual implementation specific index. These functions allow us
904:            * to have a mapping.
905:            * I currently I just adjust by 1 since the CBUS index starts at 1 whilst the EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_ROW_WIDTH*i+EVENTTABLE_OFFSET_
906:            * index starts at 0.
907:            * 
908:            * @param evtIdx
909:            * @return an index into EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_ROW_WIDTH*i+EVENTTABLE_OFFSET_
910:            */
911:           static uint8_t evtIdxToTableIndex(uint8_t evtIdx) {
1627E  6E02     MOVWF ___rparam_used, ACCESS
912:               return evtIdx - 1;
16280  0402     DECF ___rparam_used, W, ACCESS
913:           }
16282  0012     RETURN 0
914:           
915:           /**
916:            * Convert an internal tableIndex into a CBUS EvtIdx.
917:            * 
918:            * @param tableIndex index into the EVENT_TABLE_NVM_TYPE, EVENT_TABLE_ADDRESS + EVENTTABLE_ROW_WIDTH*i+EVENTTABLE_OFFSET_
919:            * @return an CBUS EvtIdx
920:            */
921:           static uint8_t tableIndexToEvtIdx(uint8_t tableIndex) {
16284  6E02     MOVWF ___rparam_used, ACCESS
922:               return tableIndex + 1;
16286  2802     INCF ___rparam_used, W, ACCESS
923:           }
16288  0012     RETURN 0
924:           
925:           
---  C:/Users/ianwh/github/VLCBlib_PIC/event_producer_simple.c  -----------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:            */
36:            /**
37:             * @author Ian Hogg 
38:             * @date Oct 2024
39:             * 
40:             */ 
41:            
42:            /**
43:             * @file
44:             * @brief
45:             * Implementation of the VLCB Event Producer Service.
46:             * @details
47:             * Handle the production of events.
48:             */
49:            
50:            #include <xc.h>
51:            #include "module.h"
52:            #include "vlcb.h"
53:            #include "event_teach.h"
54:            #include "event_producer.h"
55:            #include "mns.h"
56:            
57:            extern Boolean validStart(uint8_t tableIndex);
58:            
59:            // Forward function declarations
60:            static Processed producerProcessMessage(Message *m);
61:            #ifdef VLCB_DIAG
62:            static void producerPowerUp(void);
63:            static DiagnosticVal * producerGetDiagnostic(uint8_t index);
64:            static DiagnosticVal producerDiagnostics[NUM_PRODUCER_DIAGNOSTICS+1];
65:            #endif
66:            static uint8_t producerEsdData(uint8_t id);
67:            
68:            /**
69:             * The service descriptor for the event producer service. The application must include this
70:             * descriptor within the const Service * const services[] array and include the
71:             * necessary settings within module.h in order to make use of the event producer
72:             * service.
73:             */
74:            const Service eventProducerService = {
75:                SERVICE_ID_PRODUCER,// id
76:                1,                  // version
77:                NULL,               // factoryReset
78:            #ifdef VLCB_DIAG
79:                producerPowerUp,    // powerUp
80:            #else
81:                NULL,               // powerUp
82:            #endif
83:                producerProcessMessage,  // processMessage
84:                NULL,               // poll
85:            #if defined(_18F66K80_FAMILY_)
86:                NULL,               // highIsr
87:                NULL,               // lowIsr
88:            #endif
89:            #ifdef VLCB_SERVICE
90:                producerEsdData,               // Get ESD data
91:            #endif
92:            #ifdef VLCB_DIAG
93:                producerGetDiagnostic                // getDiagnostic
94:            #endif
95:            };
96:            
97:            #ifdef VLCB_DIAG
98:            static void producerPowerUp(void) {
99:                uint8_t i;
100:               for (i=1; i <= NUM_PRODUCER_DIAGNOSTICS; i++) {
15DA2  0E01     MOVLW 0x1
15DA4  6E02     MOVWF ___rparam_used, ACCESS
101:                   producerDiagnostics[i].asUint = 0;
15DA6  5002     MOVF ___rparam_used, W, ACCESS
15DA8  0D02     MULLW 0x2
15DAA  0ED0     MOVLW 0xD0
15DAC  24F3     ADDWF 0xFF3, W, ACCESS
15DAE  6ED9     MOVWF 0xFD9, ACCESS
15DB0  0E05     MOVLW 0x5
15DB2  20F4     ADDWFC 0xFF4, W, ACCESS
15DB4  6EDA     MOVWF 0xFDA, ACCESS
15DB6  6ADE     CLRF 0xFDE, ACCESS
15DB8  6ADD     CLRF 0xFDD, ACCESS
102:               }
15DBA  2A02     INCF ___rparam_used, F, ACCESS
15DBC  0E01     MOVLW 0x1
15DBE  6402     CPFSGT ___rparam_used, ACCESS
15DC0  D7F2     BRA 0x5DA6
103:               producerDiagnostics[PRODUCER_DIAG_COUNT].asUint = NUM_PRODUCER_DIAGNOSTICS;
15DC2  0E00     MOVLW 0x0
15DC4  0105     MOVLB 0x5
15DC6  6FD1     MOVWF 0xD1, BANKED
15DC8  0E01     MOVLW 0x1
15DCA  6FD0     MOVWF 0xD0, BANKED
104:           }
15DCC  0012     RETURN 0
105:           #endif
106:           
107:           /**
108:            * Process and events associated with the eventProduction service.
109:            * This handles the processing of the AREQ and ASRQ requests.
110:            * 
111:            * @param m the received message
112:            * @return PROCESSED if the message was handled by this function
113:            */
114:           static Processed producerProcessMessage(Message *m) {
115:               uint8_t index;
116:               
117:               switch (m->opc) {
1201A  D0F3     BRA 0x2202
118:                   case OPC_AREQ:
119:                   case OPC_ASRQ:
120:                       if (m->len < 5) {
1201C  C546     MOVFF m, FSR2
1201E  F4D9     NOP
12020  C547     MOVFF 0x547, FSR2H
12022  F4DA     NOP
12024  0E05     MOVLW 0x5
12026  60DF     CPFSLT 0xFDF, ACCESS
12028  D00B     BRA 0x2040
121:                           sendMessage3(OPC_CMDERR, nn.bytes.hi, nn.bytes.lo, CMDERR_INV_CMD);
1202A  C554     MOVFF 0x554, data1
1202C  F525     NOP
1202E  C553     MOVFF nn, data2
12030  F526     NOP
12032  0E01     MOVLW 0x1
12034  6E27     MOVWF 0x27, ACCESS
12036  0E6F     MOVLW 0x6F
12038  EC3E     CALL 0x15E7C, 0
1203A  F0AF     NOP
122:                           return PROCESSED;
1203C  0E01     MOVLW 0x1
1203E  0012     RETURN 0
123:                       }
124:                       if (m->opc == OPC_AREQ) {
12040  EE20     LFSR 2, 0x1
12042  F001     NOP
12044  5046     MOVF NVMDAT, W, ACCESS
12046  26D9     ADDWF 0xFD9, F, ACCESS
12048  5047     MOVF NVMDATH, W, ACCESS
1204A  22DA     ADDWFC 0xFDA, F, ACCESS
1204C  0E92     MOVLW 0x92
1204E  18DE     XORWF 0xFDE, W, ACCESS
12050  A4D8     BTFSS 0xFD8, 2, ACCESS
12052  D02B     BRA 0x20AA
125:                           index = findEvent((uint16_t)((m->bytes[0]<<8)|(m->bytes[1])), (uint16_t)((m->bytes[2]<<8)|(m->bytes[3])));
12054  EE20     LFSR 2, 0x3
12056  F003     NOP
12058  5046     MOVF NVMDAT, W, ACCESS
1205A  26D9     ADDWF 0xFD9, F, ACCESS
1205C  5047     MOVF NVMDATH, W, ACCESS
1205E  22DA     ADDWFC 0xFDA, F, ACCESS
12060  50DF     MOVF 0xFDF, W, ACCESS
12062  6E48     MOVWF VREGCON, ACCESS
12064  EE20     LFSR 2, 0x2
12066  F002     NOP
12068  5046     MOVF NVMDAT, W, ACCESS
1206A  26D9     ADDWF 0xFD9, F, ACCESS
1206C  5047     MOVF NVMDATH, W, ACCESS
1206E  22DA     ADDWFC 0xFDA, F, ACCESS
12070  50DF     MOVF 0xFDF, W, ACCESS
12072  6E49     MOVWF BORCON, ACCESS
12074  5048     MOVF VREGCON, W, ACCESS
12076  6E19     MOVWF 0x19, ACCESS
12078  C549     MOVFF 0x549, txFifoObj
1207A  F51A     NOP
1207C  EE20     LFSR 2, 0x5
1207E  F005     NOP
12080  5046     MOVF NVMDAT, W, ACCESS
12082  26D9     ADDWF 0xFD9, F, ACCESS
12084  5047     MOVF NVMDATH, W, ACCESS
12086  22DA     ADDWFC 0xFDA, F, ACCESS
12088  50DF     MOVF 0xFDF, W, ACCESS
1208A  6E4B     MOVWF HLVDCON1, ACCESS
1208C  EE20     LFSR 2, 0x4
1208E  F004     NOP
12090  5046     MOVF NVMDAT, W, ACCESS
12092  26D9     ADDWF 0xFD9, F, ACCESS
12094  5047     MOVF NVMDATH, W, ACCESS
12096  22DA     ADDWFC 0xFDA, F, ACCESS
12098  50DF     MOVF 0xFDF, W, ACCESS
1209A  6E4C     MOVWF ZCDCON, ACCESS
1209C  504B     MOVF HLVDCON1, W, ACCESS
1209E  6E1B     MOVWF 0x1B, ACCESS
120A0  C54C     MOVFF eventIndex, len
120A2  F51C     NOP
120A4  ECA5     CALL 0x1574A, 0
120A6  F0AB     NOP
120A8  D01A     BRA 0x20DE
126:                       } else {
127:                           index = findEvent(0, (uint16_t)((m->bytes[2]<<8)|(m->bytes[3])));
120AA  0E00     MOVLW 0x0
120AC  6E1A     MOVWF 0x1A, ACCESS
120AE  0E00     MOVLW 0x0
120B0  6E19     MOVWF 0x19, ACCESS
120B2  EE20     LFSR 2, 0x5
120B4  F005     NOP
120B6  5046     MOVF NVMDAT, W, ACCESS
120B8  26D9     ADDWF 0xFD9, F, ACCESS
120BA  5047     MOVF NVMDATH, W, ACCESS
120BC  22DA     ADDWFC 0xFDA, F, ACCESS
120BE  50DF     MOVF 0xFDF, W, ACCESS
120C0  6E48     MOVWF VREGCON, ACCESS
120C2  EE20     LFSR 2, 0x4
120C4  F004     NOP
120C6  5046     MOVF NVMDAT, W, ACCESS
120C8  26D9     ADDWF 0xFD9, F, ACCESS
120CA  5047     MOVF NVMDATH, W, ACCESS
120CC  22DA     ADDWFC 0xFDA, F, ACCESS
120CE  50DF     MOVF 0xFDF, W, ACCESS
120D0  6E49     MOVWF BORCON, ACCESS
120D2  5048     MOVF VREGCON, W, ACCESS
120D4  6E1B     MOVWF 0x1B, ACCESS
120D6  C549     MOVFF 0x549, len
120D8  F51C     NOP
120DA  ECA5     CALL 0x1574A, 0
120DC  F0AB     NOP
120DE  6E4E     MOVWF 0x4E, ACCESS
128:                       }
129:                       if (index == NO_INDEX) return PROCESSED;
120E0  284E     INCF 0x4E, W, ACCESS
120E2  B4D8     BTFSC 0xFD8, 2, ACCESS
120E4  D7AB     BRA 0x203C
130:           
131:                       if (m->opc == OPC_AREQ) {
120E6  EE20     LFSR 2, 0x1
120E8  F001     NOP
120EA  5046     MOVF NVMDAT, W, ACCESS
120EC  26D9     ADDWF 0xFD9, F, ACCESS
120EE  5047     MOVF NVMDATH, W, ACCESS
120F0  22DA     ADDWFC 0xFDA, F, ACCESS
120F2  0E92     MOVLW 0x92
120F4  18DE     XORWF 0xFDE, W, ACCESS
120F6  A4D8     BTFSS 0xFD8, 2, ACCESS
120F8  D04E     BRA 0x2196
132:                           if (APP_GetEventIndexState(index) == EVENT_ON) {
120FA  504E     MOVF 0x4E, W, ACCESS
120FC  EC39     CALL 0x15872, 0
120FE  F0AC     NOP
12100  06E8     DECF 0xFE8, F, ACCESS
12102  A4D8     BTFSS 0xFD8, 2, ACCESS
12104  D024     BRA 0x214E
133:                               sendMessage4(OPC_ARON, m->bytes[0], m->bytes[1], m->bytes[2], m->bytes[3]);
12106  EE20     LFSR 2, 0x2
12108  F002     NOP
1210A  5046     MOVF NVMDAT, W, ACCESS
1210C  26D9     ADDWF 0xFD9, F, ACCESS
1210E  5047     MOVF NVMDATH, W, ACCESS
12110  22DA     ADDWFC 0xFDA, F, ACCESS
12112  50DF     MOVF 0xFDF, W, ACCESS
12114  6E25     MOVWF 0x25, ACCESS
12116  EE20     LFSR 2, 0x3
12118  F003     NOP
1211A  5046     MOVF NVMDAT, W, ACCESS
1211C  26D9     ADDWF 0xFD9, F, ACCESS
1211E  5047     MOVF NVMDATH, W, ACCESS
12120  22DA     ADDWFC 0xFDA, F, ACCESS
12122  50DF     MOVF 0xFDF, W, ACCESS
12124  6E26     MOVWF 0x26, ACCESS
12126  EE20     LFSR 2, 0x4
12128  F004     NOP
1212A  5046     MOVF NVMDAT, W, ACCESS
1212C  26D9     ADDWF 0xFD9, F, ACCESS
1212E  5047     MOVF NVMDATH, W, ACCESS
12130  22DA     ADDWFC 0xFDA, F, ACCESS
12132  50DF     MOVF 0xFDF, W, ACCESS
12134  6E27     MOVWF 0x27, ACCESS
12136  EE20     LFSR 2, 0x5
12138  F005     NOP
1213A  5046     MOVF NVMDAT, W, ACCESS
1213C  26D9     ADDWF 0xFD9, F, ACCESS
1213E  5047     MOVF NVMDATH, W, ACCESS
12140  22DA     ADDWFC 0xFDA, F, ACCESS
12142  50DF     MOVF 0xFDF, W, ACCESS
12144  6E28     MOVWF 0x28, ACCESS
12146  0E93     MOVLW 0x93
12148  EC92     CALL 0x15F24, 0
1214A  F0AF     NOP
134:                           } else {
1214C  D777     BRA 0x203C
135:                               sendMessage4(OPC_AROF, m->bytes[0], m->bytes[1], m->bytes[2], m->bytes[3]);
1214E  EE20     LFSR 2, 0x2
12150  F002     NOP
12152  5046     MOVF NVMDAT, W, ACCESS
12154  26D9     ADDWF 0xFD9, F, ACCESS
12156  5047     MOVF NVMDATH, W, ACCESS
12158  22DA     ADDWFC 0xFDA, F, ACCESS
1215A  50DF     MOVF 0xFDF, W, ACCESS
1215C  6E25     MOVWF 0x25, ACCESS
1215E  EE20     LFSR 2, 0x3
12160  F003     NOP
12162  5046     MOVF NVMDAT, W, ACCESS
12164  26D9     ADDWF 0xFD9, F, ACCESS
12166  5047     MOVF NVMDATH, W, ACCESS
12168  22DA     ADDWFC 0xFDA, F, ACCESS
1216A  50DF     MOVF 0xFDF, W, ACCESS
1216C  6E26     MOVWF 0x26, ACCESS
1216E  EE20     LFSR 2, 0x4
12170  F004     NOP
12172  5046     MOVF NVMDAT, W, ACCESS
12174  26D9     ADDWF 0xFD9, F, ACCESS
12176  5047     MOVF NVMDATH, W, ACCESS
12178  22DA     ADDWFC 0xFDA, F, ACCESS
1217A  50DF     MOVF 0xFDF, W, ACCESS
1217C  6E27     MOVWF 0x27, ACCESS
1217E  EE20     LFSR 2, 0x5
12180  F005     NOP
12182  5046     MOVF NVMDAT, W, ACCESS
12184  26D9     ADDWF 0xFD9, F, ACCESS
12186  5047     MOVF NVMDATH, W, ACCESS
12188  22DA     ADDWFC 0xFDA, F, ACCESS
1218A  50DF     MOVF 0xFDF, W, ACCESS
1218C  6E28     MOVWF 0x28, ACCESS
1218E  0E94     MOVLW 0x94
12190  EC92     CALL 0x15F24, 0
12192  F0AF     NOP
12194  D753     BRA 0x203C
136:                           }
137:                       } else {
138:                           if (APP_GetEventIndexState(index) == EVENT_ON) {
12196  504E     MOVF 0x4E, W, ACCESS
12198  EC39     CALL 0x15872, 0
1219A  F0AC     NOP
1219C  06E8     DECF 0xFE8, F, ACCESS
1219E  A4D8     BTFSS 0xFD8, 2, ACCESS
121A0  D018     BRA 0x21D2
139:                               sendMessage4(OPC_ARSON, nn.bytes.hi, nn.bytes.lo, m->bytes[2], m->bytes[3]);
121A2  C554     MOVFF 0x554, data1
121A4  F525     NOP
121A6  C553     MOVFF nn, data2
121A8  F526     NOP
121AA  EE20     LFSR 2, 0x4
121AC  F004     NOP
121AE  5046     MOVF NVMDAT, W, ACCESS
121B0  26D9     ADDWF 0xFD9, F, ACCESS
121B2  5047     MOVF NVMDATH, W, ACCESS
121B4  22DA     ADDWFC 0xFDA, F, ACCESS
121B6  50DF     MOVF 0xFDF, W, ACCESS
121B8  6E27     MOVWF 0x27, ACCESS
121BA  EE20     LFSR 2, 0x5
121BC  F005     NOP
121BE  5046     MOVF NVMDAT, W, ACCESS
121C0  26D9     ADDWF 0xFD9, F, ACCESS
121C2  5047     MOVF NVMDATH, W, ACCESS
121C4  22DA     ADDWFC 0xFDA, F, ACCESS
121C6  50DF     MOVF 0xFDF, W, ACCESS
121C8  6E28     MOVWF 0x28, ACCESS
121CA  0E9D     MOVLW 0x9D
121CC  EC92     CALL 0x15F24, 0
121CE  F0AF     NOP
140:                           } else {
121D0  D735     BRA 0x203C
141:                               sendMessage4(OPC_ARSOF, nn.bytes.hi, nn.bytes.lo, m->bytes[2], m->bytes[3]);
121D2  C554     MOVFF 0x554, data1
121D4  F525     NOP
121D6  C553     MOVFF nn, data2
121D8  F526     NOP
121DA  EE20     LFSR 2, 0x4
121DC  F004     NOP
121DE  5046     MOVF NVMDAT, W, ACCESS
121E0  26D9     ADDWF 0xFD9, F, ACCESS
121E2  5047     MOVF NVMDATH, W, ACCESS
121E4  22DA     ADDWFC 0xFDA, F, ACCESS
121E6  50DF     MOVF 0xFDF, W, ACCESS
121E8  6E27     MOVWF 0x27, ACCESS
121EA  EE20     LFSR 2, 0x5
121EC  F005     NOP
121EE  5046     MOVF NVMDAT, W, ACCESS
121F0  26D9     ADDWF 0xFD9, F, ACCESS
121F2  5047     MOVF NVMDATH, W, ACCESS
121F4  22DA     ADDWFC 0xFDA, F, ACCESS
121F6  50DF     MOVF 0xFDF, W, ACCESS
121F8  6E28     MOVWF 0x28, ACCESS
121FA  0E9E     MOVLW 0x9E
121FC  EC92     CALL 0x15F24, 0
121FE  F0AF     NOP
12200  D71D     BRA 0x203C
142:                           }
143:                       }
144:                       return PROCESSED;
145:                   default:
146:                       break;
147:               }
12202  EE20     LFSR 2, 0x1
12204  F001     NOP
12206  5046     MOVF NVMDAT, W, ACCESS
12208  26D9     ADDWF 0xFD9, F, ACCESS
1220A  5047     MOVF NVMDATH, W, ACCESS
1220C  22DA     ADDWFC 0xFDA, F, ACCESS
1220E  50DF     MOVF 0xFDF, W, ACCESS
12210  6E48     MOVWF VREGCON, ACCESS
12212  6A49     CLRF BORCON, ACCESS
12214  5049     MOVF BORCON, W, ACCESS
12216  0A00     XORLW 0x0
12218  A4D8     BTFSS 0xFD8, 2, ACCESS
1221A  D007     BRA 0x222A
1221C  5048     MOVF VREGCON, W, ACCESS
1221E  0A92     XORLW 0x92
12220  B4D8     BTFSC 0xFD8, 2, ACCESS
12222  D6FC     BRA 0x201C
12224  0A08     XORLW 0x8
12226  B4D8     BTFSC 0xFD8, 2, ACCESS
12228  D6F9     BRA 0x201C
148:               return NOT_PROCESSED;
1222A  0E00     MOVLW 0x0
149:           }
1222C  0012     RETURN 0
150:           
151:           #ifdef VLCB_DIAG
152:           /**
153:            * Provide the means to return the diagnostic data.
154:            * @param index the diagnostic index
155:            * @return a pointer to the diagnostic data or NULL if the data isn't available
156:            */
157:           static DiagnosticVal * producerGetDiagnostic(uint8_t index) {
15FE6  6E0A     MOVWF 0xA, ACCESS
158:               if (index > NUM_PRODUCER_DIAGNOSTICS) {
15FE8  0E01     MOVLW 0x1
15FEA  640A     CPFSGT 0xA, ACCESS
15FEC  D005     BRA 0x5FF8
159:                   return NULL;
15FEE  0E00     MOVLW 0x0
15FF0  6E08     MOVWF 0x8, ACCESS
15FF2  0E00     MOVLW 0x0
15FF4  6E09     MOVWF 0x9, ACCESS
15FF6  0012     RETURN 0
160:               }
161:               return &(producerDiagnostics[index]);
15FF8  500A     MOVF 0xA, W, ACCESS
15FFA  0D02     MULLW 0x2
15FFC  0ED0     MOVLW 0xD0
15FFE  24F3     ADDWF 0xFF3, W, ACCESS
16000  6E08     MOVWF 0x8, ACCESS
16002  0E05     MOVLW 0x5
16004  20F4     ADDWFC 0xFF4, W, ACCESS
16006  6E09     MOVWF 0x9, ACCESS
162:           }
16008  0012     RETURN 0
163:           
164:           /**
165:            * Bump the number produced diagnostic counter.
166:            */
167:           void incrementProducerCounter() {
168:               producerDiagnostics[PRODUCER_DIAG_NUMPRODUCED].asUint++;
16270  0105     MOVLB 0x5
16272  4BD2     INFSNZ 0xD2, F, BANKED
16274  2BD3     INCF 0xD3, F, BANKED
169:           }
16276  0012     RETURN 0
170:           #endif
171:           
172:           #ifdef VLCB_SERVICE
173:           /**
174:            * Return the service extended definition bytes.
175:            * @param id identifier for the extended service definition data
176:            * @return the ESD data
177:            */
178:           static uint8_t producerEsdData(uint8_t index) {
1615A  6E02     MOVWF ___rparam_used, ACCESS
179:               switch (index){
1615C  D004     BRA 0x6166
180:                   case 0:
181:                       return PRODUCER_EV_HAPPENING;
1615E  0E01     MOVLW 0x1
16160  0012     RETURN 0
182:                   case 1:
183:                       return HAPPENING_SIZE;
184:                   default:
185:                       return 0;
16162  0E00     MOVLW 0x0
16164  0012     RETURN 0
186:               }
16166  5002     MOVF ___rparam_used, W, ACCESS
16168  0A00     XORLW 0x0
1616A  B4D8     BTFSC 0xFD8, 2, ACCESS
1616C  D7F8     BRA 0x615E
1616E  0A01     XORLW 0x1
16170  B4D8     BTFSC 0xFD8, 2, ACCESS
16170  B4D8     BTFSC 0xFD8, 2, ACCESS
16170  B4D8     BTFSC 0xFD8, 2, ACCESS
187:           }
188:           #endif
189:           
---  C:/Users/ianwh/github/VLCBlib_PIC/event_consumer_simple.c  -----------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:            */
36:            /**
37:             * @author Ian Hogg 
38:             * @date May 2024
39:             * 
40:             */ 
41:            
42:            #include <xc.h>
43:            #include "vlcb.h"
44:            #include "event_consumer_simple.h"
45:            #include "event_teach.h"
46:            
47:            /**
48:             * @file
49:             * @brief
50:             * Implementation of the VLCB Event Consumer service.
51:             * @details
52:             * The service definition object is called eventConsumerService.
53:             * Process consumed events. Process Long and Short events.
54:             * Also handles events with data bytes if HANDLE_DATA_EVENTS is defined. The data is ignored.
55:             */
56:            
57:            static DiagnosticVal consumerDiagnostics[NUM_CONSUMER_DIAGNOSTICS+1];
58:            static void consumerPowerUp(void);
59:            static Processed consumerProcessMessage(Message * m);
60:            static DiagnosticVal * consumerGetDiagnostic(uint8_t index); 
61:            static uint8_t consumerEsdData(uint8_t index);
62:            
63:            extern uint8_t APP_isConsumedEvent(uint8_t eventIndex);
64:            uint8_t isConsumedEvent(uint8_t eventIndex);
65:                    
66:            /**
67:             * The service descriptor for the eventConsumer service. The application must include this
68:             * descriptor within the const Service * const services[] array and include the
69:             * necessary settings within module.h in order to make use of the event consumer
70:             * service.
71:             */
72:            const Service eventConsumerService = {
73:                SERVICE_ID_CONSUMER,// id
74:                1,                  // version
75:                NULL,               // factoryReset
76:                consumerPowerUp,    // powerUp
77:                consumerProcessMessage,               // processMessage
78:                NULL,               // poll
79:            #if defined(_18F66K80_FAMILY_)
80:                NULL,               // highIsr
81:                NULL,               // lowIsr
82:            #endif
83:            #ifdef VLCB_SERVICE
84:                consumerEsdData,               // Get ESD
85:            #endif
86:            #ifdef VLCB_DIAG
87:                consumerGetDiagnostic                // getDiagnostic
88:            #endif
89:            };
90:            
91:            static void consumerPowerUp(void) {
92:            #ifdef VLCB_DIAG
93:                uint8_t temp;
94:            
95:                for (temp=1; temp<=NUM_CONSUMER_DIAGNOSTICS; temp++) {
15DCE  0E01     MOVLW 0x1
15DD0  6E02     MOVWF ___rparam_used, ACCESS
96:            	consumerDiagnostics[temp].asUint = 0;
15DD2  5002     MOVF ___rparam_used, W, ACCESS
15DD4  0D02     MULLW 0x2
15DD6  0ED8     MOVLW 0xD8
15DD8  24F3     ADDWF 0xFF3, W, ACCESS
15DDA  6ED9     MOVWF 0xFD9, ACCESS
15DDC  0E05     MOVLW 0x5
15DDE  20F4     ADDWFC 0xFF4, W, ACCESS
15DE0  6EDA     MOVWF 0xFDA, ACCESS
15DE2  6ADE     CLRF 0xFDE, ACCESS
15DE4  6ADD     CLRF 0xFDD, ACCESS
97:                }
15DE6  2A02     INCF ___rparam_used, F, ACCESS
15DE8  0E01     MOVLW 0x1
15DEA  6402     CPFSGT ___rparam_used, ACCESS
15DEC  D7F2     BRA 0x5DD2
98:                consumerDiagnostics[CONSUMER_DIAG_COUNT].asUint = NUM_CONSUMER_DIAGNOSTICS;
15DEE  0E00     MOVLW 0x0
15DF0  0105     MOVLB 0x5
15DF2  6FD9     MOVWF CLCnSEL1, BANKED
15DF4  0E01     MOVLW 0x1
15DF6  6FD8     MOVWF CLCnSEL0, BANKED
99:            #endif
100:           }
15DF8  0012     RETURN 0
101:           /**
102:            * Process consumed events. Process Long and Short events.
103:            * Also handles events with data bytes if HANDLE_DATA_EVENTS is defined. The data is ignored.
104:            * 
105:            * @param m received message
106:            * @return PROCESSED if the message needs no further processing
107:            */
108:           static Processed consumerProcessMessage(Message *m) {
109:               Processed ret;
110:               uint8_t tableIndex;
111:               uint16_t enn;
112:               
113:               if (m->len < 5) return NOT_PROCESSED;
13224  C546     MOVFF m, FSR2
13226  F4D9     NOP
13228  C547     MOVFF 0x547, FSR2H
1322A  F4DA     NOP
1322C  0E05     MOVLW 0x5
1322E  60DF     CPFSLT 0xFDF, ACCESS
13230  D002     BRA 0x3236
13232  0E00     MOVLW 0x0
13234  0012     RETURN 0
114:               
115:               enn = ((uint16_t)m->bytes[0])*256+m->bytes[1];
13236  EE20     LFSR 2, 0x3
13238  F003     NOP
1323A  5046     MOVF NVMDAT, W, ACCESS
1323C  26D9     ADDWF 0xFD9, F, ACCESS
1323E  5047     MOVF NVMDATH, W, ACCESS
13240  22DA     ADDWFC 0xFDA, F, ACCESS
13242  50DF     MOVF 0xFDF, W, ACCESS
13244  6E48     MOVWF VREGCON, ACCESS
13246  EE20     LFSR 2, 0x2
13248  F002     NOP
1324A  5046     MOVF NVMDAT, W, ACCESS
1324C  26D9     ADDWF 0xFD9, F, ACCESS
1324E  5047     MOVF NVMDATH, W, ACCESS
13250  22DA     ADDWFC 0xFDA, F, ACCESS
13252  50DF     MOVF 0xFDF, W, ACCESS
13254  6E49     MOVWF BORCON, ACCESS
13256  5048     MOVF VREGCON, W, ACCESS
13258  6E4B     MOVWF HLVDCON1, ACCESS
1325A  C549     MOVFF 0x549, eventIndex
1325C  F54C     NOP
116:           
117:               switch (m->opc) {
1325E  D005     BRA 0x326A
118:                   case OPC_ASON:
119:           #ifdef HANDLE_DATA_EVENTS
120:                   case OPC_ASON1:
121:                   case OPC_ASON2:
122:                   case OPC_ASON3:
123:           #endif
124:           		enn = 0;
13260  0E00     MOVLW 0x0
13262  6E4C     MOVWF ZCDCON, ACCESS
13264  0E00     MOVLW 0x0
13266  6E4B     MOVWF HLVDCON1, ACCESS
125:           		// fall through
126:                   case OPC_ACON:
127:           #ifdef HANDLE_DATA_EVENTS
128:                   case OPC_ACON1:
129:                   case OPC_ACON2:
130:                   case OPC_ACON3:
131:           #endif
132:                       break;
13268  D03F     BRA 0x32E8
133:                   case OPC_ASOF:
134:           #ifdef HANDLE_DATA_EVENTS
135:                   case OPC_ASOF1:
136:                   case OPC_ASOF2:
137:                   case OPC_ASOF3:
138:           #endif
139:           		enn = 0;
140:           		// fall through
141:                   case OPC_ACOF:
142:           #ifdef HANDLE_DATA_EVENTS
143:                   case OPC_ACOF1:
144:                   case OPC_ACOF2:
145:                   case OPC_ACOF3:
146:           #endif
147:                       break;
148:                   default:
149:                       return NOT_PROCESSED;
150:               }
1326A  EE20     LFSR 2, 0x1
1326C  F001     NOP
1326E  5046     MOVF NVMDAT, W, ACCESS
13270  26D9     ADDWF 0xFD9, F, ACCESS
13272  5047     MOVF NVMDATH, W, ACCESS
13274  22DA     ADDWFC 0xFDA, F, ACCESS
13276  50DF     MOVF 0xFDF, W, ACCESS
13278  6E48     MOVWF VREGCON, ACCESS
1327A  6A49     CLRF BORCON, ACCESS
1327C  5049     MOVF BORCON, W, ACCESS
1327E  0A00     XORLW 0x0
13280  A4D8     BTFSS 0xFD8, 2, ACCESS
13282  D7D7     BRA 0x3232
13284  5048     MOVF VREGCON, W, ACCESS
13286  0A90     XORLW 0x90
13288  B4D8     BTFSC 0xFD8, 2, ACCESS
1328A  D02E     BRA 0x32E8
1328C  0A01     XORLW 0x1
1328E  B4D8     BTFSC 0xFD8, 2, ACCESS
13290  D02B     BRA 0x32E8
13292  0A09     XORLW 0x9
13294  B4D8     BTFSC 0xFD8, 2, ACCESS
13296  D7E4     BRA 0x3260
13298  0A01     XORLW 0x1
1329A  B4D8     BTFSC 0xFD8, 2, ACCESS
1329C  D7E1     BRA 0x3260
1329E  0A29     XORLW 0x29
132A0  B4D8     BTFSC 0xFD8, 2, ACCESS
132A2  D022     BRA 0x32E8
132A4  0A01     XORLW 0x1
132A6  B4D8     BTFSC 0xFD8, 2, ACCESS
132A8  D01F     BRA 0x32E8
132AA  0A09     XORLW 0x9
132AC  B4D8     BTFSC 0xFD8, 2, ACCESS
132AE  D7D8     BRA 0x3260
132B0  0A01     XORLW 0x1
132B2  B4D8     BTFSC 0xFD8, 2, ACCESS
132B4  D7D5     BRA 0x3260
132B6  0A69     XORLW 0x69
132B8  B4D8     BTFSC 0xFD8, 2, ACCESS
132BA  D016     BRA 0x32E8
132BC  0A01     XORLW 0x1
132BE  B4D8     BTFSC 0xFD8, 2, ACCESS
132C0  D013     BRA 0x32E8
132C2  0A09     XORLW 0x9
132C4  B4D8     BTFSC 0xFD8, 2, ACCESS
132C6  D7CC     BRA 0x3260
132C8  0A01     XORLW 0x1
132CA  B4D8     BTFSC 0xFD8, 2, ACCESS
132CC  D7C9     BRA 0x3260
132CE  0A29     XORLW 0x29
132D0  B4D8     BTFSC 0xFD8, 2, ACCESS
132D2  D00A     BRA 0x32E8
132D4  0A01     XORLW 0x1
132D6  B4D8     BTFSC 0xFD8, 2, ACCESS
132D8  D007     BRA 0x32E8
132DA  0A09     XORLW 0x9
132DC  B4D8     BTFSC 0xFD8, 2, ACCESS
132DE  D7C0     BRA 0x3260
132E0  0A01     XORLW 0x1
132E2  B4D8     BTFSC 0xFD8, 2, ACCESS
132E4  D7BD     BRA 0x3260
132E6  D7A5     BRA 0x3232
151:           
152:               tableIndex = findEvent(enn, ((uint16_t)m->bytes[2])*256+m->bytes[3]);
132E8  C54B     MOVFF enn, tableIndex
132EA  F519     NOP
132EC  C54C     MOVFF eventIndex, txFifoObj
132EE  F51A     NOP
132F0  EE20     LFSR 2, 0x5
132F2  F005     NOP
132F4  5046     MOVF NVMDAT, W, ACCESS
132F6  26D9     ADDWF 0xFD9, F, ACCESS
132F8  5047     MOVF NVMDATH, W, ACCESS
132FA  22DA     ADDWFC 0xFDA, F, ACCESS
132FC  50DF     MOVF 0xFDF, W, ACCESS
132FE  6E48     MOVWF VREGCON, ACCESS
13300  EE20     LFSR 2, 0x4
13302  F004     NOP
13304  5046     MOVF NVMDAT, W, ACCESS
13306  26D9     ADDWF 0xFD9, F, ACCESS
13308  5047     MOVF NVMDATH, W, ACCESS
1330A  22DA     ADDWFC 0xFDA, F, ACCESS
1330C  50DF     MOVF 0xFDF, W, ACCESS
1330E  6E49     MOVWF BORCON, ACCESS
13310  5048     MOVF VREGCON, W, ACCESS
13312  6E1B     MOVWF 0x1B, ACCESS
13314  C549     MOVFF 0x549, len
13316  F51C     NOP
13318  ECA5     CALL 0x1574A, 0
1331A  F0AB     NOP
1331C  6E4E     MOVWF 0x4E, ACCESS
153:               if (tableIndex == NO_INDEX) return NOT_PROCESSED;
1331E  284E     INCF 0x4E, W, ACCESS
13320  B4D8     BTFSC 0xFD8, 2, ACCESS
13322  D787     BRA 0x3232
154:           
155:               if (!isConsumedEvent(tableIndex)) {
13324  504E     MOVF 0x4E, W, ACCESS
13326  EC2E     CALL 0x1625C, 0
13328  F0B1     NOP
1332A  0900     IORLW 0x0
1332C  B4D8     BTFSC 0xFD8, 2, ACCESS
1332E  D781     BRA 0x3232
156:                   return NOT_PROCESSED;
157:               }
158:               ret = APP_processConsumedEvent(tableIndex, m);
13330  C546     MOVFF m, tableIndex
13332  F519     NOP
13334  C547     MOVFF 0x547, txFifoObj
13336  F51A     NOP
13338  504E     MOVF 0x4E, W, ACCESS
1333A  ECB7     CALL 0x1296E, 0
1333C  F094     NOP
1333E  6E4D     MOVWF 0x4D, ACCESS
159:               if (ret == PROCESSED) {
13340  044D     DECF 0x4D, W, ACCESS
13342  A4D8     BTFSS 0xFD8, 2, ACCESS
13344  D003     BRA 0x334C
160:                   consumerDiagnostics[CONSUMER_DIAG_NUMCONSUMED].asUint++;
13346  0105     MOVLB 0x5
13348  4BDA     INFSNZ CLCnSEL2, F, BANKED
1334A  2BDB     INCF CLCnSEL3, F, BANKED
161:               }
162:               return ret;
1334C  504D     MOVF 0x4D, W, ACCESS
163:           }
1334E  0012     RETURN 0
164:           
165:           /**
166:            * This simple service doesn't know if the event is consumed so hand off to the
167:            * application to determine.
168:            * @param eventIndex
169:            * @return true if the event is a consumed event
170:            */
171:           uint8_t isConsumedEvent(uint8_t eventIndex) {
1625C  6E1D     MOVWF 0x1D, ACCESS
172:               return APP_isConsumedEvent(eventIndex);
1625E  501D     MOVF 0x1D, W, ACCESS
16260  EC31     CALL 0x15462, 0
16262  F0AA     NOP
173:           }
16264  0012     RETURN 0
174:           
175:           #ifdef VLCB_DIAG
176:           /**
177:            * Provide the means to return the diagnostic data.
178:            * @param index the diagnostic index
179:            * @return a pointer to the diagnostic data or NULL if the data isn't available
180:            */
181:           static DiagnosticVal * consumerGetDiagnostic(uint8_t index) {
15E26  6E0C     MOVWF 0xC, ACCESS
182:               if (index > NUM_CONSUMER_DIAGNOSTICS) {
15E28  0E01     MOVLW 0x1
15E2A  640C     CPFSGT 0xC, ACCESS
15E2C  D005     BRA 0x5E38
183:                   return NULL;
15E2E  0E00     MOVLW 0x0
15E30  6E08     MOVWF 0x8, ACCESS
15E32  0E00     MOVLW 0x0
15E34  6E09     MOVWF 0x9, ACCESS
15E36  0012     RETURN 0
184:               }
185:               return &(consumerDiagnostics[index-1]);
15E38  500C     MOVF 0xC, W, ACCESS
15E3A  6E0A     MOVWF 0xA, ACCESS
15E3C  6A0B     CLRF 0xB, ACCESS
15E3E  90D8     BCF 0xFD8, 0, ACCESS
15E40  360A     RLCF 0xA, F, ACCESS
15E42  360B     RLCF 0xB, F, ACCESS
15E44  0ED6     MOVLW 0xD6
15E46  240A     ADDWF 0xA, W, ACCESS
15E48  6E08     MOVWF 0x8, ACCESS
15E4A  0E05     MOVLW 0x5
15E4C  200B     ADDWFC 0xB, W, ACCESS
15E4E  6E09     MOVWF 0x9, ACCESS
186:           }
15E50  0012     RETURN 0
187:           #endif
188:           
189:           #ifdef VLCB_SERVICE
190:           /**
191:            * Return the service extended definition bytes.
192:            * @param id identifier for the extended service definition data
193:            * @return the ESD data
194:            */
195:           static uint8_t consumerEsdData(uint8_t index) {
16238  6E02     MOVWF ___rparam_used, ACCESS
196:               switch (index){
1623A  D002     BRA 0x6240
197:                   case 0:
198:                       return CONSUMER_EV_NOT_SPECIFIED;
1623C  0E00     MOVLW 0x0
1623E  0012     RETURN 0
199:                   default:
200:                       return 0;
201:               }
16240  5002     MOVF ___rparam_used, W, ACCESS
16240  5002     MOVF ___rparam_used, W, ACCESS
16240  5002     MOVF ___rparam_used, W, ACCESS
202:           }
203:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/event_acknowledge.c  ---------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:            */
36:            /**
37:             * @author Ian Hogg 
38:             * @date Dec 2022
39:             * 
40:             */ 
41:            
42:            #include <xc.h>
43:            #include "vlcb.h"
44:            #include "event_acknowledge.h"
45:            #include "event_teach.h"
46:            #include "mns.h"
47:            
48:            /**
49:             * @file
50:             * @brief
51:             * Implementation of the VLCB EventAcknowledge Service.
52:             * @details
53:             * This service will send a ENACK message if the module has been taught to
54:             * consume the received event. The module must be in EVENT ACK mode. 
55:             * The service definition object is called eventAckService.
56:             */
57:            static void ackPowerUp(void);
58:            static Processed ackEventProcessMessage(Message * m);
59:            static Processed ackEventCheckLen(Message * m, uint8_t needed);
60:            #ifdef VLCB_DIAG
61:            static DiagnosticVal * ackGetDiagnostic(uint8_t code);
62:            static DiagnosticVal ackDiagnostics[NUM_ACK_DIAGNOSTICS+1];
63:            #endif
64:            
65:            extern uint8_t isConsumedEvent(uint8_t eventIndex);
66:            
67:            /**
68:             * The service descriptor for the Event Acknowledge service. The application must include this
69:             * descriptor within the const Service * const services[] array and include the
70:             * necessary settings within module.h in order to make use of the PIC event acknowledgement
71:             * service.
72:             */
73:            const Service eventAckService = {
74:                SERVICE_ID_EVENTACK,// id
75:                1,                  // version
76:                NULL,               // factoryReset
77:            #ifdef VLCB_DIAG
78:                ackPowerUp,         // powerUp
79:            #else
80:                NULL,
81:            #endif
82:                ackEventProcessMessage,                // processMessage
83:                NULL,               // poll
84:            #if defined(_18F66K80_FAMILY_)
85:                NULL,               // highIsr
86:                NULL,               // lowIsr
87:            #endif
88:            #ifdef VLCB_SERVICE
89:                NULL,               // Get ESD data
90:            #endif
91:            #ifdef VLCB_DIAG
92:                ackGetDiagnostic    // getDiagnostic
93:            #endif
94:            };
95:            
96:            #ifdef VLCB_DIAG
97:            static void ackPowerUp(void) {
98:                uint8_t i;
99:                
100:               // Clear the diagnostics
101:               for (i=1; i<= NUM_ACK_DIAGNOSTICS; i++) {
15DFA  0E01     MOVLW 0x1
15DFC  6E02     MOVWF ___rparam_used, ACCESS
102:                   ackDiagnostics[i].asUint = 0;
15DFE  5002     MOVF ___rparam_used, W, ACCESS
15E00  0D02     MULLW 0x2
15E02  0EDC     MOVLW 0xDC
15E04  24F3     ADDWF 0xFF3, W, ACCESS
15E06  6ED9     MOVWF 0xFD9, ACCESS
15E08  0E05     MOVLW 0x5
15E0A  20F4     ADDWFC 0xFF4, W, ACCESS
15E0C  6EDA     MOVWF 0xFDA, ACCESS
15E0E  6ADE     CLRF 0xFDE, ACCESS
15E10  6ADD     CLRF 0xFDD, ACCESS
103:               }
15E12  2A02     INCF ___rparam_used, F, ACCESS
15E14  0E01     MOVLW 0x1
15E16  6402     CPFSGT ___rparam_used, ACCESS
15E18  D7F2     BRA 0x5DFE
104:               ackDiagnostics[ACK_DIAG_COUNT].asUint = NUM_ACK_DIAGNOSTICS;
15E1A  0E00     MOVLW 0x0
15E1C  0105     MOVLB 0x5
15E1E  6FDD     MOVWF CLCnGLS1, BANKED
15E20  0E01     MOVLW 0x1
15E22  6FDC     MOVWF CLCnGLS0, BANKED
105:           }
15E24  0012     RETURN 0
106:           #endif
107:           
108:           /**
109:            * This only provides the functionality for event acknowledge.
110:            */
111:           static Processed ackEventProcessMessage(Message * m) {
112:               Word eventNN, eventEN;
113:               uint8_t eventIndex;
114:               int16_t ev;
115:               
116:           #ifdef VLCB_MODE
117:               if (m->opc == OPC_MODE) {      // 76 MODE - NN, mode
12406  EE20     LFSR 2, 0x1
12408  F001     NOP
1240A  5046     MOVF NVMDAT, W, ACCESS
1240C  26D9     ADDWF 0xFD9, F, ACCESS
1240E  5047     MOVF NVMDATH, W, ACCESS
12410  22DA     ADDWFC 0xFDA, F, ACCESS
12412  0E76     MOVLW 0x76
12414  18DE     XORWF 0xFDE, W, ACCESS
12416  A4D8     BTFSS 0xFD8, 2, ACCESS
12418  D03D     BRA 0x2494
118:                   if (ackEventCheckLen(m, 4) == PROCESSED) return PROCESSED;
1241A  C546     MOVFF m, m
1241C  F530     NOP
1241E  C547     MOVFF 0x547, evVal
12420  F531     NOP
12422  0E04     MOVLW 0x4
12424  6E32     MOVWF 0x32, ACCESS
12426  ECED     CALL 0x161DA, 0
12428  F0B0     NOP
1242A  06E8     DECF 0xFE8, F, ACCESS
1242C  A4D8     BTFSS 0xFD8, 2, ACCESS
1242E  D002     BRA 0x2434
12430  0E01     MOVLW 0x1
12432  0012     RETURN 0
119:                   if ((m->bytes[0] == nn.bytes.hi) && (m->bytes[1] == nn.bytes.lo)) {
12434  EE20     LFSR 2, 0x2
12436  F002     NOP
12438  5046     MOVF NVMDAT, W, ACCESS
1243A  26D9     ADDWF 0xFD9, F, ACCESS
1243C  5047     MOVF NVMDATH, W, ACCESS
1243E  22DA     ADDWFC 0xFDA, F, ACCESS
12440  50DE     MOVF 0xFDE, W, ACCESS
12442  1854     XORWF 0x54, W, ACCESS
12444  A4D8     BTFSS 0xFD8, 2, ACCESS
12446  D024     BRA 0x2490
12448  EE20     LFSR 2, 0x3
1244A  F003     NOP
1244C  5046     MOVF NVMDAT, W, ACCESS
1244E  26D9     ADDWF 0xFD9, F, ACCESS
12450  5047     MOVF NVMDATH, W, ACCESS
12452  22DA     ADDWFC 0xFDA, F, ACCESS
12454  5053     MOVF 0x53, W, ACCESS
12456  18DE     XORWF 0xFDE, W, ACCESS
12458  A4D8     BTFSS 0xFD8, 2, ACCESS
1245A  D01A     BRA 0x2490
120:                       if (m->bytes[2] == MODE_EVENT_ACK_ON) {
1245C  EE20     LFSR 2, 0x4
1245E  F004     NOP
12460  5046     MOVF NVMDAT, W, ACCESS
12462  26D9     ADDWF 0xFD9, F, ACCESS
12464  5047     MOVF NVMDATH, W, ACCESS
12466  22DA     ADDWFC 0xFDA, F, ACCESS
12468  0E0A     MOVLW 0xA
1246A  18DE     XORWF 0xFDE, W, ACCESS
1246C  A4D8     BTFSS 0xFD8, 2, ACCESS
1246E  D003     BRA 0x2476
121:                           // Do enter Learn mode
122:                           mode_flags |= FLAG_MODE_LEARN;
12470  0105     MOVLB 0x5
12472  81B4     BSF PRLOCK, 0, BANKED
12474  D7DD     BRA 0x2430
123:                           return PROCESSED;
124:                       } else if (m->bytes[2] == MODE_EVENT_ACK_OFF) {
12476  EE20     LFSR 2, 0x4
12478  F004     NOP
1247A  5046     MOVF NVMDAT, W, ACCESS
1247C  26D9     ADDWF 0xFD9, F, ACCESS
1247E  5047     MOVF NVMDATH, W, ACCESS
12480  22DA     ADDWFC 0xFDA, F, ACCESS
12482  0E0B     MOVLW 0xB
12484  18DE     XORWF 0xFDE, W, ACCESS
12486  A4D8     BTFSS 0xFD8, 2, ACCESS
12488  D003     BRA 0x2490
125:                           // Do exit Learn mode
126:                           mode_flags &= ~FLAG_MODE_LEARN;
1248A  0105     MOVLB 0x5
1248C  91B4     BCF PRLOCK, 0, BANKED
1248E  D7D0     BRA 0x2430
127:                           return PROCESSED;
128:                       }
129:                   } 
130:                   return NOT_PROCESSED;   // mode probably processed by other services
12490  0E00     MOVLW 0x0
12492  0012     RETURN 0
131:               }
132:           #endif
133:                       
134:               // Check that the Event Ack mode is set
135:               if (! (mode_flags & FLAG_MODE_EVENTACK)) {
12494  0105     MOVLB 0x5
12496  A3B4     BTFSS PRLOCK, 1, BANKED
12498  D7FB     BRA 0x2490
136:                   return NOT_PROCESSED;
137:               }
138:               // check that we have event consumption service
139:               if (findService(SERVICE_ID_CONSUMER) == NULL) {
1249A  0E06     MOVLW 0x6
1249C  EC44     CALL 0x14288, 0
1249E  F0A1     NOP
124A0  5002     MOVF ___rparam_used, W, ACCESS
124A2  1003     IORWF __activetblptr, W, ACCESS
124A4  B4D8     BTFSC 0xFD8, 2, ACCESS
124A6  D7F4     BRA 0x2490
140:                   return NOT_PROCESSED;
141:               }
142:               if (m->len < 5) {
124A8  C546     MOVFF m, FSR2
124AA  F4D9     NOP
124AC  C547     MOVFF 0x547, FSR2H
124AE  F4DA     NOP
124B0  0E05     MOVLW 0x5
124B2  60DF     CPFSLT 0xFDF, ACCESS
124B4  D001     BRA 0x24B8
124B6  D7EC     BRA 0x2490
143:                   return NOT_PROCESSED;
144:               }
145:               eventNN.bytes.hi = m->bytes[0];
124B8  EE20     LFSR 2, 0x2
124BA  F002     NOP
124BC  5046     MOVF NVMDAT, W, ACCESS
124BE  26D9     ADDWF 0xFD9, F, ACCESS
124C0  5047     MOVF NVMDATH, W, ACCESS
124C2  22DA     ADDWFC 0xFDA, F, ACCESS
124C4  50DF     MOVF 0xFDF, W, ACCESS
124C6  6E4E     MOVWF 0x4E, ACCESS
146:               eventNN.bytes.lo = m->bytes[1];
124C8  EE20     LFSR 2, 0x3
124CA  F003     NOP
124CC  5046     MOVF NVMDAT, W, ACCESS
124CE  26D9     ADDWF 0xFD9, F, ACCESS
124D0  5047     MOVF NVMDATH, W, ACCESS
124D2  22DA     ADDWFC 0xFDA, F, ACCESS
124D4  50DF     MOVF 0xFDF, W, ACCESS
124D6  6E4D     MOVWF 0x4D, ACCESS
147:               eventEN.bytes.hi = m->bytes[2];
124D8  EE20     LFSR 2, 0x4
124DA  F004     NOP
124DC  5046     MOVF NVMDAT, W, ACCESS
124DE  26D9     ADDWF 0xFD9, F, ACCESS
124E0  5047     MOVF NVMDATH, W, ACCESS
124E2  22DA     ADDWFC 0xFDA, F, ACCESS
124E4  50DF     MOVF 0xFDF, W, ACCESS
124E6  6E4B     MOVWF HLVDCON1, ACCESS
148:               eventEN.bytes.lo = m->bytes[3];
124E8  EE20     LFSR 2, 0x5
124EA  F005     NOP
124EC  5046     MOVF NVMDAT, W, ACCESS
124EE  26D9     ADDWF 0xFD9, F, ACCESS
124F0  5047     MOVF NVMDATH, W, ACCESS
124F2  22DA     ADDWFC 0xFDA, F, ACCESS
124F4  50DF     MOVF 0xFDF, W, ACCESS
124F6  6E4A     MOVWF HLVDCON0, ACCESS
149:               
150:               switch (m->opc) {
124F8  D017     BRA 0x2528
151:                   case OPC_ACON:
152:                   case OPC_ACOF:
153:                       // Long event
154:                       eventIndex = findEvent(eventNN.word, eventNN.word);
124FA  C54D     MOVFF eventNN, tableIndex
124FC  F519     NOP
124FE  C54E     MOVFF index, txFifoObj
12500  F51A     NOP
12502  C54D     MOVFF eventNN, eventNumber
12504  F51B     NOP
12506  C54E     MOVFF index, len
12508  F51C     NOP
1250A  ECA5     CALL 0x1574A, 0
1250C  F0AB     NOP
1250E  D00A     BRA 0x2524
155:                       break;
156:                   case OPC_ASON:
157:                   case OPC_ASOF:
158:                       // Short event
159:                       eventIndex = findEvent(0, eventNN.word);
12510  0E00     MOVLW 0x0
12512  6E1A     MOVWF 0x1A, ACCESS
12514  0E00     MOVLW 0x0
12516  6E19     MOVWF 0x19, ACCESS
12518  C54D     MOVFF eventNN, eventNumber
1251A  F51B     NOP
1251C  C54E     MOVFF index, len
1251E  F51C     NOP
12520  ECA5     CALL 0x1574A, 0
12522  F0AB     NOP
12524  6E4C     MOVWF ZCDCON, ACCESS
160:                       break;
12526  D01B     BRA 0x255E
161:                   default:
162:                       return NOT_PROCESSED;
163:               }
12528  EE20     LFSR 2, 0x1
1252A  F001     NOP
1252C  5046     MOVF NVMDAT, W, ACCESS
1252E  26D9     ADDWF 0xFD9, F, ACCESS
12530  5047     MOVF NVMDATH, W, ACCESS
12532  22DA     ADDWFC 0xFDA, F, ACCESS
12534  50DF     MOVF 0xFDF, W, ACCESS
12536  6E48     MOVWF VREGCON, ACCESS
12538  6A49     CLRF BORCON, ACCESS
1253A  5049     MOVF BORCON, W, ACCESS
1253C  0A00     XORLW 0x0
1253E  A4D8     BTFSS 0xFD8, 2, ACCESS
12540  D7A7     BRA 0x2490
12542  5048     MOVF VREGCON, W, ACCESS
12544  0A90     XORLW 0x90
12546  B4D8     BTFSC 0xFD8, 2, ACCESS
12548  D7D8     BRA 0x24FA
1254A  0A01     XORLW 0x1
1254C  B4D8     BTFSC 0xFD8, 2, ACCESS
1254E  D7D5     BRA 0x24FA
12550  0A09     XORLW 0x9
12552  B4D8     BTFSC 0xFD8, 2, ACCESS
12554  D7DD     BRA 0x2510
12556  0A01     XORLW 0x1
12558  B4D8     BTFSC 0xFD8, 2, ACCESS
1255A  D7DA     BRA 0x2510
1255C  D799     BRA 0x2490
164:               if (eventIndex != NO_INDEX) {
1255E  284C     INCF ZCDCON, W, ACCESS
12560  B4D8     BTFSC 0xFD8, 2, ACCESS
12562  D796     BRA 0x2490
165:                   // we have the event in the event table
166:                   // check that we have a consumed Action
167:                   if (isConsumedEvent(eventIndex)) {
12564  504C     MOVF ZCDCON, W, ACCESS
12566  EC2E     CALL 0x1625C, 0
12568  F0B1     NOP
1256A  0900     IORLW 0x0
1256C  B4D8     BTFSC 0xFD8, 2, ACCESS
1256E  D790     BRA 0x2490
168:                       // sent the ack
169:                       sendMessage7(OPC_ENACK, nn.bytes.hi, nn.bytes.lo, m->opc, m->bytes[0], m->bytes[1], m->bytes[2], m->bytes[3]);
12570  C554     MOVFF 0x554, data1
12572  F525     NOP
12574  C553     MOVFF nn, data2
12576  F526     NOP
12578  EE20     LFSR 2, 0x1
1257A  F001     NOP
1257C  5046     MOVF NVMDAT, W, ACCESS
1257E  26D9     ADDWF 0xFD9, F, ACCESS
12580  5047     MOVF NVMDATH, W, ACCESS
12582  22DA     ADDWFC 0xFDA, F, ACCESS
12584  50DF     MOVF 0xFDF, W, ACCESS
12586  6E27     MOVWF 0x27, ACCESS
12588  EE20     LFSR 2, 0x2
1258A  F002     NOP
1258C  5046     MOVF NVMDAT, W, ACCESS
1258E  26D9     ADDWF 0xFD9, F, ACCESS
12590  5047     MOVF NVMDATH, W, ACCESS
12592  22DA     ADDWFC 0xFDA, F, ACCESS
12594  50DF     MOVF 0xFDF, W, ACCESS
12596  6E28     MOVWF 0x28, ACCESS
12598  EE20     LFSR 2, 0x3
1259A  F003     NOP
1259C  5046     MOVF NVMDAT, W, ACCESS
1259E  26D9     ADDWF 0xFD9, F, ACCESS
125A0  5047     MOVF NVMDATH, W, ACCESS
125A2  22DA     ADDWFC 0xFDA, F, ACCESS
125A4  50DF     MOVF 0xFDF, W, ACCESS
125A6  6E29     MOVWF 0x29, ACCESS
125A8  EE20     LFSR 2, 0x4
125AA  F004     NOP
125AC  5046     MOVF NVMDAT, W, ACCESS
125AE  26D9     ADDWF 0xFD9, F, ACCESS
125B0  5047     MOVF NVMDATH, W, ACCESS
125B2  22DA     ADDWFC 0xFDA, F, ACCESS
125B4  50DF     MOVF 0xFDF, W, ACCESS
125B6  6E2A     MOVWF 0x2A, ACCESS
125B8  EE20     LFSR 2, 0x5
125BA  F005     NOP
125BC  5046     MOVF NVMDAT, W, ACCESS
125BE  26D9     ADDWF 0xFD9, F, ACCESS
125C0  5047     MOVF NVMDATH, W, ACCESS
125C2  22DA     ADDWFC 0xFDA, F, ACCESS
125C4  50DF     MOVF 0xFDF, W, ACCESS
125C6  6E2B     MOVWF 0x2B, ACCESS
125C8  0EE6     MOVLW 0xE6
125CA  EC68     CALL 0x15ED0, 0
125CC  F0AF     NOP
170:           #ifdef VLCB_DIAG
171:                       ackDiagnostics[ACK_DIAG_NUM_ACKED].asInt++;
125CE  0105     MOVLB 0x5
125CE  0105     MOVLB 0x5
125CE  0105     MOVLB 0x5
125CE  0105     MOVLB 0x5
172:           #endif
173:                   }
174:               }
175:               return NOT_PROCESSED;
176:           }
177:           
178:           /**
179:            * Check the message length is sufficient for the opcode.
180:            * @param m the message
181:            * @param needed the number of bytes needed
182:            * @return PROCESSED if the message is invalid and should not be processed further
183:            */
184:           static Processed ackEventCheckLen(Message * m, uint8_t needed) {
185:               return checkLen(m, needed, SERVICE_ID_EVENTACK);
161DA  C530     MOVFF m, opc
161DC  F52B     NOP
161DE  C531     MOVFF evVal, opc
161E0  F52C     NOP
161E2  C532     MOVFF needed, needed
161E4  F52D     NOP
161E6  0E09     MOVLW 0x9
161E8  6E2E     MOVWF 0x2E, ACCESS
161EA  ECA5     CALL 0x14B4A, 0
161EC  F0A5     NOP
186:           }
161EE  0012     RETURN 0
187:           
188:           #ifdef VLCB_DIAG
189:           /**
190:            * Provide the means to return the diagnostic data.
191:            * @param index the diagnostic index 1..NUM_CAN_DIAGNOSTSICS
192:            * @return a pointer to the diagnostic data or NULL if the data isn't available
193:            */
194:           static DiagnosticVal * ackGetDiagnostic(uint8_t index) {
16052  6E0A     MOVWF 0xA, ACCESS
195:               if (index > NUM_ACK_DIAGNOSTICS) {
16054  0E01     MOVLW 0x1
16056  640A     CPFSGT 0xA, ACCESS
16058  D005     BRA 0x6064
196:                   return NULL;
1605A  0E00     MOVLW 0x0
1605C  6E08     MOVWF 0x8, ACCESS
1605E  0E00     MOVLW 0x0
16060  6E09     MOVWF 0x9, ACCESS
16062  0012     RETURN 0
197:               }
198:               return &(ackDiagnostics[index]);
16064  500A     MOVF 0xA, W, ACCESS
16066  0D02     MULLW 0x2
16068  0EDC     MOVLW 0xDC
1606A  24F3     ADDWF 0xFF3, W, ACCESS
1606C  6E08     MOVWF 0x8, ACCESS
1606E  0E05     MOVLW 0x5
16070  20F4     ADDWFC 0xFF4, W, ACCESS
16072  6E09     MOVWF 0x9, ACCESS
199:           }
16074  0012     RETURN 0
200:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/can18_can_2.c  ---------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            
35:            */
36:            /**
37:             * @author Ian Hogg 
38:             * @date Dec 2022
39:             * 
40:             */ 
41:            #if defined(_18FXXQ83_FAMILY_)
42:            /**
43:             * @file
44:             * @brief
45:             * Implementation of the VLCB CAN Service. 
46:             * @details
47:             * Uses Controller Area Network to carry VLCB messages.
48:             * This implementation works with the PIC18 CAN_2.0 peripheral.
49:             * The service definition object is called canService.
50:             * The transport interface is called canTransport.
51:             * Performs self enumeration and CANID collision detection and re-enumeration.
52:             * Performs loopback of events for Consumes Own Event behaviour.
53:             * Collects diagnostic data to aid communications fault finding.
54:             * 
55:             * The CAN_2.0 peripheral has a TXQ and a TX FIFO. Here we don't use the TXQ since
56:             * frames are sent in ID (CANID) order which is not what is wanted for VLCB. We do
57:             * use the FIFO as frames are sent in order. 
58:             * We actually use 3 TX FIFOs. Two high priority FIFOs for sending self enumeration 
59:             * frames and a low priority FIFO for sending normal VLCB data frames.
60:             * 
61:             * We set up 1 RX Filters: One filter for all Normal (non extended frames) to 
62:             * put these frames into a RX FIFO.
63:             */
64:            #include <xc.h>
65:            #include <string.h> // for memcpy
66:            #include "vlcb.h"
67:            #include "module.h"
68:            #include "can.h"
69:            #include "mns.h"
70:            
71:            #include "nvm.h"
72:            #include "ticktime.h"
73:            #include "messageQueue.h"
74:            
75:            #define CAN1_BUFFERS_BASE_ADDRESS           0x3BB0  // Allows for 0x450 of CAN buffers (4+1+32+32)*(16) = 69*16 = 0x450
76:            // High priority transmit queue
77:            #define CAN1_TXQ_BUFFERS_BASE_ADDRESS       CAN1_BUFFERS_BASE_ADDRESS
78:            #define CAN1_TXQ_PAYLOAD_SIZE       8
79:            #define CAN1_TXQ_SIZE               4
80:            // RTR response FIFO
81:            #define CAN1_FIFO1_BUFFERS_BASE_ADDRESS     (CAN1_TXQ_BUFFERS_BASE_ADDRESS+((CAN1_TXQ_PAYLOAD_SIZE+8)*CAN1_TXQ_SIZE))
82:            #define CAN1_FIFO1_PAYLOAD_SIZE     8
83:            #define CAN1_FIFO1_SIZE             1
84:            // Transmit FIFO
85:            #define CAN1_FIFO2_BUFFERS_BASE_ADDRESS     (CAN1_FIFO1_BUFFERS_BASE_ADDRESS+((CAN1_FIFO1_PAYLOAD_SIZE+8)*CAN1_FIFO1_SIZE))
86:            #define CAN1_FIFO2_PAYLOAD_SIZE     8
87:            #define CAN1_FIFO2_SIZE             32
88:            // Receive FIFO
89:            #define CAN1_FIFO3_BUFFERS_BASE_ADDRESS     (CAN1_FIFO2_BUFFERS_BASE_ADDRESS+((CAN1_FIFO2_PAYLOAD_SIZE+8)*CAN1_FIFO2_SIZE))
90:            #define CAN1_FIFO3_PAYLOAD_SIZE     8
91:            #define CAN1_FIFO3_SIZE             32
92:            
93:            
94:            // Forward declarations
95:            static void canFactoryReset(void);
96:            static void canPowerUp(void);
97:            static void canPoll(void);
98:            static Processed canProcessMessage(Message * m);
99:            static void canIsr(void);
100:           static uint8_t canEsdData(uint8_t id);
101:           static void prepareSelfEnumResponse(void);
102:           
103:           enum CAN_OP_MODE_STATUS CAN1_OperationModeSet(const enum CAN_OP_MODES requestMode);
104:           
105:           #ifdef VLCB_DIAG
106:           static DiagnosticVal * canGetDiagnostic(uint8_t index);
107:           /**
108:            * The set of diagnostics for the CAN service
109:            */
110:           static DiagnosticVal canDiagnostics[NUM_CAN_DIAGNOSTICS+1];
111:           #endif
112:           
113:           /**
114:            * The service descriptor for the CAN service. The application must include this
115:            * descriptor within the const Service * const services[] array and include the
116:            * necessary settings within module.h in order to make use of the CAN
117:            * service.
118:            */
119:           const Service canService = {
120:               SERVICE_ID_CAN,     // id
121:               2,                  // version
122:               canFactoryReset,    // factoryReset
123:               canPowerUp,         // powerUp
124:               canProcessMessage,  // processMessage
125:               canPoll,            // poll
126:           #ifdef VLCB_SERVICE
127:               canEsdData,          // get ESD data
128:           #endif
129:           #ifdef VLCB_DIAG
130:               canGetDiagnostic    // getDiagnostic
131:           #endif
132:           };
133:           
134:           // forward declarations
135:           static SendResult canSendMessage(Message * mp);
136:           static MessageReceived canReceiveMessage(Message * m);
137:           
138:           /**
139:            * The transport descriptor for the CAN service. The application must set
140:            * const Transport * transport to the address of the CAN transport descriptor 
141:            * thus: transport = &canTransport;
142:            * In order to make use of the CAN transport.
143:            */
144:           const Transport canTransport = {
145:               canSendMessage,
146:               canReceiveMessage
147:           };
148:           
149:           /**
150:            * The CANID. This is persisted in non-volatile memory.
151:            */
152:           static uint8_t canId;
153:           
154:           
155:           static uint8_t  canTransmitFailed;
156:           
157:           /**
158:            *  Rx buffers used to store self consumed events
159:            */
160:           static Message rxBuffers[CAN_NUM_RXBUFFERS];
161:           static MessageQueue rxQueue;
162:           
163:           /**
164:            * Variables for self enumeration of CANID 
165:            */
166:           enum EnumerationState {
167:               NO_ENUMERATION,
168:               ENUMERATION_REQUIRED,
169:               ENUMERATION_IN_PROGRESS,
170:               ENUMERATION_IN_PROGRESS_TX_WAITING
171:           } EnumerationState;
172:           static TickValue  enumerationStartTime;
173:           static enum EnumerationState enumerationState; 
174:           static uint8_t    enumerationResults[ENUM_ARRAY_SIZE];
175:           #define arraySetBit( array, index ) ( array[index>>3] |= ( 1<<(index & 0x07) ) )
176:           
177:           // forward declarations
178:           static CanidResult setNewCanId(uint8_t newCanId);
179:           static void canInterruptHandler(void);
180:           static void startEnumeration(Boolean txWaiting);
181:           static void processEnumeration(void);
182:           static void handleSelfEnumeration(uint8_t canid);
183:           static void canFillRxFifo(void);
184:           #ifdef VLCB_DIAG
185:           static uint8_t getNumTxBuffersInUse(void);
186:           static uint8_t getNumRxBuffersInUse(void);
187:           #endif
188:           /*
189:            * The VLCB opcodes define a set of priorities for each opcode.
190:            * Here we map these priorities to the CAN priority bits.
191:            */
192:           // The CAN priorities
193:           static const uint8_t canPri[] = {
194:               0b00001011, // pLOW
195:               0b00001010, // pNORMAL
196:               0b00001001, // pABOVE
197:               0b00001000, // pHIGH
198:               0b00000000  // pSUPER
199:           };
200:           #define pSUPER  4   // Not message priority so supply here
201:           
202:           //
203:           //CAN SERVICE
204:           //
205:           /**
206:            * Perform the CAN factory reset. Just set the CANID to the default of 1.
207:            */
208:           static void canFactoryReset(void) {
209:               canId = CANID_DEFAULT;
16120  0E00     MOVLW 0x0
16122  0105     MOVLB 0x5
16124  6FAF     MOVWF OSCCON3, BANKED
210:               writeNVM(CANID_NVM_TYPE, CANID_ADDRESS, canId);
16126  0EFE     MOVLW 0xFE
16128  6E10     MOVWF 0x10, ACCESS
1612A  0E03     MOVLW 0x3
1612C  6E11     MOVWF 0x11, ACCESS
1612E  0E00     MOVLW 0x0
16130  6E12     MOVWF 0x12, ACCESS
16132  C5AF     MOVFF canId, hi
16134  F513     NOP
16136  0E00     MOVLW 0x0
16138  EC7E     CALL 0x156FC, 0
1613A  F0AB     NOP
211:           }
1613C  0012     RETURN 0
212:           
213:           #pragma warning disable 759
214:           /**
215:            * Do the CAN power up. Get the saved CANID, provision the CAN peripheral.
216:            * The CAN is configured for 125Kbs clocked from Fosc
217:            * 
218:            * The CAN bit timing is configured based on the base clock freq (Fosc) and divider.
219:            * So, for 125kbits/s, bit time = 8us, we need Tq = 500ns
220:            * To get 500nS, we set the CAN bit rate prescaler, to half the Fosc clock rate.
221:            * For example, 16MHz oscillator using PLL, Fosc is 64MHz, Tosc is 15.625nS, so 
222:            * we use prescaler of 1:63 to give Tq of 500nS  (15.625 x 63)
223:            * Having set Tq to 500nS, all other CAN timings are relative to Tq, so do not 
224:            * need changing with processor clock speed.
225:            * 
226:            * SJW is set to 1 Tq
227:            *  
228:            * Tq = 500ns, so 1 CAN bit-time equals 16Tq, Sync-segment = 1 Tq, Propagation 
229:            * time = 7 Tq  (this is based on bus length), Phase1 = 4 Tq, Phase2 = 4 Tq,
230:            * This results in giving a total bit time of (1+7+4+4) 16 Tq. 
231:            * 
232:            * The various FIFOs are configured thus:
233:            *   TEF - unused
234:            *   TXQ - size 4 used to transmit a RTR or potentially any other high priority message
235:            *   FIFO1 - size 1 used to transmit a high priority zero length message for RTR response.
236:            *   FIFO2 - Transmit FIFO size 32 low priority used to transmit regular data frames.
237:            *   FIFO3 - Receive FIFO size 32 used to receive regular data frames.
238:            *
239:            * Using FIFO sizes of 32 means there is no longer a need for a software
240:            * FIFO as used by the ECAN driver.
241:            * 
242:            * The following filter would also be configured:
243:            *   Filter 1. filters for normal (11 bit) data frames and store into FIFO3.
244:            *
245:            * The CAN 2.0 peripheral also has a TXBWS setting to force a delay between 
246:            * two consecutive transmissions. This is to prevent a single module swamping 
247:            * the bus. It is configured for 32 bit times i.e. a value of 5.
248:            * 
249:            * Interrupt of buffer overflow used to update diagnostics.
250:            * 
251:            */
252:           static void canPowerUp(void) {
253:               int temp;
254:               uint8_t* txFifoObj;
255:               
256:               // initialise the RX buffers
257:               rxQueue.readIndex = 0;
12CDA  0E00     MOVLW 0x0
12CDC  0105     MOVLB 0x5
12CDE  6FCD     MOVWF 0xCD, BANKED
258:               rxQueue.writeIndex = 0;
12CE0  0E00     MOVLW 0x0
12CE2  6FCE     MOVWF 0xCE, BANKED
259:               rxQueue.messages = rxBuffers;
12CE4  0E69     MOVLW 0x69
12CE6  6FCB     MOVWF 0xCB, BANKED
12CE8  0E06     MOVLW 0x6
12CEA  6FCC     MOVWF 0xCC, BANKED
260:               rxQueue.size = CAN_NUM_RXBUFFERS;
12CEC  0E08     MOVLW 0x8
12CEE  6FCF     MOVWF 0xCF, BANKED
261:               
262:               temp = readNVM(CANID_NVM_TYPE, CANID_ADDRESS);
12CF0  0EFE     MOVLW 0xFE
12CF2  6E08     MOVWF 0x8, ACCESS
12CF4  0E03     MOVLW 0x3
12CF6  6E09     MOVWF 0x9, ACCESS
12CF8  0E00     MOVLW 0x0
12CFA  6E0A     MOVWF 0xA, ACCESS
12CFC  0E00     MOVLW 0x0
12CFE  ECF3     CALL 0x151E6, 0
12D00  F0A8     NOP
12D02  C508     MOVFF index, evNum
12D04  F50E     NOP
12D06  C509     MOVFF d, interruptEnabled
12D08  F50F     NOP
263:               if (temp < 0) {
12D0A  AE0F     BTFSS 0xF, 7, ACCESS
12D0C  D004     BRA 0x2D16
264:                   // Unsure what to do
265:                   canId = CANID_DEFAULT;
12D0E  0E00     MOVLW 0x0
12D10  0105     MOVLB 0x5
12D12  6FAF     MOVWF OSCCON3, BANKED
266:               } else {
12D14  D002     BRA 0x2D1A
267:                   canId = (uint8_t)temp;
12D16  C50E     MOVFF evNum, canId
12D18  F5AF     NOP
268:               }
269:           #ifdef VLCB_DIAG
270:               // clear the diagnostic stats
271:               for (temp=1; temp<NUM_CAN_DIAGNOSTICS; temp++) {
12D1A  0E00     MOVLW 0x0
12D1C  6E0F     MOVWF 0xF, ACCESS
12D1E  0E01     MOVLW 0x1
12D20  6E0E     MOVWF 0xE, ACCESS
272:                   canDiagnostics[temp].asUint = 0;
12D22  90D8     BCF 0xFD8, 0, ACCESS
12D24  340E     RLCF 0xE, W, ACCESS
12D26  6ED9     MOVWF 0xFD9, ACCESS
12D28  340F     RLCF 0xF, W, ACCESS
12D2A  6EDA     MOVWF 0xFDA, ACCESS
12D2C  0EB1     MOVLW 0xB1
12D2E  26D9     ADDWF 0xFD9, F, ACCESS
12D30  0E06     MOVLW 0x6
12D32  22DA     ADDWFC 0xFDA, F, ACCESS
12D34  6ADE     CLRF 0xFDE, ACCESS
12D36  6ADD     CLRF 0xFDD, ACCESS
273:               }
12D38  4A0E     INFSNZ 0xE, F, ACCESS
12D3A  2A0F     INCF 0xF, F, ACCESS
12D3C  BE0F     BTFSC 0xF, 7, ACCESS
12D3E  D7F1     BRA 0x2D22
12D40  500F     MOVF 0xF, W, ACCESS
12D42  E104     BNZ 0x2D4C
12D44  0E12     MOVLW 0x12
12D46  5C0E     SUBWF 0xE, W, ACCESS
12D48  A0D8     BTFSS 0xFD8, 0, ACCESS
12D4A  D7EB     BRA 0x2D22
274:               canDiagnostics[CAN_DIAG_COUNT].asUint = NUM_CAN_DIAGNOSTICS;
12D4C  0E00     MOVLW 0x0
12D4E  0106     MOVLB 0x6
12D50  6FB2     MOVWF OSCSTAT, BANKED
12D52  0E12     MOVLW 0x12
12D54  6FB1     MOVWF OSCFRQ, BANKED
275:           #endif
276:               
277:               canTransmitFailed=0;
12D56  0E00     MOVLW 0x0
12D58  0105     MOVLB 0x5
12D5A  6FAE     MOVWF OSCCON2, BANKED
278:                   
279:               // initialise the CAN peripheral
280:               RB2PPS = 0x46;      // CANTX
12D5C  0E46     MOVLW 0x46
12D5E  0102     MOVLB 0x2
12D60  6F0B     MOVWF 0xB, BANKED
281:               CANRXPPS = 013 ;    // octal 1=PORTB 3 = port B3
12D62  0E0B     MOVLW 0xB
12D64  6F3D     MOVWF 0x3D, BANKED
282:               TRISBbits.TRISB2 = 0;  // CAN TX output
12D66  94C7     BCF 0xFC7, 2, ACCESS
283:               TRISBbits.TRISB3 = 1;  // CAN RX input
12D68  86C7     BSF 0xFC7, 3, ACCESS
284:               IPR5 = CAN_INTERRUPT_PRIORITY;    // CAN interrupts priority
12D6A  0E00     MOVLW 0x0
12D6C  0103     MOVLB 0x3
12D6E  6F67     MOVWF PMD7, BANKED
285:               /* Enable the CAN module */
286:               C1CONHbits.ON = 1;
12D70  0101     MOVLB 0x1
12D72  8F01     BSF ___rparam_used, 7, BANKED
287:               
288:               // Put module into Configuration mode.
289:               if (CAN_OP_MODE_REQUEST_SUCCESS == CAN1_OperationModeSet(CAN_CONFIGURATION_MODE)) {
12D74  0E04     MOVLW 0x4
12D76  ECF0     CALL 0x157E0, 0
12D78  F0AB     NOP
12D7A  0900     IORLW 0x0
12D7C  A4D8     BTFSS 0xFD8, 2, ACCESS
12D7E  D04E     BRA 0x2E1C
290:                   
291:                   
292:                   /* Initialise the C1FIFOBA with the start address of the CAN FIFO message object area. */
293:                   C1FIFOBA = CAN1_BUFFERS_BASE_ADDRESS;
12D80  0EB0     MOVLW 0xB0
12D82  0101     MOVLB 0x1
12D84  6F4C     MOVWF ZCDCON, BANKED
12D86  0E3B     MOVLW 0x3B
12D88  6F4D     MOVWF 0x4D, BANKED
12D8A  0E00     MOVLW 0x0
12D8C  6F4E     MOVWF 0x4E, BANKED
12D8E  0E00     MOVLW 0x0
12D90  6F4F     MOVWF 0x4F, BANKED
294:           
295:                   C1CONL = 0x00;      // CLKSEL0 disabled; DeviceNet filter disabled
12D92  0E00     MOVLW 0x0
12D94  6F00     MOVWF s, BANKED
296:                   C1CONH = 0x87;      // ON enabled; SIDL disabled; BUSY disabled; WFT T11 Filter; WAKFIL enabled;
12D96  0E87     MOVLW 0x87
12D98  6F01     MOVWF ___rparam_used, BANKED
297:                   C1CONU = 0x10;      // TXQEN enabled; STEF disabled; SERR2LOM disabled; ESIGM disabled; RTXAT disabled;
12D9A  0E10     MOVLW 0x10
12D9C  6F02     MOVWF ___rparam_used, BANKED
298:                   C1CONT = 0x50;      // TXBWS=5; ABAT=0; REQOP=0
12D9E  0E50     MOVLW 0x50
12DA0  6F03     MOVWF __activetblptr, BANKED
299:                   C1NBTCFGL = 0x00;   // SJW 1;
12DA2  0E00     MOVLW 0x0
12DA4  6F04     MOVWF __activetblptr, BANKED
300:                   C1NBTCFGH = 0x03;   // TSEG2 4;
12DA6  0E03     MOVLW 0x3
12DA8  6F05     MOVWF 0x5, BANKED
301:                   C1NBTCFGU = 0x02;   // TSEG1 3;
12DAA  0E02     MOVLW 0x2
12DAC  6F06     MOVWF 0x6, BANKED
302:                   C1NBTCFGT = 0x3F;   // BRP 15;
12DAE  0E3F     MOVLW 0x3F
12DB0  6F07     MOVWF 0x7, BANKED
303:                   // Used to transmit the RTR self enum request
304:                   C1TXQCONL = 0x10;   // TXATIE enabled; TXQEIE disabled; TXQNIE disabled;
12DB2  0E10     MOVLW 0x10
12DB4  6F50     MOVWF 0x50, BANKED
305:                   C1TXQCONH = 0x04;   // FRESET enabled; UINC disabled;
12DB6  0E04     MOVLW 0x4
12DB8  6F51     MOVWF 0x51, BANKED
306:                   C1TXQCONU = 0x6F;   // TXAT unlimited ; TXPRI 15 (high);
12DBA  0E6F     MOVLW 0x6F
12DBC  6F52     MOVWF 0x52, BANKED
307:                   C1TXQCONT = (((CAN1_TXQ_PAYLOAD_SIZE<32) ? (CAN1_TXQ_PAYLOAD_SIZE/4)-2 : 
12DBE  0E03     MOVLW 0x3
12DC0  6F53     MOVWF 0x53, BANKED
308:                                   (CAN1_TXQ_PAYLOAD_SIZE==32) ? 5 : 
309:                                                           (CAN1_TXQ_PAYLOAD_SIZE/16)+3) <<5 ) | (CAN1_TXQ_SIZE-1);   // PLSIZE 8; FSIZE 4;
310:           
311:                   // used to transmit the zero data length response to RTR
312:                   C1FIFOCON1L = 0x80; // TXEN enabled; RTREN enabled; RXTSEN disabled; TXATIE disabled; RXOVIE disabled; TFERFFIE enabled; TFHRFHIE disabled; TFNRFNIE disabled;
12DC2  0E80     MOVLW 0x80
12DC4  6F5C     MOVWF 0x5C, BANKED
313:                   C1FIFOCON1H = 0x04; // FRESET enabled; TXREQ disabled; UINC disabled;
12DC6  0E04     MOVLW 0x4
12DC8  6F5D     MOVWF 0x5D, BANKED
314:                   C1FIFOCON1U = 0x6F; // TXAT unlimited retransmission attempts; TXPRI 15 (high);
12DCA  0E6F     MOVLW 0x6F
12DCC  6F5E     MOVWF 0x5E, BANKED
315:                   C1FIFOCON1T = (((CAN1_FIFO1_PAYLOAD_SIZE<32) ? (CAN1_FIFO1_PAYLOAD_SIZE/4)-2 : 
12DCE  0E00     MOVLW 0x0
12DD0  6F5F     MOVWF 0x5F, BANKED
316:                                   (CAN1_FIFO1_PAYLOAD_SIZE==32) ? 5 : 
317:                                                           (CAN1_FIFO1_PAYLOAD_SIZE/16)+3) << 5) | (CAN1_FIFO1_SIZE-1);// PLSIZE 8; FSIZE 1;
318:           
319:                   // Normal TX FIFO
320:                   C1FIFOCON2L = 0x80; // TXEN enabled; RTREN disabled; RXTSEN disabled; TXATIE disabled; RXOVIE disabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled;
12DD2  0E80     MOVLW 0x80
12DD4  6F68     MOVWF PMD8, BANKED
321:                   C1FIFOCON2H = 0x04; // FRESET enabled; TXREQ disabled; UINC disabled;
12DD6  0E04     MOVLW 0x4
12DD8  6F69     MOVWF 0x69, BANKED
322:                   C1FIFOCON2U = 0x60; // TXAT unlimited retransmission attempts; TXPRI 0 (low);
12DDA  0E60     MOVLW 0x60
12DDC  6F6A     MOVWF MD1CON0, BANKED
323:                   C1FIFOCON2T = (((CAN1_FIFO2_PAYLOAD_SIZE<32) ? (CAN1_FIFO2_PAYLOAD_SIZE/4)-2 : 
12DDE  0E1F     MOVLW 0x1F
12DE0  6F6B     MOVWF MD1CON1, BANKED
324:                                   (CAN1_FIFO2_PAYLOAD_SIZE==32) ? 5 : 
325:                                                           (CAN1_FIFO2_PAYLOAD_SIZE/16)+3) << 5) | (CAN1_FIFO2_SIZE-1);// PLSIZE 8; FSIZE 32;
326:           
327:                   // Normal RX FIFO
328:                   C1FIFOCON3L = 0x08; // TXEN disabled; RTREN disabled; RXTSEN disabled; TXATIE disabled; RXOVIE enabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled;
12DE2  0E08     MOVLW 0x8
12DE4  6F74     MOVWF CM2CON0, BANKED
329:                   C1FIFOCON3H = 0x04; // FRESET enabled; TXREQ disabled; UINC disabled;
12DE6  0E04     MOVLW 0x4
12DE8  6F75     MOVWF CM2CON1, BANKED
330:                   C1FIFOCON3U = 0x00; // TXAT retransmission disabled; TXPRI 0;
12DEA  0E00     MOVLW 0x0
12DEC  6F76     MOVWF CM2NCH, BANKED
331:                   C1FIFOCON3T = (((CAN1_FIFO3_PAYLOAD_SIZE<32) ? (CAN1_FIFO3_PAYLOAD_SIZE/4)-2 : 
12DEE  0E1F     MOVLW 0x1F
12DF0  6F77     MOVWF CM2PCH, BANKED
332:                                   (CAN1_FIFO3_PAYLOAD_SIZE==32) ? 5 : 
333:                                                           (CAN1_FIFO3_PAYLOAD_SIZE/16)+3) << 5) | (CAN1_FIFO3_SIZE-1); // PLSIZE 8; FSIZE 32;
334:           
335:                   // Filter 0 for All Normal messages
336:                   C1FLTOBJ0L = 0x00;
12DF2  0E00     MOVLW 0x0
12DF4  6F8C     MOVWF SPI1CLK, BANKED
337:                   C1FLTOBJ0H = 0x00;
12DF6  0E00     MOVLW 0x0
12DF8  6F8D     MOVWF SPI2RXB, BANKED
338:                   C1FLTOBJ0U = 0x00;
12DFA  0E00     MOVLW 0x0
12DFC  6F8E     MOVWF SPI2TXB, BANKED
339:                   C1FLTOBJ0T = 0x00;  // EXIDE clear: allow standard ID only
12DFE  0E00     MOVLW 0x0
12E00  6F8F     MOVWF SPI2TCNT, BANKED
340:                   C1MASK0L = 0x00;
12E02  0E00     MOVLW 0x0
12E04  6F90     MOVWF SPI2TCNTH, BANKED
341:                   C1MASK0H = 0x00;
12E06  0E00     MOVLW 0x0
12E08  6F91     MOVWF SPI2CON0, BANKED
342:                   C1MASK0U = 0x00;
12E0A  0E00     MOVLW 0x0
12E0C  6F92     MOVWF SPI2CON1, BANKED
343:                   C1MASK0T = 0x40;    // MIDE set: filter on EXIDE
12E0E  0E40     MOVLW 0x40
12E10  6F93     MOVWF SPI2CON2, BANKED
344:                   C1FLTCON0L = 0x83;  // FLTEN0 enabled; F1BP FIFO 3 - the normal RX FIFO
12E12  0E83     MOVLW 0x83
12E14  6F80     MOVWF SPI1RXB, BANKED
345:                   
346:                   /* Place CAN1 module in Normal Operation mode */
347:                   (void)CAN1_OperationModeSet(CAN_NORMAL_2_0_MODE);
12E16  0E06     MOVLW 0x6
12E18  ECF0     CALL 0x157E0, 0
12E1A  F0AB     NOP
348:               }
349:           
350:               // Preload FIFO1 with a zero length packet containing CANID for  use in self enumeration
351:               prepareSelfEnumResponse();
12E1C  ECF7     CALL 0x14DEE, 0
12E1E  F0A6     NOP
352:               // Initialise enumeration control variables
353:               enumerationState = NO_ENUMERATION;
12E20  0E00     MOVLW 0x0
12E22  0105     MOVLB 0x5
12E24  6FAC     MOVWF ACTCON, BANKED
354:               enumerationStartTime.val = tickGet();
12E26  ECD8     CALL 0x153B0, 0
12E28  F0A9     NOP
12E2A  C502     MOVFF i, enumerationStartTime
12E2C  F578     NOP
12E2E  C503     MOVFF opc, 0x579
12E30  F579     NOP
12E32  C504     MOVFF s, 0x57A
12E34  F57A     NOP
12E36  C505     MOVFF i, 0x57B
12E38  F57B     NOP
355:               
356:               IPR0bits.CANIP = 0;
12E3A  0103     MOVLB 0x3
12E3C  9D62     BCF PMD2, 6, BANKED
357:               PIR0bits.CANIF = 0;
12E3E  9CAE     BCF 0xFAE, 6, ACCESS
358:               C1INTUbits.TXIE = 1;          // enable main interrupt
12E40  0101     MOVLB 0x1
12E42  811E     BSF 0x1E, 0, BANKED
359:               C1INTTbits.RXOVIE = 1;        // enable receive overrun interrupt
12E44  871F     BSF 0x1F, 3, BANKED
360:               C1INTTbits.IVMIE = 1;         // Enable interrupts for invalid message
12E46  8F1F     BSF 0x1F, 7, BANKED
361:           
362:               PIE0bits.CANIE = 1; // Enable the CAN master interrupt
12E48  8C9E     BSF 0xF9E, 6, ACCESS
363:           }
12E4A  0012     RETURN 0
364:           
365:           /**
366:            * Handle the RX overrun and receive error interrupts.
367:            */
368:           void __interrupt(irq(IRQ_CAN), base(IVT_BASE)) receiveOverrun(void) {
369:               if (C1FIFOSTA3Lbits.RXOVIF == 1) {
16100  0101     MOVLB 0x1
16102  A778     BTFSS WDTCON0, 3, BANKED
16104  D005     BRA 0x6110
16106  0106     MOVLB 0x6
16108  4BC1     INFSNZ 0xC1, F, BANKED
1610A  2BC2     INCF 0xC2, F, BANKED
370:           #ifdef VLCB_DIAG
371:                   canDiagnostics[CAN_DIAG_RX_BUFFER_OVERRUN].asUint++;
16106  0106     MOVLB 0x6
16108  4BC1     INFSNZ 0xC1, F, BANKED
1610A  2BC2     INCF 0xC2, F, BANKED
372:           #endif
373:                   C1FIFOSTA3Lbits.RXOVIF = 0;
1610C  0101     MOVLB 0x1
1610E  9778     BCF WDTCON0, 3, BANKED
374:               }
375:               if (C1INTHbits.IVMIF == 1) {
16110  AF1D     BTFSS 0x1D, 7, BANKED
16112  0011     RETFIE 1
16114  0106     MOVLB 0x6
16116  4BB3     INFSNZ OSCEN, F, BANKED
376:           #ifdef VLCB_DIAG
377:                   canDiagnostics[CAN_DIAG_RX_ERRORS].asUint++;
16114  0106     MOVLB 0x6
16116  4BB3     INFSNZ OSCEN, F, BANKED
16118  2BB4     INCF PRLOCK, F, BANKED
1611A  0101     MOVLB 0x1
1611C  9F1D     BCF 0x1D, 7, BANKED
378:           #endif
379:                   C1INTHbits.IVMIF = 0;
1611A  0101     MOVLB 0x1
1611C  9F1D     BCF 0x1D, 7, BANKED
380:               }
381:           }
1611E  0011     RETFIE 1
16204  AEB1     BTFSS 0xFB1, 7, ACCESS
16206  0011     RETFIE 1
382:           
383:           
384:           /**
385:            * Put a self enum response into FIFO1. This is just a zero length message.
386:            */
387:           void prepareSelfEnumResponse(void) {
388:               uint8_t* txFifoObj = (uint8_t*) C1FIFOUA1;
14DEE  C164     MOVFF C1FIFOUA1, i
14DF0  F502     NOP
14DF2  C165     MOVFF C1FIFOUA1H, opc
14DF4  F503     NOP
389:               
390:               while (C1FIFOSTA1Lbits.TFNRFNIF == 1) { // FIFO1 not full
14DF6  D02D     BRA 0x4E52
14E52  0101     MOVLB 0x1
391:                   // Refill with self enum response
392:                   txFifoObj[0] = (canId & 0x7F);      // Put ID
14DF8  0105     MOVLB 0x5
14DFA  51AF     MOVF OSCCON3, W, BANKED
14DFC  0B7F     ANDLW 0x7F
14DFE  C502     MOVFF i, FSR2
14E00  F4D9     NOP
14E02  C503     MOVFF opc, FSR2H
14E04  F4DA     NOP
14E06  6EDF     MOVWF 0xFDF, ACCESS
393:                   txFifoObj[1] = 0;       // high priority
14E08  EE20     LFSR 2, 0x1
14E0A  F001     NOP
14E0C  5002     MOVF ___rparam_used, W, ACCESS
14E0E  26D9     ADDWF 0xFD9, F, ACCESS
14E10  5003     MOVF __activetblptr, W, ACCESS
14E12  22DA     ADDWFC 0xFDA, F, ACCESS
14E14  6ADF     CLRF 0xFDF, ACCESS
394:                   txFifoObj[4] = 0;       // Standard frame, Zero data length DLC
14E16  EE20     LFSR 2, 0x4
14E18  F004     NOP
14E1A  5002     MOVF ___rparam_used, W, ACCESS
14E1C  26D9     ADDWF 0xFD9, F, ACCESS
14E1E  5003     MOVF __activetblptr, W, ACCESS
14E20  22DA     ADDWFC 0xFDA, F, ACCESS
14E22  6ADF     CLRF 0xFDF, ACCESS
395:                   txFifoObj[5] = 0;       // No sequence number
14E24  EE20     LFSR 2, 0x5
14E26  F005     NOP
14E28  5002     MOVF ___rparam_used, W, ACCESS
14E2A  26D9     ADDWF 0xFD9, F, ACCESS
14E2C  5003     MOVF __activetblptr, W, ACCESS
14E2E  22DA     ADDWFC 0xFDA, F, ACCESS
14E30  6ADF     CLRF 0xFDF, ACCESS
396:                   txFifoObj[6] = 0;       // No sequence number
14E32  EE20     LFSR 2, 0x6
14E34  F006     NOP
14E36  5002     MOVF ___rparam_used, W, ACCESS
14E38  26D9     ADDWF 0xFD9, F, ACCESS
14E3A  5003     MOVF __activetblptr, W, ACCESS
14E3C  22DA     ADDWFC 0xFDA, F, ACCESS
14E3E  6ADF     CLRF 0xFDF, ACCESS
397:                   txFifoObj[7] = 0;       // No sequence number
14E40  EE20     LFSR 2, 0x7
14E42  F007     NOP
14E44  5002     MOVF ___rparam_used, W, ACCESS
14E46  26D9     ADDWF 0xFD9, F, ACCESS
14E48  5003     MOVF __activetblptr, W, ACCESS
14E4A  22DA     ADDWFC 0xFDA, F, ACCESS
14E4C  6ADF     CLRF 0xFDF, ACCESS
398:                   C1FIFOCON1Hbits.UINC = 1; // ready for future transmit
14E4E  0101     MOVLB 0x1
14E50  815D     BSF 0x5D, 0, BANKED
14E50  815D     BSF 0x5D, 0, BANKED
14E50  815D     BSF 0x5D, 0, BANKED
14E50  815D     BSF 0x5D, 0, BANKED
14E50  815D     BSF 0x5D, 0, BANKED
399:               }
400:           }
401:           
402:           /**
403:            * Process the CAN specific VLCB messages. The VLCB CAN specification
404:            * describes two opcodes ENUM and CANID but this implementation does not 
405:            * require these as both are handled automatically.
406:            * @param m the message to be processed
407:            * @return PROCESSED is the message is processed, NOT_PROCESSED otherwise
408:            */
409:           static Processed canProcessMessage(Message * m) {
410:               // check NN matches us
411:               if (m->len < 3) return NOT_PROCESSED;
1431E  C546     MOVFF m, FSR2
14320  F4D9     NOP
14322  C547     MOVFF 0x547, FSR2H
14324  F4DA     NOP
14326  0E03     MOVLW 0x3
14328  60DF     CPFSLT 0xFDF, ACCESS
1432A  D002     BRA 0x4330
1432C  0E00     MOVLW 0x0
1432E  0012     RETURN 0
412:               if (m->bytes[0] != nn.bytes.hi) return NOT_PROCESSED;
14330  EE20     LFSR 2, 0x2
14332  F002     NOP
14334  5046     MOVF NVMDAT, W, ACCESS
14336  26D9     ADDWF 0xFD9, F, ACCESS
14338  5047     MOVF NVMDATH, W, ACCESS
1433A  22DA     ADDWFC 0xFDA, F, ACCESS
1433C  50DE     MOVF 0xFDE, W, ACCESS
1433E  1854     XORWF 0x54, W, ACCESS
14340  A4D8     BTFSS 0xFD8, 2, ACCESS
14342  D7F4     BRA 0x432C
413:               if (m->bytes[1] != nn.bytes.lo) return NOT_PROCESSED;
14344  EE20     LFSR 2, 0x3
14346  F003     NOP
14348  5046     MOVF NVMDAT, W, ACCESS
1434A  26D9     ADDWF 0xFD9, F, ACCESS
1434C  5047     MOVF NVMDATH, W, ACCESS
1434E  22DA     ADDWFC 0xFDA, F, ACCESS
14350  5053     MOVF 0x53, W, ACCESS
14352  18DE     XORWF 0xFDE, W, ACCESS
14354  A4D8     BTFSS 0xFD8, 2, ACCESS
14356  D7EA     BRA 0x432C
14358  D017     BRA 0x4388
414:               
415:               // Handle any CAN specific OPCs
416:               switch (m->opc) {
417:                   case OPC_ENUM:
418:                       // ignore request
419:                       return PROCESSED;
1435A  0E01     MOVLW 0x1
1435C  0012     RETURN 0
420:                   case OPC_CANID:
421:                       if (m->len < 4) {
1435E  C546     MOVFF m, FSR2
14360  F4D9     NOP
14362  C547     MOVFF 0x547, FSR2H
14364  F4DA     NOP
14366  0E04     MOVLW 0x4
14368  60DF     CPFSLT 0xFDF, ACCESS
1436A  D7F7     BRA 0x435A
422:           #ifdef VLCB_GRSP
423:                           sendMessage5(OPC_GRSP, nn.bytes.hi, nn.bytes.lo, OPC_CANID, SERVICE_ID_MNS, CMDERR_INV_CMD);
1436C  C554     MOVFF 0x554, data1
1436E  F525     NOP
14370  C553     MOVFF nn, data2
14372  F526     NOP
14374  0E75     MOVLW 0x75
14376  6E27     MOVWF 0x27, ACCESS
14378  0E01     MOVLW 0x1
1437A  6E28     MOVWF 0x28, ACCESS
1437C  0E01     MOVLW 0x1
1437E  6E29     MOVWF 0x29, ACCESS
14380  0EAF     MOVLW 0xAF
14382  EC7D     CALL 0x15EFA, 0
14384  F0AF     NOP
14386  D7E9     BRA 0x435A
424:           #endif
425:                           return PROCESSED;
426:                       }
427:                       // ignore request
428:                       return PROCESSED;
429:                   default:
430:                       break;
431:               }
14388  EE20     LFSR 2, 0x1
1438A  F001     NOP
1438C  5046     MOVF NVMDAT, W, ACCESS
1438E  26D9     ADDWF 0xFD9, F, ACCESS
14390  5047     MOVF NVMDATH, W, ACCESS
14392  22DA     ADDWFC 0xFDA, F, ACCESS
14394  50DF     MOVF 0xFDF, W, ACCESS
14396  6E48     MOVWF VREGCON, ACCESS
14398  6A49     CLRF BORCON, ACCESS
1439A  5049     MOVF BORCON, W, ACCESS
1439C  0A00     XORLW 0x0
1439E  A4D8     BTFSS 0xFD8, 2, ACCESS
143A0  D7C5     BRA 0x432C
143A2  5048     MOVF VREGCON, W, ACCESS
143A4  0A5D     XORLW 0x5D
143A6  B4D8     BTFSC 0xFD8, 2, ACCESS
143A8  D7D8     BRA 0x435A
143AA  0A28     XORLW 0x28
143AC  B4D8     BTFSC 0xFD8, 2, ACCESS
143AC  B4D8     BTFSC 0xFD8, 2, ACCESS
143AC  B4D8     BTFSC 0xFD8, 2, ACCESS
432:               return NOT_PROCESSED;
433:           }
434:           
435:           /**
436:            * The poll routine just continues any self enumeration that is in progress.
437:            * I originally also tried to extend the error counters from 8bit to 16bit for
438:            * the diagnostic counters but this is probably unnecessary and takes too much
439:            * CPU time.
440:            */
441:           void canPoll() {
442:               uint8_t t8;
443:               
444:               processEnumeration();   // Continue or finish CANID enumeration if required
1628A  ECD2     CALL 0x12FA4, 0
1628C  F097     NOP
445:           /*    
446:               // copy the counts to diagnostic data and extend to 16bits
447:               t8 = C1BDIAG0Hbits.NTERRCNT; // TX_ERRORS
448:               if (canDiagnostics[CAN_DIAG_TX_ERRORS].asBytes.lo > t8) {
449:                   canDiagnostics[CAN_DIAG_TX_ERRORS].asBytes.hi++;
450:               }
451:               canDiagnostics[CAN_DIAG_TX_ERRORS].asBytes.lo = t8;
452:               
453:               t8 = C1BDIAG0Lbits.NRERRCNT; // RX_ERRORS
454:               if (canDiagnostics[CAN_DIAG_RX_ERRORS].asBytes.lo > t8) {
455:                   canDiagnostics[CAN_DIAG_RX_ERRORS].asBytes.hi++;
456:               }
457:               canDiagnostics[CAN_DIAG_RX_ERRORS].asBytes.lo = t8;*/
458:           }
1628E  0012     RETURN 0
459:           
460:           #ifdef VLCB_SERVICE
461:           /**
462:            * Return the service extended definition bytes.
463:            * @param id identifier for the extended service definition data
464:            * @return the ESD data
465:            */
466:           uint8_t canEsdData(uint8_t id) {
161C4  6E02     MOVWF ___rparam_used, ACCESS
467:               switch(id) {
161C6  D004     BRA 0x61D0
468:                   case 1:
469:                       return CAN_HW_PIC_CAN_2_0;
161C8  0E02     MOVLW 0x2
161CA  0012     RETURN 0
470:                   default:
471:                       return 0;
161CC  0E00     MOVLW 0x0
161CE  0012     RETURN 0
472:               }
161D0  5002     MOVF ___rparam_used, W, ACCESS
161D2  0A01     XORLW 0x1
161D4  B4D8     BTFSC 0xFD8, 2, ACCESS
161D4  B4D8     BTFSC 0xFD8, 2, ACCESS
161D4  B4D8     BTFSC 0xFD8, 2, ACCESS
473:           }
474:           #endif
475:           #ifdef VLCB_DIAG
476:           /**
477:            * Provide the means to return the diagnostic data. Diagnostics supported:
478:            *   RX_ERRORS          0x00  CAN RX error counter.             Supported
479:            *   TX_ERRORS          0x01  CAN TX error counter.             Supported
480:            *   STATUS             0x02  last CAN status byte (TBA)        Supported
481:            *   TX_BUFFER_USAGE    0x03  Tx buffer usage count             Supported
482:            *   TX_BUFFER_OVERRUN  0x04  Tx buffer overrun count           Supported
483:            *   TX_MESSAGES        0x05  TX message count                  Supported
484:            *   RX_BUFFER_USAGE    0x06  RX buffer usage count             Supported
485:            *   RX_BUFFER_OVERRUN  0x07  RX buffer overrun count           Supported
486:            *   RX_MESSAGES        0x08  RX message counter                Supported
487:            *   ERROR_FRAMES_DET   0x09  CAN error frames detected 
488:            *   ERROR_FRAMES_GEN   0x0A  CAN error frames generated (both active and passive ?)
489:            *   LOST_ARRBITARTAION 0x0B  CAN arbitration was lost count    Supported
490:            *   CANID_ENUMS        0x0C  number of CANID enumerations      Supported
491:            *   CANID_CONFLICTS    0x0D  number of CANID conflicts         Supported
492:            *   CANID_CHANGES      0x0E  Number of CANID changes           Supported
493:            *   CANID_ENUMS_FAIL   0x0F  Number of CANID enumeration fails Supported
494:            * 
495:            * @param index the diagnostic index 1..NUM_CAN_DIAGNOSTSICS
496:            * @return a pointer to the diagnostic data or NULL if the data isn't available
497:            */
498:           static DiagnosticVal * canGetDiagnostic(uint8_t index) {
14772  6E0B     MOVWF 0xB, ACCESS
499:               int16_t i16;
500:               
501:               if (index > NUM_CAN_DIAGNOSTICS) {
14774  0E12     MOVLW 0x12
14776  640B     CPFSGT 0xB, ACCESS
14778  D024     BRA 0x47C2
502:                   return NULL;
1477A  0E00     MOVLW 0x0
1477C  6E08     MOVWF 0x8, ACCESS
1477E  0E00     MOVLW 0x0
14780  6E09     MOVWF 0x9, ACCESS
14782  0012     RETURN 0
503:               }
504:               switch (index) {
505:                   case CAN_DIAG_STATUS:
506:                       canDiagnostics[CAN_DIAG_STATUS].asUint = C1TRECU;
14784  C136     MOVFF C1TRECU, 0x6B7
14786  F6B7     NOP
14788  0106     MOVLB 0x6
1478A  6BB8     CLRF DMA3PR, BANKED
507:                       break;
1478C  D02A     BRA 0x47E2
508:                   case CAN_DIAG_TX_BUFFER_USAGE:
509:                       canDiagnostics[CAN_DIAG_TX_BUFFER_USAGE].asUint = getNumTxBuffersInUse();
1478E  EC65     CALL 0x150CA, 0
14790  F0A8     NOP
14792  6E0A     MOVWF 0xA, ACCESS
14794  500A     MOVF 0xA, W, ACCESS
14796  0106     MOVLB 0x6
14798  6FB9     MOVWF DMA4PR, BANKED
1479A  6BBA     CLRF DMA5PR, BANKED
510:                       break;
1479C  D022     BRA 0x47E2
511:                   case CAN_DIAG_RX_BUFFER_USAGE:
512:                       canDiagnostics[CAN_DIAG_RX_BUFFER_USAGE].asUint = getNumRxBuffersInUse();
1479E  ECAB     CALL 0x15356, 0
147A0  F0A9     NOP
147A2  6E0A     MOVWF 0xA, ACCESS
147A4  500A     MOVF 0xA, W, ACCESS
147A6  0106     MOVLB 0x6
147A8  6FBF     MOVWF ISRPR, BANKED
147AA  6BC0     CLRF 0xC0, BANKED
513:                       break;
147AC  D01A     BRA 0x47E2
514:                   case CAN_DIAG_TX_ERRORS:
515:                       canDiagnostics[CAN_DIAG_TX_ERRORS].asUint = C1BDIAG0Hbits.NTERRCNT; // TX_ERRORS
147AE  C139     MOVFF C1BDIAG0H, 0x6B5
147B0  F6B5     NOP
147B2  0106     MOVLB 0x6
147B4  6BB6     CLRF DMA1PR, BANKED
516:                       break;
147B6  D015     BRA 0x47E2
517:                   case CAN_DIAG_RX_ERRORS:
518:                       canDiagnostics[CAN_DIAG_RX_ERRORS].asUint = C1BDIAG0Lbits.NRERRCNT; // RX_ERRORS
147B8  C138     MOVFF C1BDIAG0L, 0x6B3
147BA  F6B3     NOP
147BC  0106     MOVLB 0x6
147BE  6BB4     CLRF PRLOCK, BANKED
519:                       break;
147C0  D010     BRA 0x47E2
520:               }
147C2  500B     MOVF 0xB, W, ACCESS
147C4  0A01     XORLW 0x1
147C6  B4D8     BTFSC 0xFD8, 2, ACCESS
147C8  D7F7     BRA 0x47B8
147CA  0A03     XORLW 0x3
147CC  B4D8     BTFSC 0xFD8, 2, ACCESS
147CE  D7EF     BRA 0x47AE
147D0  0A01     XORLW 0x1
147D2  B4D8     BTFSC 0xFD8, 2, ACCESS
147D4  D7D7     BRA 0x4784
147D6  0A07     XORLW 0x7
147D8  B4D8     BTFSC 0xFD8, 2, ACCESS
147DA  D7D9     BRA 0x478E
147DC  0A03     XORLW 0x3
147DE  B4D8     BTFSC 0xFD8, 2, ACCESS
147E0  D7DE     BRA 0x479E
521:           
522:               return &(canDiagnostics[index]);
147E2  500B     MOVF 0xB, W, ACCESS
147E4  0D02     MULLW 0x2
147E6  0EB1     MOVLW 0xB1
147E8  24F3     ADDWF 0xFF3, W, ACCESS
147EA  6E08     MOVWF 0x8, ACCESS
147EC  0E06     MOVLW 0x6
147EE  20F4     ADDWFC 0xFF4, W, ACCESS
147F0  6E09     MOVWF 0x9, ACCESS
523:           }
147F2  0012     RETURN 0
524:           
525:           /**
526:            * Determine the number of transmit buffers currently being used.
527:            * 
528:            * @return number of TX buffers in use
529:            */
530:           static uint8_t getNumTxBuffersInUse(void) {
531:               if (! C1FIFOSTA2Lbits.TFNRFNIF) {   // FIFO full
150CA  0101     MOVLB 0x1
150CC  B16C     BTFSC MD1SRC, 0, BANKED
150CE  D002     BRA 0x50D4
532:                   return CAN1_FIFO2_SIZE;
150D0  0E20     MOVLW 0x20
150D2  0012     RETURN 0
533:               } else {
534:                   int16_t i16;
535:                   
536:                   i16 = (int16_t)((C1FIFOUA2 - CAN1_FIFO2_BUFFERS_BASE_ADDRESS)/(8+CAN1_FIFO2_PAYLOAD_SIZE)); // write index
150D4  0E00     MOVLW 0x0
150D6  2570     ADDWF CM1CON0, W, BANKED
150D8  6E02     MOVWF ___rparam_used, ACCESS
150DA  0EC4     MOVLW 0xC4
150DC  2171     ADDWFC CM1CON1, W, BANKED
150DE  6E03     MOVWF __activetblptr, ACCESS
150E0  0EFF     MOVLW 0xFF
150E2  2172     ADDWFC CM1NCH, W, BANKED
150E4  6E04     MOVWF __activetblptr, ACCESS
150E6  0EFF     MOVLW 0xFF
150E8  2173     ADDWFC CM1PCH, W, BANKED
150EA  6E05     MOVWF 0x5, ACCESS
150EC  0E05     MOVLW 0x5
150EE  D005     BRA 0x50FA
150F0  90D8     BCF 0xFD8, 0, ACCESS
150F2  3205     RRCF 0x5, F, ACCESS
150F4  3204     RRCF __activetblptr, F, ACCESS
150F6  3203     RRCF __activetblptr, F, ACCESS
150F8  3202     RRCF ___rparam_used, F, ACCESS
150FA  2EE8     DECFSZ 0xFE8, F, ACCESS
150FC  D7F9     BRA 0x50F0
150FE  C502     MOVFF i, id
15100  F506     NOP
15102  C503     MOVFF opc, i
15104  F507     NOP
537:                   i16 = (int16_t)(i16 - C1FIFOSTA2Hbits.FIFOCI); // quantity in buffer
15106  516D     MOVF MD1CARL, W, BANKED
15108  0B1F     ANDLW 0x1F
1510A  6E02     MOVWF ___rparam_used, ACCESS
1510C  5002     MOVF ___rparam_used, W, ACCESS
1510E  5C06     SUBWF 0x6, W, ACCESS
15110  6E06     MOVWF 0x6, ACCESS
15112  5007     MOVF 0x7, W, ACCESS
15114  A0D8     BTFSS 0xFD8, 0, ACCESS
15116  0407     DECF 0x7, W, ACCESS
15118  6E07     MOVWF 0x7, ACCESS
538:                   if (i16 < 0) i16 += CAN1_FIFO2_SIZE;
1511A  AE07     BTFSS 0x7, 7, ACCESS
1511C  D004     BRA 0x5126
1511E  0E20     MOVLW 0x20
15120  2606     ADDWF 0x6, F, ACCESS
15122  0E00     MOVLW 0x0
15124  2207     ADDWFC 0x7, F, ACCESS
539:                   return (uint8_t)i16;
15126  5006     MOVF 0x6, W, ACCESS
540:               }
541:           }
15128  0012     RETURN 0
542:           
543:           /**
544:            * Determine the number of receive buffers currently being used.
545:            * 
546:            * @return number of RX buffers in use
547:            */
548:           static uint8_t getNumRxBuffersInUse(void) {
549:               if (C1FIFOSTA3Lbits.TFERFFIF) {   // FIFO full
15356  0101     MOVLB 0x1
15358  A578     BTFSS WDTCON0, 2, BANKED
1535A  D002     BRA 0x5360
550:                   return CAN1_FIFO3_SIZE;
1535C  0E20     MOVLW 0x20
1535E  0012     RETURN 0
551:               } else {
552:                   int16_t i16;
553:                   
554:                   i16 = (int16_t)((CAN1_FIFO3_BUFFERS_BASE_ADDRESS - C1FIFOUA3)/(8+CAN1_FIFO3_PAYLOAD_SIZE)); // write index
15360  517C     MOVF WDTTMR, W, BANKED
15362  0800     SUBLW 0x0
15364  6E02     MOVWF ___rparam_used, ACCESS
15366  0E3E     MOVLW 0x3E
15368  557D     SUBFWB DAC1DAT, W, BANKED
1536A  6E03     MOVWF __activetblptr, ACCESS
1536C  0E00     MOVLW 0x0
1536E  557E     SUBFWB 0x7E, W, BANKED
15370  6E04     MOVWF __activetblptr, ACCESS
15372  0E00     MOVLW 0x0
15374  557F     SUBFWB DAC1CON, W, BANKED
15376  6E05     MOVWF 0x5, ACCESS
15378  0E05     MOVLW 0x5
1537A  D005     BRA 0x5386
1537C  90D8     BCF 0xFD8, 0, ACCESS
1537E  3205     RRCF 0x5, F, ACCESS
15380  3204     RRCF __activetblptr, F, ACCESS
15382  3203     RRCF __activetblptr, F, ACCESS
15384  3202     RRCF ___rparam_used, F, ACCESS
15386  2EE8     DECFSZ 0xFE8, F, ACCESS
15388  D7F9     BRA 0x537C
1538A  C502     MOVFF i, id
1538C  F506     NOP
1538E  C503     MOVFF opc, i
15390  F507     NOP
555:                   i16 += C1FIFOSTA3Hbits.FIFOCI; // read index
15392  5179     MOVF WDTCON1, W, BANKED
15394  0B1F     ANDLW 0x1F
15396  6E02     MOVWF ___rparam_used, ACCESS
15398  5002     MOVF ___rparam_used, W, ACCESS
1539A  2606     ADDWF 0x6, F, ACCESS
1539C  0E00     MOVLW 0x0
1539E  2207     ADDWFC 0x7, F, ACCESS
556:                   if (i16 < 0) i16 += CAN1_FIFO3_SIZE;
153A0  AE07     BTFSS 0x7, 7, ACCESS
153A2  D004     BRA 0x53AC
153A4  0E20     MOVLW 0x20
153A6  2606     ADDWF 0x6, F, ACCESS
153A8  0E00     MOVLW 0x0
153AA  2207     ADDWFC 0x7, F, ACCESS
557:                   return (uint8_t) i16;
153AC  5006     MOVF 0x6, W, ACCESS
558:               }
559:           }
153AE  0012     RETURN 0
560:           #endif
561:           
562:           /*            TRANSPORT INTERFACE             */
563:           /**
564:            * Send a message on the CAN interface. Put the message into transmit FIFO2.
565:            * @param m the message to be sent
566:            * @return SEND_OK if a message was sent, SEND_FAIL if FIFO was full
567:            */
568:           static SendResult canSendMessage(Message * mp) {
569:               uint8_t i;
570:               uint8_t* txFifoObj;
571:           #ifdef VLCB_DIAG
572:               uint16_t temp;
573:           #endif
574:           #ifdef CONSUMED_EVENTS
575:               Message * m;
576:           
577:               // If this is an event we are sending then put it onto the rx queue so
578:               // we can consume our own events.
579:               if (isEvent(mp->opc)) {
11068  EE20     LFSR 2, 0x1
1106A  F001     NOP
1106C  500E     MOVF 0xE, W, ACCESS
1106E  26D9     ADDWF 0xFD9, F, ACCESS
11070  500F     MOVF 0xF, W, ACCESS
11072  22DA     ADDWFC 0xFDA, F, ACCESS
11074  50DF     MOVF 0xFDF, W, ACCESS
11076  EC4D     CALL 0x1609A, 0
11078  F0B0     NOP
1107A  0900     IORLW 0x0
1107C  B4D8     BTFSC 0xFD8, 2, ACCESS
1107E  D0A5     BRA 0x11CA
580:                   if (have(SERVICE_ID_CONSUME_OWN_EVENTS)) {
11080  0E08     MOVLW 0x8
11082  EC50     CALL 0x14CA0, 0
11084  F0A6     NOP
11086  0900     IORLW 0x0
11088  B4D8     BTFSC 0xFD8, 2, ACCESS
1108A  D09F     BRA 0x11CA
581:                       // we can consume our own events.
582:                       m = getNextWriteMessage(&rxQueue);
1108C  0ECB     MOVLW 0xCB
1108E  6E02     MOVWF ___rparam_used, ACCESS
11090  0E05     MOVLW 0x5
11092  6E03     MOVWF __activetblptr, ACCESS
11094  ECB7     CALL 0x1396E, 0
11096  F09C     NOP
11098  C502     MOVFF i, evIdx
1109A  F518     NOP
1109C  C503     MOVFF opc, tableIndex
1109E  F519     NOP
583:                       if (m == NULL) {
110A0  5018     MOVF 0x18, W, ACCESS
110A2  1019     IORWF 0x19, W, ACCESS
110A4  A4D8     BTFSS 0xFD8, 2, ACCESS
110A6  D006     BRA 0x10B4
584:           #ifdef VLCB_DIAG
585:                           canDiagnostics[CAN_DIAG_RX_BUFFER_OVERRUN].asUint++;
110A8  0106     MOVLB 0x6
110AA  4BC1     INFSNZ 0xC1, F, BANKED
110AC  2BC2     INCF 0xC2, F, BANKED
586:                           updateModuleErrorStatus();
110AE  EC23     CALL 0x16246, 0
110B0  F0B1     NOP
587:           #endif
588:                       } else {
110B2  D07A     BRA 0x11A8
589:                           // copy ECAN buffer to message
590:                           m->opc = mp->opc;
110B4  EE20     LFSR 2, 0x1
110B6  F001     NOP
110B8  500E     MOVF 0xE, W, ACCESS
110BA  26D9     ADDWF 0xFD9, F, ACCESS
110BC  500F     MOVF 0xF, W, ACCESS
110BE  22DA     ADDWFC 0xFDA, F, ACCESS
110C0  EE10     LFSR 1, 0x1
110C2  F001     NOP
110C4  5018     MOVF 0x18, W, ACCESS
110C6  26E1     ADDWF 0xFE1, F, ACCESS
110C8  5019     MOVF 0x19, W, ACCESS
110CA  22E2     ADDWFC 0xFE2, F, ACCESS
110CC  C4DF     MOVFF INDF2, INDF1
110CE  F4E7     NOP
591:                           m->len = mp->len;
110D0  C50E     MOVFF evNum, FSR2
110D2  F4D9     NOP
110D4  C50F     MOVFF interruptEnabled, FSR2H
110D6  F4DA     NOP
110D8  C518     MOVFF evIdx, FSR1
110DA  F4E1     NOP
110DC  C519     MOVFF tableIndex, FSR1H
110DE  F4E2     NOP
110E0  C4DF     MOVFF INDF2, INDF1
110E2  F4E7     NOP
592:                           m->bytes[0] = mp->bytes[0];
110E4  EE20     LFSR 2, 0x2
110E6  F002     NOP
110E8  500E     MOVF 0xE, W, ACCESS
110EA  26D9     ADDWF 0xFD9, F, ACCESS
110EC  500F     MOVF 0xF, W, ACCESS
110EE  22DA     ADDWFC 0xFDA, F, ACCESS
110F0  EE10     LFSR 1, 0x2
110F2  F002     NOP
110F4  5018     MOVF 0x18, W, ACCESS
110F6  26E1     ADDWF 0xFE1, F, ACCESS
110F8  5019     MOVF 0x19, W, ACCESS
110FA  22E2     ADDWFC 0xFE2, F, ACCESS
110FC  C4DF     MOVFF INDF2, INDF1
110FE  F4E7     NOP
593:                           m->bytes[1] = mp->bytes[1];
11100  EE20     LFSR 2, 0x3
11102  F003     NOP
11104  500E     MOVF 0xE, W, ACCESS
11106  26D9     ADDWF 0xFD9, F, ACCESS
11108  500F     MOVF 0xF, W, ACCESS
1110A  22DA     ADDWFC 0xFDA, F, ACCESS
1110C  EE10     LFSR 1, 0x3
1110E  F003     NOP
11110  5018     MOVF 0x18, W, ACCESS
11112  26E1     ADDWF 0xFE1, F, ACCESS
11114  5019     MOVF 0x19, W, ACCESS
11116  22E2     ADDWFC 0xFE2, F, ACCESS
11118  C4DF     MOVFF INDF2, INDF1
1111A  F4E7     NOP
594:                           m->bytes[2] = mp->bytes[2];
1111C  EE20     LFSR 2, 0x4
1111E  F004     NOP
11120  500E     MOVF 0xE, W, ACCESS
11122  26D9     ADDWF 0xFD9, F, ACCESS
11124  500F     MOVF 0xF, W, ACCESS
11126  22DA     ADDWFC 0xFDA, F, ACCESS
11128  EE10     LFSR 1, 0x4
1112A  F004     NOP
1112C  5018     MOVF 0x18, W, ACCESS
1112E  26E1     ADDWF 0xFE1, F, ACCESS
11130  5019     MOVF 0x19, W, ACCESS
11132  22E2     ADDWFC 0xFE2, F, ACCESS
11134  C4DF     MOVFF INDF2, INDF1
11136  F4E7     NOP
595:                           m->bytes[3] = mp->bytes[3];
11138  EE20     LFSR 2, 0x5
1113A  F005     NOP
1113C  500E     MOVF 0xE, W, ACCESS
1113E  26D9     ADDWF 0xFD9, F, ACCESS
11140  500F     MOVF 0xF, W, ACCESS
11142  22DA     ADDWFC 0xFDA, F, ACCESS
11144  EE10     LFSR 1, 0x5
11146  F005     NOP
11148  5018     MOVF 0x18, W, ACCESS
1114A  26E1     ADDWF 0xFE1, F, ACCESS
1114C  5019     MOVF 0x19, W, ACCESS
1114E  22E2     ADDWFC 0xFE2, F, ACCESS
11150  C4DF     MOVFF INDF2, INDF1
11152  F4E7     NOP
596:                           m->bytes[4] = mp->bytes[4];
11154  EE20     LFSR 2, 0x6
11156  F006     NOP
11158  500E     MOVF 0xE, W, ACCESS
1115A  26D9     ADDWF 0xFD9, F, ACCESS
1115C  500F     MOVF 0xF, W, ACCESS
1115E  22DA     ADDWFC 0xFDA, F, ACCESS
11160  EE10     LFSR 1, 0x6
11162  F006     NOP
11164  5018     MOVF 0x18, W, ACCESS
11166  26E1     ADDWF 0xFE1, F, ACCESS
11168  5019     MOVF 0x19, W, ACCESS
1116A  22E2     ADDWFC 0xFE2, F, ACCESS
1116C  C4DF     MOVFF INDF2, INDF1
1116E  F4E7     NOP
597:                           m->bytes[5] = mp->bytes[5];
11170  EE20     LFSR 2, 0x7
11172  F007     NOP
11174  500E     MOVF 0xE, W, ACCESS
11176  26D9     ADDWF 0xFD9, F, ACCESS
11178  500F     MOVF 0xF, W, ACCESS
1117A  22DA     ADDWFC 0xFDA, F, ACCESS
1117C  EE10     LFSR 1, 0x7
1117E  F007     NOP
11180  5018     MOVF 0x18, W, ACCESS
11182  26E1     ADDWF 0xFE1, F, ACCESS
11184  5019     MOVF 0x19, W, ACCESS
11186  22E2     ADDWFC 0xFE2, F, ACCESS
11188  C4DF     MOVFF INDF2, INDF1
1118A  F4E7     NOP
598:                           m->bytes[6] = mp->bytes[6];
1118C  EE20     LFSR 2, 0x8
1118E  F008     NOP
11190  500E     MOVF 0xE, W, ACCESS
11192  26D9     ADDWF 0xFD9, F, ACCESS
11194  500F     MOVF 0xF, W, ACCESS
11196  22DA     ADDWFC 0xFDA, F, ACCESS
11198  EE10     LFSR 1, 0x8
1119A  F008     NOP
1119C  5018     MOVF 0x18, W, ACCESS
1119E  26E1     ADDWF 0xFE1, F, ACCESS
111A0  5019     MOVF 0x19, W, ACCESS
111A2  22E2     ADDWFC 0xFE2, F, ACCESS
111A4  C4DF     MOVFF INDF2, INDF1
111A6  F4E7     NOP
599:                       }
600:           #ifdef VLCB_DIAG
601:                       temp = getNumRxBuffersInUse();
111A8  ECAB     CALL 0x15356, 0
111AA  F0A9     NOP
111AC  6E10     MOVWF 0x10, ACCESS
111AE  5010     MOVF 0x10, W, ACCESS
111B0  6E16     MOVWF 0x16, ACCESS
111B2  6A17     CLRF 0x17, ACCESS
602:                       if (temp > canDiagnostics[CAN_DIAG_RX_HIGH_WATERMARK].asUint) {
111B4  5016     MOVF 0x16, W, ACCESS
111B6  0106     MOVLB 0x6
111B8  5DD5     SUBWF CLCSELECT, W, BANKED
111BA  5017     MOVF 0x17, W, ACCESS
111BC  59D6     SUBWFB CLCnCON, W, BANKED
111BE  B0D8     BTFSC 0xFD8, 0, ACCESS
111C0  D004     BRA 0x11CA
603:                           canDiagnostics[CAN_DIAG_RX_HIGH_WATERMARK].asUint = temp;
111C2  C516     MOVFF i, 0x6D5
111C4  F6D5     NOP
111C6  C517     MOVFF tableIndex, 0x6D6
111C8  F6D6     NOP
604:                       }
605:           #endif
606:                   }
607:               }
608:           #endif
609:               // Done if FIFO full
610:               if (!C1FIFOSTA2Lbits.TFNRFNIF) {
111CA  0101     MOVLB 0x1
111CC  B16C     BTFSC MD1SRC, 0, BANKED
111CE  D006     BRA 0x11DC
611:           #ifdef VLCB_DIAG
612:                   canDiagnostics[CAN_DIAG_TX_BUFFER_OVERRUN].asUint++;
111D0  0106     MOVLB 0x6
111D2  4BBB     INFSNZ DMA6PR, F, BANKED
111D4  2BBC     INCF DMA7PR, F, BANKED
613:                   updateModuleErrorStatus();
111D6  EC23     CALL 0x16246, 0
111D8  F0B1     NOP
111DA  0012     RETURN 0
614:           #endif
615:                   return SEND_FAILED;
616:               }
617:           #ifdef VLCB_DIAG
618:               // Did previous TX fail arbitration?
619:               // This is really not the best place to detect arbitration failure but
620:               // I can't think of a better way.
621:               if (C1FIFOSTA2Lbits.TXLARB == 1) {
111DC  AD6C     BTFSS MD1SRC, 6, BANKED
111DE  D003     BRA 0x11E6
622:                   canDiagnostics[CAN_DIAG_LOST_ARBITRATION].asUint++;
111E0  0106     MOVLB 0x6
111E2  4BC9     INFSNZ 0xC9, F, BANKED
111E4  2BCA     INCF _writeConfigByte, F, BANKED
623:               }
624:           #endif
625:               
626:               // start an enumeration on first transmit if we are still using canId=0
627:               if ((canId == 0) && (enumerationState == NO_ENUMERATION)) {
111E6  0105     MOVLB 0x5
111E8  51AF     MOVF OSCCON3, W, BANKED
111EA  A4D8     BTFSS 0xFD8, 2, ACCESS
111EC  D007     BRA 0x11FC
111EE  51AC     MOVF ACTCON, W, BANKED
111F0  A4D8     BTFSS 0xFD8, 2, ACCESS
111F2  D004     BRA 0x11FC
628:                   enumerationState = ENUMERATION_REQUIRED;
111F4  0E01     MOVLW 0x1
111F6  6FAC     MOVWF ACTCON, BANKED
629:                   canId = 1;
111F8  0E01     MOVLW 0x1
111FA  6FAF     MOVWF OSCCON3, BANKED
630:               }
631:               
632:               // Pointer to FIFO entry
633:               txFifoObj = (uint8_t*) C1FIFOUA2;
111FC  C170     MOVFF C1FIFOUA2, txFifoObj
111FE  F51A     NOP
11200  C171     MOVFF C1FIFOUA2H, eventNumber
11202  F51B     NOP
634:               txFifoObj[0] = (uint8_t)((canPri[priorities[mp->opc]] & 1) << 7) | (canId & 0x7F);      // Put ID
11204  C5AF     MOVFF canId, receivedCanId
11206  F510     NOP
11208  0E7F     MOVLW 0x7F
1120A  1610     ANDWF 0x10, F, ACCESS
1120C  EE20     LFSR 2, 0x1
1120E  F001     NOP
11210  500E     MOVF 0xE, W, ACCESS
11212  26D9     ADDWF 0xFD9, F, ACCESS
11214  500F     MOVF 0xF, W, ACCESS
11216  22DA     ADDWFC 0xFDA, F, ACCESS
11218  50DF     MOVF 0xFDF, W, ACCESS
1121A  6E11     MOVWF 0x11, ACCESS
1121C  6A12     CLRF 0x12, ACCESS
1121E  0E23     MOVLW 0x23
11220  2411     ADDWF 0x11, W, ACCESS
11222  6EF6     MOVWF 0xFF6, ACCESS
11224  0EFE     MOVLW 0xFE
11226  2012     ADDWFC 0x12, W, ACCESS
11228  6EF7     MOVWF 0xFF7, ACCESS
1122A  6AF8     CLRF 0xFF8, ACCESS
1122C  0E00     MOVLW 0x0
1122E  22F8     ADDWFC 0xFF8, F, ACCESS
11230  0008     TBLRD*
11232  50F5     MOVF 0xFF5, W, ACCESS
11234  6E13     MOVWF 0x13, ACCESS
11236  6A14     CLRF 0x14, ACCESS
11238  0E40     MOVLW 0x40
1123A  2413     ADDWF 0x13, W, ACCESS
1123C  6EF6     MOVWF 0xFF6, ACCESS
1123E  0EFF     MOVLW 0xFF
11240  2014     ADDWFC 0x14, W, ACCESS
11242  6EF7     MOVWF 0xFF7, ACCESS
11244  6AF8     CLRF 0xFF8, ACCESS
11246  0E00     MOVLW 0x0
11248  22F8     ADDWFC 0xFF8, F, ACCESS
1124A  0008     TBLRD*
1124C  C4F5     MOVFF TABLAT, lo
1124E  F515     NOP
11250  0E01     MOVLW 0x1
11252  1615     ANDWF 0x15, F, ACCESS
11254  0E00     MOVLW 0x0
11256  B015     BTFSC 0x15, 0, ACCESS
11258  0E80     MOVLW 0x80
1125A  6E15     MOVWF 0x15, ACCESS
1125C  5015     MOVF 0x15, W, ACCESS
1125E  1010     IORWF 0x10, W, ACCESS
11260  C51A     MOVFF txFifoObj, FSR2
11262  F4D9     NOP
11264  C51B     MOVFF eventNumber, FSR2H
11266  F4DA     NOP
11268  6EDF     MOVWF 0xFDF, ACCESS
635:               txFifoObj[1] = canPri[priorities[mp->opc]] >> 1;
1126A  EE20     LFSR 2, 0x1
1126C  F001     NOP
1126E  501A     MOVF 0x1A, W, ACCESS
11270  26D9     ADDWF 0xFD9, F, ACCESS
11272  501B     MOVF 0x1B, W, ACCESS
11274  22DA     ADDWFC 0xFDA, F, ACCESS
11276  EE10     LFSR 1, 0x1
11278  F001     NOP
1127A  500E     MOVF 0xE, W, ACCESS
1127C  26E1     ADDWF 0xFE1, F, ACCESS
1127E  500F     MOVF 0xF, W, ACCESS
11280  22E2     ADDWFC 0xFE2, F, ACCESS
11282  50E7     MOVF 0xFE7, W, ACCESS
11284  6E10     MOVWF 0x10, ACCESS
11286  6A11     CLRF 0x11, ACCESS
11288  0E23     MOVLW 0x23
1128A  2410     ADDWF 0x10, W, ACCESS
1128C  6EF6     MOVWF 0xFF6, ACCESS
1128E  0EFE     MOVLW 0xFE
11290  2011     ADDWFC 0x11, W, ACCESS
11292  6EF7     MOVWF 0xFF7, ACCESS
11294  6AF8     CLRF 0xFF8, ACCESS
11296  0E00     MOVLW 0x0
11298  22F8     ADDWFC 0xFF8, F, ACCESS
1129A  0008     TBLRD*
1129C  50F5     MOVF 0xFF5, W, ACCESS
1129E  6E12     MOVWF 0x12, ACCESS
112A0  6A13     CLRF 0x13, ACCESS
112A2  0E40     MOVLW 0x40
112A4  2412     ADDWF 0x12, W, ACCESS
112A6  6EF6     MOVWF 0xFF6, ACCESS
112A8  0EFF     MOVLW 0xFF
112AA  2013     ADDWFC 0x13, W, ACCESS
112AC  6EF7     MOVWF 0xFF7, ACCESS
112AE  6AF8     CLRF 0xFF8, ACCESS
112B0  0E00     MOVLW 0x0
112B2  22F8     ADDWFC 0xFF8, F, ACCESS
112B4  0008     TBLRD*
112B6  C4F5     MOVFF TABLAT, incomingCanId
112B8  F514     NOP
112BA  90D8     BCF 0xFD8, 0, ACCESS
112BC  3014     RRCF 0x14, W, ACCESS
112BE  6EDF     MOVWF 0xFDF, ACCESS
636:               txFifoObj[4] = (mp->len&0xF);       // Standard frame, length in DLC
112C0  EE20     LFSR 2, 0x4
112C2  F004     NOP
112C4  501A     MOVF 0x1A, W, ACCESS
112C6  26D9     ADDWF 0xFD9, F, ACCESS
112C8  501B     MOVF 0x1B, W, ACCESS
112CA  22DA     ADDWFC 0xFDA, F, ACCESS
112CC  C50E     MOVFF evNum, FSR1
112CE  F4E1     NOP
112D0  C50F     MOVFF interruptEnabled, FSR1H
112D2  F4E2     NOP
112D4  50E7     MOVF 0xFE7, W, ACCESS
112D6  0B0F     ANDLW 0xF
112D8  6EDF     MOVWF 0xFDF, ACCESS
637:               txFifoObj[5] = 0;       // No sequence number
112DA  EE20     LFSR 2, 0x5
112DC  F005     NOP
112DE  501A     MOVF 0x1A, W, ACCESS
112E0  26D9     ADDWF 0xFD9, F, ACCESS
112E2  501B     MOVF 0x1B, W, ACCESS
112E4  22DA     ADDWFC 0xFDA, F, ACCESS
112E6  6ADF     CLRF 0xFDF, ACCESS
638:               txFifoObj[6] = 0;       // No sequence number
112E8  EE20     LFSR 2, 0x6
112EA  F006     NOP
112EC  501A     MOVF 0x1A, W, ACCESS
112EE  26D9     ADDWF 0xFD9, F, ACCESS
112F0  501B     MOVF 0x1B, W, ACCESS
112F2  22DA     ADDWFC 0xFDA, F, ACCESS
112F4  6ADF     CLRF 0xFDF, ACCESS
639:               txFifoObj[7] = 0;       // No sequence number
112F6  EE20     LFSR 2, 0x7
112F8  F007     NOP
112FA  501A     MOVF 0x1A, W, ACCESS
112FC  26D9     ADDWF 0xFD9, F, ACCESS
112FE  501B     MOVF 0x1B, W, ACCESS
11300  22DA     ADDWFC 0xFDA, F, ACCESS
11302  6ADF     CLRF 0xFDF, ACCESS
640:               txFifoObj[8] = mp->opc;  // opcode
11304  EE20     LFSR 2, 0x1
11306  F001     NOP
11308  500E     MOVF 0xE, W, ACCESS
1130A  26D9     ADDWF 0xFD9, F, ACCESS
1130C  500F     MOVF 0xF, W, ACCESS
1130E  22DA     ADDWFC 0xFDA, F, ACCESS
11310  EE10     LFSR 1, 0x8
11312  F008     NOP
11314  501A     MOVF 0x1A, W, ACCESS
11316  26E1     ADDWF 0xFE1, F, ACCESS
11318  501B     MOVF 0x1B, W, ACCESS
1131A  22E2     ADDWFC 0xFE2, F, ACCESS
1131C  C4DF     MOVFF INDF2, INDF1
1131E  F4E7     NOP
641:               txFifoObj[9]  = mp->bytes[0];  // data1
11320  EE20     LFSR 2, 0x2
11322  F002     NOP
11324  500E     MOVF 0xE, W, ACCESS
11326  26D9     ADDWF 0xFD9, F, ACCESS
11328  500F     MOVF 0xF, W, ACCESS
1132A  22DA     ADDWFC 0xFDA, F, ACCESS
1132C  EE10     LFSR 1, 0x9
1132E  F009     NOP
11330  501A     MOVF 0x1A, W, ACCESS
11332  26E1     ADDWF 0xFE1, F, ACCESS
11334  501B     MOVF 0x1B, W, ACCESS
11336  22E2     ADDWFC 0xFE2, F, ACCESS
11338  C4DF     MOVFF INDF2, INDF1
1133A  F4E7     NOP
642:               txFifoObj[10] = mp->bytes[1];  // data2
1133C  EE20     LFSR 2, 0x3
1133E  F003     NOP
11340  500E     MOVF 0xE, W, ACCESS
11342  26D9     ADDWF 0xFD9, F, ACCESS
11344  500F     MOVF 0xF, W, ACCESS
11346  22DA     ADDWFC 0xFDA, F, ACCESS
11348  EE10     LFSR 1, 0xA
1134A  F00A     NOP
1134C  501A     MOVF 0x1A, W, ACCESS
1134E  26E1     ADDWF 0xFE1, F, ACCESS
11350  501B     MOVF 0x1B, W, ACCESS
11352  22E2     ADDWFC 0xFE2, F, ACCESS
11354  C4DF     MOVFF INDF2, INDF1
11356  F4E7     NOP
643:               txFifoObj[11] = mp->bytes[2];  // data3
11358  EE20     LFSR 2, 0x4
1135A  F004     NOP
1135C  500E     MOVF 0xE, W, ACCESS
1135E  26D9     ADDWF 0xFD9, F, ACCESS
11360  500F     MOVF 0xF, W, ACCESS
11362  22DA     ADDWFC 0xFDA, F, ACCESS
11364  EE10     LFSR 1, 0xB
11366  F00B     NOP
11368  501A     MOVF 0x1A, W, ACCESS
1136A  26E1     ADDWF 0xFE1, F, ACCESS
1136C  501B     MOVF 0x1B, W, ACCESS
1136E  22E2     ADDWFC 0xFE2, F, ACCESS
11370  C4DF     MOVFF INDF2, INDF1
11372  F4E7     NOP
644:               txFifoObj[12] = mp->bytes[3];  // data4
11374  EE20     LFSR 2, 0x5
11376  F005     NOP
11378  500E     MOVF 0xE, W, ACCESS
1137A  26D9     ADDWF 0xFD9, F, ACCESS
1137C  500F     MOVF 0xF, W, ACCESS
1137E  22DA     ADDWFC 0xFDA, F, ACCESS
11380  EE10     LFSR 1, 0xC
11382  F00C     NOP
11384  501A     MOVF 0x1A, W, ACCESS
11386  26E1     ADDWF 0xFE1, F, ACCESS
11388  501B     MOVF 0x1B, W, ACCESS
1138A  22E2     ADDWFC 0xFE2, F, ACCESS
1138C  C4DF     MOVFF INDF2, INDF1
1138E  F4E7     NOP
645:               txFifoObj[13] = mp->bytes[4];  // data5
11390  EE20     LFSR 2, 0x6
11392  F006     NOP
11394  500E     MOVF 0xE, W, ACCESS
11396  26D9     ADDWF 0xFD9, F, ACCESS
11398  500F     MOVF 0xF, W, ACCESS
1139A  22DA     ADDWFC 0xFDA, F, ACCESS
1139C  EE10     LFSR 1, 0xD
1139E  F00D     NOP
113A0  501A     MOVF 0x1A, W, ACCESS
113A2  26E1     ADDWF 0xFE1, F, ACCESS
113A4  501B     MOVF 0x1B, W, ACCESS
113A6  22E2     ADDWFC 0xFE2, F, ACCESS
113A8  C4DF     MOVFF INDF2, INDF1
113AA  F4E7     NOP
646:               txFifoObj[14] = mp->bytes[5];  // data6
113AC  EE20     LFSR 2, 0x7
113AE  F007     NOP
113B0  500E     MOVF 0xE, W, ACCESS
113B2  26D9     ADDWF 0xFD9, F, ACCESS
113B4  500F     MOVF 0xF, W, ACCESS
113B6  22DA     ADDWFC 0xFDA, F, ACCESS
113B8  EE10     LFSR 1, 0xE
113BA  F00E     NOP
113BC  501A     MOVF 0x1A, W, ACCESS
113BE  26E1     ADDWF 0xFE1, F, ACCESS
113C0  501B     MOVF 0x1B, W, ACCESS
113C2  22E2     ADDWFC 0xFE2, F, ACCESS
113C4  C4DF     MOVFF INDF2, INDF1
113C6  F4E7     NOP
647:               txFifoObj[15] = mp->bytes[6];  // data7
113C8  EE20     LFSR 2, 0x8
113CA  F008     NOP
113CC  500E     MOVF 0xE, W, ACCESS
113CE  26D9     ADDWF 0xFD9, F, ACCESS
113D0  500F     MOVF 0xF, W, ACCESS
113D2  22DA     ADDWFC 0xFDA, F, ACCESS
113D4  EE10     LFSR 1, 0xF
113D6  F00F     NOP
113D8  501A     MOVF 0x1A, W, ACCESS
113DA  26E1     ADDWF 0xFE1, F, ACCESS
113DC  501B     MOVF 0x1B, W, ACCESS
113DE  22E2     ADDWFC 0xFE2, F, ACCESS
113E0  C4DF     MOVFF INDF2, INDF1
113E2  F4E7     NOP
648:               
649:           #ifdef VLCB_DIAG
650:               canDiagnostics[CAN_DIAG_TX_MESSAGES].asUint++;
113E4  0106     MOVLB 0x6
113E6  4BBD     INFSNZ DMA8PR, F, BANKED
113E8  2BBE     INCF MAINPR, F, BANKED
651:           #endif
652:               C1FIFOCON2H |= _C1FIFOCON2H_UINC_MASK; // add to TX queue
113EA  0101     MOVLB 0x1
113EC  8169     BSF 0x69, 0, BANKED
653:           #ifdef VLCB_DIAG
654:               temp = getNumTxBuffersInUse();
113EE  EC65     CALL 0x150CA, 0
113F0  F0A8     NOP
113F2  6E10     MOVWF 0x10, ACCESS
113F4  5010     MOVF 0x10, W, ACCESS
113F6  6E16     MOVWF 0x16, ACCESS
113F8  6A17     CLRF 0x17, ACCESS
655:               if (temp > canDiagnostics[CAN_DIAG_TX_HIGH_WATERMARK].asUint) {
113FA  5016     MOVF 0x16, W, ACCESS
113FC  0106     MOVLB 0x6
113FE  5DD3     SUBWF 0xD3, W, BANKED
11400  5017     MOVF 0x17, W, ACCESS
11402  59D4     SUBWFB CLCDATA, W, BANKED
11404  B0D8     BTFSC 0xFD8, 0, ACCESS
11406  D004     BRA 0x1410
656:                   canDiagnostics[CAN_DIAG_TX_HIGH_WATERMARK].asUint = temp;
11408  C516     MOVFF i, 0x6D3
1140A  F6D3     NOP
1140C  C517     MOVFF tableIndex, 0x6D4
1140E  F6D4     NOP
657:               }
658:           #endif
659:               if (canId == 0) {
11410  0105     MOVLB 0x5
11412  51AF     MOVF OSCCON3, W, BANKED
11414  A4D8     BTFSS 0xFD8, 2, ACCESS
11416  D004     BRA 0x1420
660:                   // Not ready to send as we don't yet have a CANID so start the self enumeration
661:                   startEnumeration(1);
11418  0E01     MOVLW 0x1
1141A  ECDF     CALL 0x155BE, 0
1141C  F0AA     NOP
662:               } else {
1141E  0012     RETURN 0
663:                   // ready to send as we have a CANID
664:                   C1FIFOCON2H |= _C1FIFOCON2H_TXREQ_MASK; // transmit
11420  0101     MOVLB 0x1
11422  8369     BSF 0x69, 1, BANKED
665:               }
666:               return SEND_OK;
667:           }
11424  0012     RETURN 0
668:           
669:           /** 
670:            * Initiate a self enumeration by sending a RTR frame using the TXQ.
671:            */
672:           static void sendRTR(void) {
673:               uint8_t* txFifoObj = (uint8_t*) C1TXQUA;
158FA  C158     MOVFF C1TXQUA, i
158FC  F502     NOP
158FE  C159     MOVFF C1TXQUAH, opc
15900  F503     NOP
674:               txFifoObj[0] = (canId & 0x7F);      // Put ID
15902  0105     MOVLB 0x5
15904  51AF     MOVF OSCCON3, W, BANKED
15906  0B7F     ANDLW 0x7F
15908  C502     MOVFF i, FSR2
1590A  F4D9     NOP
1590C  C503     MOVFF opc, FSR2H
1590E  F4DA     NOP
15910  6EDF     MOVWF 0xFDF, ACCESS
675:               txFifoObj[1] = 0;       // high priority
15912  EE20     LFSR 2, 0x1
15914  F001     NOP
15916  5002     MOVF ___rparam_used, W, ACCESS
15918  26D9     ADDWF 0xFD9, F, ACCESS
1591A  5003     MOVF __activetblptr, W, ACCESS
1591C  22DA     ADDWFC 0xFDA, F, ACCESS
1591E  6ADF     CLRF 0xFDF, ACCESS
676:               txFifoObj[4] = 0x20;    // Standard frame, RTR, Zero data length DLC
15920  EE20     LFSR 2, 0x4
15922  F004     NOP
15924  5002     MOVF ___rparam_used, W, ACCESS
15926  26D9     ADDWF 0xFD9, F, ACCESS
15928  5003     MOVF __activetblptr, W, ACCESS
1592A  22DA     ADDWFC 0xFDA, F, ACCESS
1592C  0E20     MOVLW 0x20
1592E  6EDF     MOVWF 0xFDF, ACCESS
677:               C1TXQCONH |= (_C1TXQCONH_TXREQ_MASK | _C1TXQCONH_UINC_MASK); // transmit
15930  0E03     MOVLW 0x3
15932  0101     MOVLB 0x1
15934  1351     IORWF 0x51, F, BANKED
678:           #ifdef VLCB_DIAG
679:               canDiagnostics[CAN_DIAG_TX_MESSAGES].asUint++;
15936  0106     MOVLB 0x6
15938  4BBD     INFSNZ DMA8PR, F, BANKED
1593A  2BBE     INCF MAINPR, F, BANKED
680:           #endif
681:           }
1593C  0012     RETURN 0
682:           
683:           /**
684:            * Check to see if there are any received messages available returning the first
685:            * one.
686:            * If there are messages waiting in the receive buffer then return the oldest entry.
687:            * Sends self enumeration reply if a request has been received.
688:            * Collects the self enumeration replies if we sent a request.
689:            * Any received message is copied to the location pointed by m.
690:            * @return RECEIVED if message received NOT_RECEIVED otherwise
691:            */
692:           static MessageReceived canReceiveMessage(Message * m){
693:               Message * mp;
694:               uint8_t incomingCanId;
695:               uint8_t* rxFifoObj;
696:           #ifdef VLCB_DIAG
697:               uint16_t temp;
698:           #endif
699:           
700:               // Check for any messages in the software fifo, which will be self-consumed events
701:               mp = pop(&rxQueue);
12B24  0ECB     MOVLW 0xCB
12B26  6E02     MOVWF ___rparam_used, ACCESS
12B28  0E05     MOVLW 0x5
12B2A  6E03     MOVWF __activetblptr, ACCESS
12B2C  EC9F     CALL 0x1413E, 0
12B2E  F0A0     NOP
12B30  C502     MOVFF i, lo
12B32  F515     NOP
12B34  C503     MOVFF opc, i
12B36  F516     NOP
702:               if (mp != NULL) {
12B38  5015     MOVF 0x15, W, ACCESS
12B3A  1016     IORWF 0x16, W, ACCESS
12B3C  B4D8     BTFSC 0xFD8, 2, ACCESS
12B3E  D010     BRA 0x2B60
703:                   memcpy(m, mp, sizeof(Message));
12B40  C511     MOVFF m, i
12B42  F502     NOP
12B44  C512     MOVFF i, opc
12B46  F503     NOP
12B48  C515     MOVFF lo, s
12B4A  F504     NOP
12B4C  C516     MOVFF i, i
12B4E  F505     NOP
12B50  0E00     MOVLW 0x0
12B52  6E07     MOVWF 0x7, ACCESS
12B54  0E09     MOVLW 0x9
12B56  6E06     MOVWF 0x6, ACCESS
12B58  EC5B     CALL 0x158B6, 0
12B5A  F0AC     NOP
704:                   return RECEIVED;      // message available
12B5C  0E01     MOVLW 0x1
12B5E  0012     RETURN 0
705:               } else { // Nothing in software FIFO, so now check for message in hardware FIFO
706:                   if (! C1FIFOSTA3Lbits.TFNRFNIF) {
12B60  0101     MOVLB 0x1
12B62  B178     BTFSC WDTCON0, 0, BANKED
12B64  D002     BRA 0x2B6A
707:                       // No messages
708:                       return NOT_RECEIVED;
12B66  0E00     MOVLW 0x0
12B68  0012     RETURN 0
709:                   }
710:                   // message in hardware FIFO
711:           #ifdef VLCB_DIAG
712:                   temp = getNumRxBuffersInUse();
12B6A  ECAB     CALL 0x15356, 0
12B6C  F0A9     NOP
12B6E  6E13     MOVWF 0x13, ACCESS
12B70  5013     MOVF 0x13, W, ACCESS
12B72  6E17     MOVWF 0x17, ACCESS
12B74  6A18     CLRF 0x18, ACCESS
713:                   if (temp > canDiagnostics[CAN_DIAG_RX_HIGH_WATERMARK].asUint) {
12B76  5017     MOVF 0x17, W, ACCESS
12B78  0106     MOVLB 0x6
12B7A  5DD5     SUBWF CLCSELECT, W, BANKED
12B7C  5018     MOVF 0x18, W, ACCESS
12B7E  59D6     SUBWFB CLCnCON, W, BANKED
12B80  B0D8     BTFSC 0xFD8, 0, ACCESS
12B82  D004     BRA 0x2B8C
714:                       canDiagnostics[CAN_DIAG_RX_HIGH_WATERMARK].asUint = temp;
12B84  C517     MOVFF tableIndex, 0x6D5
12B86  F6D5     NOP
12B88  C518     MOVFF evIdx, 0x6D6
12B8A  F6D6     NOP
715:                   }
716:           #endif
717:                   // get message
718:                   rxFifoObj = (uint8_t*) C1FIFOUA3;   // Pointer to FIFO entry
12B8C  C17C     MOVFF C1FIFOUA3, tableIndex
12B8E  F519     NOP
12B90  C17D     MOVFF C1FIFOUA3H, txFifoObj
12B92  F51A     NOP
719:                   incomingCanId = rxFifoObj[0] & 0x7F;
12B94  C519     MOVFF tableIndex, FSR2
12B96  F4D9     NOP
12B98  C51A     MOVFF txFifoObj, FSR2H
12B9A  F4DA     NOP
12B9C  50DF     MOVF 0xFDF, W, ACCESS
12B9E  0B7F     ANDLW 0x7F
12BA0  6E14     MOVWF 0x14, ACCESS
720:                   handleSelfEnumeration(incomingCanId);
12BA2  5014     MOVF 0x14, W, ACCESS
12BA4  ECF2     CALL 0x145E4, 0
12BA6  F0A2     NOP
721:           
722:           #ifdef VLCB_DIAG
723:                   canDiagnostics[CAN_DIAG_RX_MESSAGES].asUint++;
12BA8  0106     MOVLB 0x6
12BAA  4BC3     INFSNZ 0xC3, F, BANKED
12BAC  2BC4     INCF 0xC4, F, BANKED
724:           #endif
725:                   /* !!! Note that we access RTR and DLC from index 4 whereas Datasheet incorrectly says 5 !!!!!! */
726:                   if (rxFifoObj[4] & 0x20) {
12BAE  EE20     LFSR 2, 0x4
12BB0  F004     NOP
12BB2  5019     MOVF 0x19, W, ACCESS
12BB4  26D9     ADDWF 0xFD9, F, ACCESS
12BB6  501A     MOVF 0x1A, W, ACCESS
12BB8  22DA     ADDWFC 0xFDA, F, ACCESS
12BBA  AADF     BTFSS 0xFDF, 5, ACCESS
12BBC  D004     BRA 0x2BC6
727:                       //send the RTR response
728:                       C1FIFOCON1H |= (_C1FIFOCON1H_TXREQ_MASK | _C1FIFOCON1H_UINC_MASK); // transmit
12BBE  0E03     MOVLW 0x3
12BC0  0101     MOVLB 0x1
12BC2  135D     IORWF 0x5D, F, BANKED
729:                       C1FIFOCON3Hbits.UINC = 1;   // Indicate that we have got the message from FIFO
12BC4  D015     BRA 0x2BF0
730:                       return NOT_RECEIVED;
731:                   }
732:                   m->len = (rxFifoObj[4] & 0x0F);
12BC6  EE20     LFSR 2, 0x4
12BC8  F004     NOP
12BCA  5019     MOVF 0x19, W, ACCESS
12BCC  26D9     ADDWF 0xFD9, F, ACCESS
12BCE  501A     MOVF 0x1A, W, ACCESS
12BD0  22DA     ADDWFC 0xFDA, F, ACCESS
12BD2  50DF     MOVF 0xFDF, W, ACCESS
12BD4  0B0F     ANDLW 0xF
12BD6  C511     MOVFF m, FSR2
12BD8  F4D9     NOP
12BDA  C512     MOVFF i, FSR2H
12BDC  F4DA     NOP
12BDE  6EDF     MOVWF 0xFDF, ACCESS
733:                   if (m->len == 0) {
12BE0  C511     MOVFF m, FSR2
12BE2  F4D9     NOP
12BE4  C512     MOVFF i, FSR2H
12BE6  F4DA     NOP
12BE8  50DF     MOVF 0xFDF, W, ACCESS
12BEA  A4D8     BTFSS 0xFD8, 2, ACCESS
12BEC  D003     BRA 0x2BF4
734:                       // message was a RTR response so no need to process further
735:                       C1FIFOCON3Hbits.UINC = 1;   // Indicate that we have got the message from FIFO
12BEE  0101     MOVLB 0x1
12BF0  8175     BSF CM2CON1, 0, BANKED
12BF2  D7B9     BRA 0x2B66
736:                       return NOT_RECEIVED;
737:                   }
738:                   m->opc = rxFifoObj[8];
12BF4  EE20     LFSR 2, 0x8
12BF6  F008     NOP
12BF8  5019     MOVF 0x19, W, ACCESS
12BFA  26D9     ADDWF 0xFD9, F, ACCESS
12BFC  501A     MOVF 0x1A, W, ACCESS
12BFE  22DA     ADDWFC 0xFDA, F, ACCESS
12C00  EE10     LFSR 1, 0x1
12C02  F001     NOP
12C04  5011     MOVF 0x11, W, ACCESS
12C06  26E1     ADDWF 0xFE1, F, ACCESS
12C08  5012     MOVF 0x12, W, ACCESS
12C0A  22E2     ADDWFC 0xFE2, F, ACCESS
12C0C  C4DF     MOVFF INDF2, INDF1
12C0E  F4E7     NOP
739:                   m->bytes[0] = rxFifoObj[9];
12C10  EE20     LFSR 2, 0x9
12C12  F009     NOP
12C14  5019     MOVF 0x19, W, ACCESS
12C16  26D9     ADDWF 0xFD9, F, ACCESS
12C18  501A     MOVF 0x1A, W, ACCESS
12C1A  22DA     ADDWFC 0xFDA, F, ACCESS
12C1C  EE10     LFSR 1, 0x2
12C1E  F002     NOP
12C20  5011     MOVF 0x11, W, ACCESS
12C22  26E1     ADDWF 0xFE1, F, ACCESS
12C24  5012     MOVF 0x12, W, ACCESS
12C26  22E2     ADDWFC 0xFE2, F, ACCESS
12C28  C4DF     MOVFF INDF2, INDF1
12C2A  F4E7     NOP
740:                   m->bytes[1] = rxFifoObj[10];
12C2C  EE20     LFSR 2, 0xA
12C2E  F00A     NOP
12C30  5019     MOVF 0x19, W, ACCESS
12C32  26D9     ADDWF 0xFD9, F, ACCESS
12C34  501A     MOVF 0x1A, W, ACCESS
12C36  22DA     ADDWFC 0xFDA, F, ACCESS
12C38  EE10     LFSR 1, 0x3
12C3A  F003     NOP
12C3C  5011     MOVF 0x11, W, ACCESS
12C3E  26E1     ADDWF 0xFE1, F, ACCESS
12C40  5012     MOVF 0x12, W, ACCESS
12C42  22E2     ADDWFC 0xFE2, F, ACCESS
12C44  C4DF     MOVFF INDF2, INDF1
12C46  F4E7     NOP
741:                   m->bytes[2] = rxFifoObj[11];
12C48  EE20     LFSR 2, 0xB
12C4A  F00B     NOP
12C4C  5019     MOVF 0x19, W, ACCESS
12C4E  26D9     ADDWF 0xFD9, F, ACCESS
12C50  501A     MOVF 0x1A, W, ACCESS
12C52  22DA     ADDWFC 0xFDA, F, ACCESS
12C54  EE10     LFSR 1, 0x4
12C56  F004     NOP
12C58  5011     MOVF 0x11, W, ACCESS
12C5A  26E1     ADDWF 0xFE1, F, ACCESS
12C5C  5012     MOVF 0x12, W, ACCESS
12C5E  22E2     ADDWFC 0xFE2, F, ACCESS
12C60  C4DF     MOVFF INDF2, INDF1
12C62  F4E7     NOP
742:                   m->bytes[3] = rxFifoObj[12];
12C64  EE20     LFSR 2, 0xC
12C66  F00C     NOP
12C68  5019     MOVF 0x19, W, ACCESS
12C6A  26D9     ADDWF 0xFD9, F, ACCESS
12C6C  501A     MOVF 0x1A, W, ACCESS
12C6E  22DA     ADDWFC 0xFDA, F, ACCESS
12C70  EE10     LFSR 1, 0x5
12C72  F005     NOP
12C74  5011     MOVF 0x11, W, ACCESS
12C76  26E1     ADDWF 0xFE1, F, ACCESS
12C78  5012     MOVF 0x12, W, ACCESS
12C7A  22E2     ADDWFC 0xFE2, F, ACCESS
12C7C  C4DF     MOVFF INDF2, INDF1
12C7E  F4E7     NOP
743:                   m->bytes[4] = rxFifoObj[13];
12C80  EE20     LFSR 2, 0xD
12C82  F00D     NOP
12C84  5019     MOVF 0x19, W, ACCESS
12C86  26D9     ADDWF 0xFD9, F, ACCESS
12C88  501A     MOVF 0x1A, W, ACCESS
12C8A  22DA     ADDWFC 0xFDA, F, ACCESS
12C8C  EE10     LFSR 1, 0x6
12C8E  F006     NOP
12C90  5011     MOVF 0x11, W, ACCESS
12C92  26E1     ADDWF 0xFE1, F, ACCESS
12C94  5012     MOVF 0x12, W, ACCESS
12C96  22E2     ADDWFC 0xFE2, F, ACCESS
12C98  C4DF     MOVFF INDF2, INDF1
12C9A  F4E7     NOP
744:                   m->bytes[5] = rxFifoObj[14];
12C9C  EE20     LFSR 2, 0xE
12C9E  F00E     NOP
12CA0  5019     MOVF 0x19, W, ACCESS
12CA2  26D9     ADDWF 0xFD9, F, ACCESS
12CA4  501A     MOVF 0x1A, W, ACCESS
12CA6  22DA     ADDWFC 0xFDA, F, ACCESS
12CA8  EE10     LFSR 1, 0x7
12CAA  F007     NOP
12CAC  5011     MOVF 0x11, W, ACCESS
12CAE  26E1     ADDWF 0xFE1, F, ACCESS
12CB0  5012     MOVF 0x12, W, ACCESS
12CB2  22E2     ADDWFC 0xFE2, F, ACCESS
12CB4  C4DF     MOVFF INDF2, INDF1
12CB6  F4E7     NOP
745:                   m->bytes[6] = rxFifoObj[15];
12CB8  EE20     LFSR 2, 0xF
12CBA  F00F     NOP
12CBC  5019     MOVF 0x19, W, ACCESS
12CBE  26D9     ADDWF 0xFD9, F, ACCESS
12CC0  501A     MOVF 0x1A, W, ACCESS
12CC2  22DA     ADDWFC 0xFDA, F, ACCESS
12CC4  EE10     LFSR 1, 0x8
12CC6  F008     NOP
12CC8  5011     MOVF 0x11, W, ACCESS
12CCA  26E1     ADDWF 0xFE1, F, ACCESS
12CCC  5012     MOVF 0x12, W, ACCESS
12CCE  22E2     ADDWFC 0xFE2, F, ACCESS
12CD0  C4DF     MOVFF INDF2, INDF1
12CD2  F4E7     NOP
746:           
747:                   C1FIFOCON3Hbits.UINC = 1;   // Indicate that we have got the message from FIFO
12CD4  0101     MOVLB 0x1
12CD4  0101     MOVLB 0x1
12CD4  0101     MOVLB 0x1
748:                   return RECEIVED;   // message available
749:               }
750:           }
751:           
752:           
753:           /*
754:           C1INTH.RXOVIE  // Receive Buffer Overflow       RX_BUFFER_OVERRUN
755:           C1INTH.IVMIF   // Invalid Message               RX_ERRORS
756:           C1INTH.CERRIF    // Bus Error                   ERROR_FRAMES_DET
757:           C1INTH.SERRIF    // System error
758:           C1FIFOSTA2L.C1TXLARB // Loss of arbitration     LOST_ARRBITARTAION
759:           C1BDIAG0H.NTERRCNT   // TX error                TX_ERRORS
760:           C1BDIAG0L.NRERRCNT   // RX error                RX_ERRORS
761:           C1FIFOSTA3.RXOVIF // RX Overruns
762:           C1FIFOSTA2.TXATIF // TX attempts
763:            */
764:           
765:           /**
766:            * Start a Self Enumeration.
767:            * @param txWaiting set to true if this self enumeration was triggered by a transmit request without a valid CANID.
768:            */
769:           static void startEnumeration(Boolean txWaiting) {
155BE  6E0C     MOVWF 0xC, ACCESS
770:               uint8_t i;
771:               
772:               for (i=1; i< ENUM_ARRAY_SIZE; i++) {
155C0  0E01     MOVLW 0x1
155C2  6E0D     MOVWF 0xD, ACCESS
773:                   enumerationResults[i] = 0;
155C4  0E40     MOVLW 0x40
155C6  240D     ADDWF 0xD, W, ACCESS
155C8  6ED9     MOVWF 0xFD9, ACCESS
155CA  6ADA     CLRF 0xFDA, ACCESS
155CC  0E06     MOVLW 0x6
155CE  22DA     ADDWFC 0xFDA, F, ACCESS
155D0  6ADF     CLRF 0xFDF, ACCESS
774:               }
155D2  2A0D     INCF 0xD, F, ACCESS
155D4  0E0F     MOVLW 0xF
155D6  640D     CPFSGT 0xD, ACCESS
155D8  D7F5     BRA 0x55C4
775:               enumerationResults[0] = 1;  // Don't allocate canid 0
155DA  0E01     MOVLW 0x1
155DC  0106     MOVLB 0x6
155DE  6F40     MOVWF NVMCON0, BANKED
776:           
777:               enumerationState = txWaiting ? ENUMERATION_IN_PROGRESS_TX_WAITING : ENUMERATION_IN_PROGRESS;
155E0  500C     MOVF 0xC, W, ACCESS
155E2  A4D8     BTFSS 0xFD8, 2, ACCESS
155E4  D002     BRA 0x55EA
155E6  0E02     MOVLW 0x2
155E8  D001     BRA 0x55EC
155EA  0E03     MOVLW 0x3
155EC  0105     MOVLB 0x5
155EE  6FAC     MOVWF ACTCON, BANKED
778:               enumerationStartTime.val = tickGet();
155F0  ECD8     CALL 0x153B0, 0
155F2  F0A9     NOP
155F4  C502     MOVFF i, enumerationStartTime
155F6  F578     NOP
155F8  C503     MOVFF opc, 0x579
155FA  F579     NOP
155FC  C504     MOVFF s, 0x57A
155FE  F57A     NOP
15600  C505     MOVFF i, 0x57B
15602  F57B     NOP
779:           #ifdef VLCB_DIAG
780:               canDiagnostics[CAN_DIAG_CANID_ENUMS].asUint++;
15604  0106     MOVLB 0x6
15606  4BCB     INFSNZ 0xCB, F, BANKED
15608  2BCC     INCF 0xCC, F, BANKED
781:           #endif
782:               sendRTR();              // Send RTR frame to initiate self enumeration
1560A  EC7D     CALL 0x158FA, 0
1560C  F0AC     NOP
783:           }
1560E  0012     RETURN 0
784:           
785:           /**
786:            * Start or respond to self-enumeration process.
787:            * Checks received frame in case CANID matches our own then will start a self enum process.
788:            * If self enum is in progress then save the CANIDs from any responses.
789:            * 
790:            * @param receivedCanId a CANID received from another module.
791:            */
792:           static void handleSelfEnumeration(uint8_t receivedCanId) {
145E4  6E10     MOVWF 0x10, ACCESS
793:               // Check incoming Canid and initiate self enumeration if it is the same as our own
794:               switch (enumerationState) {
145E6  D02E     BRA 0x4644
795:                   case ENUMERATION_IN_PROGRESS:
796:                   case ENUMERATION_IN_PROGRESS_TX_WAITING:
797:                       arraySetBit(enumerationResults, receivedCanId);
145E8  C510     MOVFF receivedCanId, txWaiting
145EA  F50C     NOP
145EC  0E07     MOVLW 0x7
145EE  160C     ANDWF 0xC, F, ACCESS
145F0  0E01     MOVLW 0x1
145F2  6E0D     MOVWF 0xD, ACCESS
145F4  2A0C     INCF 0xC, F, ACCESS
145F6  D002     BRA 0x45FC
145F8  90D8     BCF 0xFD8, 0, ACCESS
145FA  360D     RLCF 0xD, F, ACCESS
145FC  2E0C     DECFSZ 0xC, F, ACCESS
145FE  D7FC     BRA 0x45F8
14600  3810     SWAPF 0x10, W, ACCESS
14602  46E8     RLNCF 0xFE8, F, ACCESS
14604  0B1F     ANDLW 0x1F
14606  6E0E     MOVWF 0xE, ACCESS
14608  6A0F     CLRF 0xF, ACCESS
1460A  0E40     MOVLW 0x40
1460C  240E     ADDWF 0xE, W, ACCESS
1460E  6ED9     MOVWF 0xFD9, ACCESS
14610  0E06     MOVLW 0x6
14612  200F     ADDWFC 0xF, W, ACCESS
14614  6EDA     MOVWF 0xFDA, ACCESS
14616  500D     MOVF 0xD, W, ACCESS
14618  12DF     IORWF 0xFDF, F, ACCESS
798:                       break;
1461A  0012     RETURN 0
799:                   case NO_ENUMERATION:
800:                       if (receivedCanId == canId) {
1461C  51AF     MOVF OSCCON3, W, BANKED
1461E  1810     XORWF 0x10, W, ACCESS
14620  A4D8     BTFSS 0xFD8, 2, ACCESS
14622  0012     RETURN 0
801:                           // If we receive a packet with our own canid, initiate enumeration as automatic conflict resolution (Thanks to Bob V for this idea)
802:                           // we know enumerationInProgress = FALSE here
803:                           enumerationState = ENUMERATION_REQUIRED;
14624  0E01     MOVLW 0x1
14626  6FAC     MOVWF ACTCON, BANKED
804:           #ifdef VLCB_DIAG
805:                           canDiagnostics[CAN_DIAG_CANID_CONFLICTS].asUint++;
14628  0106     MOVLB 0x6
1462A  4BCD     INFSNZ 0xCD, F, BANKED
1462C  2BCE     INCF 0xCE, F, BANKED
806:           #endif
807:                           enumerationStartTime.val = tickGet();  // Start hold off time for self enumeration - start after 200ms delay
1462E  ECD8     CALL 0x153B0, 0
14630  F0A9     NOP
14632  C502     MOVFF i, enumerationStartTime
14634  F578     NOP
14636  C503     MOVFF opc, 0x579
14638  F579     NOP
1463A  C504     MOVFF s, 0x57A
1463C  F57A     NOP
1463E  C505     MOVFF i, 0x57B
14640  F57B     NOP
14642  0012     RETURN 0
808:                       }
809:                       break;
810:                   default:
811:                       break;
812:               }
14644  0105     MOVLB 0x5
14646  51AC     MOVF ACTCON, W, BANKED
14648  6E0C     MOVWF 0xC, ACCESS
1464A  6A0D     CLRF 0xD, ACCESS
1464C  500D     MOVF 0xD, W, ACCESS
1464E  0A00     XORLW 0x0
14650  A4D8     BTFSS 0xFD8, 2, ACCESS
14652  0012     RETURN 0
14654  500C     MOVF 0xC, W, ACCESS
14656  0A00     XORLW 0x0
14658  B4D8     BTFSC 0xFD8, 2, ACCESS
1465A  D7E0     BRA 0x461C
1465C  0A02     XORLW 0x2
1465E  B4D8     BTFSC 0xFD8, 2, ACCESS
14660  D7C3     BRA 0x45E8
14662  0A01     XORLW 0x1
14664  A4D8     BTFSS 0xFD8, 2, ACCESS
14664  A4D8     BTFSS 0xFD8, 2, ACCESS
14664  A4D8     BTFSS 0xFD8, 2, ACCESS
813:           }
814:           
815:           
816:           /**
817:            * Check if enumeration pending, if so kick it off providing hold off time has expired.
818:            * If enumeration complete, find and set new can id.
819:            */
820:           static void processEnumeration(void) {
821:               uint8_t i, newCanId, enumResult;
822:           
823:               switch (enumerationState) {
12FA4  D091     BRA 0x30C8
824:                   case ENUMERATION_REQUIRED:
825:                       // start after a 200ms delay
826:                       if (tickTimeSince(enumerationStartTime) > ENUMERATION_HOLDOFF ) {
12FA6  ECD8     CALL 0x153B0, 0
12FA8  F0A9     NOP
12FAA  0105     MOVLB 0x5
12FAC  5178     MOVF WDTCON0, W, BANKED
12FAE  5C02     SUBWF ___rparam_used, W, ACCESS
12FB0  6E18     MOVWF 0x18, ACCESS
12FB2  5179     MOVF WDTCON1, W, BANKED
12FB4  5803     SUBWFB __activetblptr, W, ACCESS
12FB6  6E19     MOVWF 0x19, ACCESS
12FB8  517A     MOVF WDTPSL, W, BANKED
12FBA  5804     SUBWFB __activetblptr, W, ACCESS
12FBC  6E1A     MOVWF 0x1A, ACCESS
12FBE  517B     MOVF WDTPSH, W, BANKED
12FC0  5805     SUBWFB 0x5, W, ACCESS
12FC2  6E1B     MOVWF 0x1B, ACCESS
12FC4  501B     MOVF 0x1B, W, ACCESS
12FC6  101A     IORWF 0x1A, W, ACCESS
12FC8  E106     BNZ 0x2FD6
12FCA  0ED5     MOVLW 0xD5
12FCC  5C18     SUBWF 0x18, W, ACCESS
12FCE  0E30     MOVLW 0x30
12FD0  5819     SUBWFB 0x19, W, ACCESS
12FD2  A0D8     BTFSS 0xFD8, 0, ACCESS
12FD4  0012     RETURN 0
827:                           /*
828:                            * Start a Self Enumeration
829:                            */
830:                           startEnumeration(0);
12FD6  0E00     MOVLW 0x0
12FD8  ECDF     CALL 0x155BE, 0
12FDA  F0AA     NOP
12FDC  0012     RETURN 0
831:                       }
832:                       break;
833:                   case ENUMERATION_IN_PROGRESS:
834:                   case ENUMERATION_IN_PROGRESS_TX_WAITING:
835:                       /*
836:                        * Continue Self Enumeration
837:                        */
838:                       if (tickTimeSince(enumerationStartTime) > ENUMERATION_TIMEOUT ) {
12FDE  ECD8     CALL 0x153B0, 0
12FE0  F0A9     NOP
12FE2  0105     MOVLB 0x5
12FE4  5178     MOVF WDTCON0, W, BANKED
12FE6  5C02     SUBWF ___rparam_used, W, ACCESS
12FE8  6E18     MOVWF 0x18, ACCESS
12FEA  5179     MOVF WDTCON1, W, BANKED
12FEC  5803     SUBWFB __activetblptr, W, ACCESS
12FEE  6E19     MOVWF 0x19, ACCESS
12FF0  517A     MOVF WDTPSL, W, BANKED
12FF2  5804     SUBWFB __activetblptr, W, ACCESS
12FF4  6E1A     MOVWF 0x1A, ACCESS
12FF6  517B     MOVF WDTPSH, W, BANKED
12FF8  5805     SUBWFB 0x5, W, ACCESS
12FFA  6E1B     MOVWF 0x1B, ACCESS
12FFC  501B     MOVF 0x1B, W, ACCESS
12FFE  101A     IORWF 0x1A, W, ACCESS
13000  E106     BNZ 0x300E
13002  0E6B     MOVLW 0x6B
13004  5C18     SUBWF 0x18, W, ACCESS
13006  0E18     MOVLW 0x18
13008  5819     SUBWFB 0x19, W, ACCESS
1300A  A0D8     BTFSS 0xFD8, 0, ACCESS
1300C  0012     RETURN 0
839:                           /*
840:                            * Enumeration complete, find first free canid
841:                            */
842:                           // Find byte in array with first free flag. Skip over 0xFF bytes
843:                           for (i=0; (enumerationResults[i] == 0xFF) && (i < ENUM_ARRAY_SIZE); i++) {
1300E  0E00     MOVLW 0x0
13010  6E1E     MOVWF 0x1E, ACCESS
13012  D001     BRA 0x3016
844:                               ;
845:                           } 
13014  2A1E     INCF 0x1E, F, ACCESS
13016  0E40     MOVLW 0x40
13018  241E     ADDWF 0x1E, W, ACCESS
1301A  6ED9     MOVWF 0xFD9, ACCESS
1301C  6ADA     CLRF 0xFDA, ACCESS
1301E  0E06     MOVLW 0x6
13020  22DA     ADDWFC 0xFDA, F, ACCESS
13022  28DE     INCF 0xFDE, W, ACCESS
13024  A4D8     BTFSS 0xFD8, 2, ACCESS
13026  D003     BRA 0x302E
13028  0E0F     MOVLW 0xF
1302A  641E     CPFSGT 0x1E, ACCESS
1302C  D7F3     BRA 0x3014
846:                           if ((enumResult = enumerationResults[i]) != 0xFF) {
1302E  0E40     MOVLW 0x40
13030  241E     ADDWF 0x1E, W, ACCESS
13032  6ED9     MOVWF 0xFD9, ACCESS
13034  6ADA     CLRF 0xFDA, ACCESS
13036  0E06     MOVLW 0x6
13038  22DA     ADDWFC 0xFDA, F, ACCESS
1303A  50DF     MOVF 0xFDF, W, ACCESS
1303C  6E1C     MOVWF 0x1C, ACCESS
1303E  281C     INCF 0x1C, W, ACCESS
13040  B4D8     BTFSC 0xFD8, 2, ACCESS
13042  D017     BRA 0x3072
847:                               for (newCanId = i*8; (enumResult & 0x01); newCanId++) {
13044  501E     MOVF 0x1E, W, ACCESS
13046  0D08     MULLW 0x8
13048  C4F3     MOVFF PROD, data1
1304A  F51D     NOP
1304C  D003     BRA 0x3054
848:                                   enumResult >>= 1;
1304E  90D8     BCF 0xFD8, 0, ACCESS
13050  321C     RRCF 0x1C, F, ACCESS
849:                               }
13052  2A1D     INCF 0x1D, F, ACCESS
13054  B01C     BTFSC 0x1C, 0, ACCESS
13056  D7FB     BRA 0x304E
850:                               if ((newCanId >= 1) && (newCanId <= 99)) {
13058  501D     MOVF 0x1D, W, ACCESS
1305A  B4D8     BTFSC 0xFD8, 2, ACCESS
1305C  D00A     BRA 0x3072
1305E  0E64     MOVLW 0x64
13060  601D     CPFSLT 0x1D, ACCESS
13062  D007     BRA 0x3072
851:                                   // found a new CANID
852:                                   canId = newCanId;
13064  C51D     MOVFF data1, canId
13066  F5AF     NOP
853:                                   setNewCanId(canId);
13068  0105     MOVLB 0x5
1306A  51AF     MOVF OSCCON3, W, BANKED
1306C  EC41     CALL 0x15C82, 0
1306E  F0AE     NOP
854:                               } else {
13070  D005     BRA 0x307C
855:           #ifdef VLCB_DIAG
856:                                   canDiagnostics[CAN_DIAG_CANID_ENUMS_FAIL].asUint++;
13072  0106     MOVLB 0x6
13074  4BD1     INFSNZ 0xD1, F, BANKED
13076  2BD2     INCF 0xD2, F, BANKED
857:                                   updateModuleErrorStatus();
13078  EC23     CALL 0x16246, 0
1307A  F0B1     NOP
858:           #endif
859:                               }
860:                           } else {
861:           #ifdef VLCB_DIAG
862:                               canDiagnostics[CAN_DIAG_CANID_ENUMS_FAIL].asUint++;
863:                               updateModuleErrorStatus();
864:           #endif
865:                           }
866:                           // If there are TX messages waiting then enable them now
867:                           if (enumerationState == ENUMERATION_IN_PROGRESS_TX_WAITING) {
1307C  0E03     MOVLW 0x3
1307E  0105     MOVLB 0x5
13080  19AC     XORWF ACTCON, W, BANKED
13082  A4D8     BTFSS 0xFD8, 2, ACCESS
13084  D01D     BRA 0x30C0
868:                               // put our new CANID into all the transmit buffers
869:                               for (i=0; i< CAN1_FIFO2_SIZE; i++) {
13086  0E00     MOVLW 0x0
13088  6E1E     MOVWF 0x1E, ACCESS
870:                                   *((uint8_t*)(CAN1_FIFO2_BUFFERS_BASE_ADDRESS + (i* (8 + CAN1_FIFO2_PAYLOAD_SIZE)))) = canId & 0x7f;
1308A  501E     MOVF 0x1E, W, ACCESS
1308C  6E18     MOVWF 0x18, ACCESS
1308E  6A19     CLRF 0x19, ACCESS
13090  3A18     SWAPF 0x18, F, ACCESS
13092  3A19     SWAPF 0x19, F, ACCESS
13094  0EF0     MOVLW 0xF0
13096  1619     ANDWF 0x19, F, ACCESS
13098  5018     MOVF 0x18, W, ACCESS
1309A  0B0F     ANDLW 0xF
1309C  1219     IORWF 0x19, F, ACCESS
1309E  0EF0     MOVLW 0xF0
130A0  1618     ANDWF 0x18, F, ACCESS
130A2  0E00     MOVLW 0x0
130A4  2418     ADDWF 0x18, W, ACCESS
130A6  6ED9     MOVWF 0xFD9, ACCESS
130A8  0E3C     MOVLW 0x3C
130AA  2019     ADDWFC 0x19, W, ACCESS
130AC  6EDA     MOVWF 0xFDA, ACCESS
130AE  51AF     MOVF OSCCON3, W, BANKED
130B0  0B7F     ANDLW 0x7F
130B2  6EDF     MOVWF 0xFDF, ACCESS
871:                               }
130B4  2A1E     INCF 0x1E, F, ACCESS
130B6  0E1F     MOVLW 0x1F
130B8  641E     CPFSGT 0x1E, ACCESS
130BA  D7E7     BRA 0x308A
872:                               // now send them all
873:                               C1FIFOCON2H |= _C1FIFOCON2H_TXREQ_MASK; // transmit
130BC  0101     MOVLB 0x1
130BE  8369     BSF 0x69, 1, BANKED
874:                           }
875:                           enumerationState = NO_ENUMERATION;
130C0  0E00     MOVLW 0x0
130C2  0105     MOVLB 0x5
130C4  6FAC     MOVWF ACTCON, BANKED
130C6  0012     RETURN 0
876:                       }
877:                       break;
878:                   default:
879:                       break;
880:               }
130C8  0105     MOVLB 0x5
130CA  51AC     MOVF ACTCON, W, BANKED
130CC  6E18     MOVWF 0x18, ACCESS
130CE  6A19     CLRF 0x19, ACCESS
130D0  5019     MOVF 0x19, W, ACCESS
130D2  0A00     XORLW 0x0
130D4  A4D8     BTFSS 0xFD8, 2, ACCESS
130D6  0012     RETURN 0
130D8  5018     MOVF 0x18, W, ACCESS
130DA  0A01     XORLW 0x1
130DC  B4D8     BTFSC 0xFD8, 2, ACCESS
130DE  D763     BRA 0x2FA6
130E0  0A03     XORLW 0x3
130E2  B4D8     BTFSC 0xFD8, 2, ACCESS
130E4  D77C     BRA 0x2FDE
130E6  0A01     XORLW 0x1
130E8  A4D8     BTFSS 0xFD8, 2, ACCESS
130E8  A4D8     BTFSS 0xFD8, 2, ACCESS
130E8  A4D8     BTFSS 0xFD8, 2, ACCESS
881:           }  // Process enumeration
882:               
883:           
884:           /**
885:            * Set a new can id. Update the diagnostic statistics.
886:            * @return CANID_OK upon success CANID_FAIL otherwise
887:            */
888:           static CanidResult setNewCanId(uint8_t newCanId) {
15C82  6E17     MOVWF 0x17, ACCESS
889:               if ((newCanId >= 1) && (newCanId <= 99)) {
15C84  5017     MOVF 0x17, W, ACCESS
15C86  B4D8     BTFSC 0xFD8, 2, ACCESS
15C88  0012     RETURN 0
15C8A  0E64     MOVLW 0x64
15C8C  6017     CPFSLT 0x17, ACCESS
15C8E  0012     RETURN 0
890:                   canId = newCanId;
15C90  C517     MOVFF tableIndex, canId
15C92  F5AF     NOP
891:                   // Update CANID in FIFO1 waiting message
892:                   prepareSelfEnumResponse();
15C94  ECF7     CALL 0x14DEE, 0
15C96  F0A6     NOP
893:                   writeNVM(CANID_NVM_TYPE, CANID_ADDRESS, newCanId );       // Update saved value
15C98  0EFE     MOVLW 0xFE
15C9A  6E10     MOVWF 0x10, ACCESS
15C9C  0E03     MOVLW 0x3
15C9E  6E11     MOVWF 0x11, ACCESS
15CA0  0E00     MOVLW 0x0
15CA2  6E12     MOVWF 0x12, ACCESS
15CA4  C517     MOVFF tableIndex, hi
15CA6  F513     NOP
15CA8  0E00     MOVLW 0x0
15CAA  EC7E     CALL 0x156FC, 0
15CAC  F0AB     NOP
894:           #ifdef VLCB_DIAG
895:                   canDiagnostics[CAN_DIAG_CANID_CHANGES].asUint++;
15CAE  0106     MOVLB 0x6
15CB0  4BCF     INFSNZ 0xCF, F, BANKED
15CB2  2BD0     INCF 0xD0, F, BANKED
896:           #endif
897:                   return CANID_OK;
898:               } else {
899:                   return CANID_FAIL;
900:               }
901:           }
15CB4  0012     RETURN 0
902:           
903:           /************************************
904:            * Section copied from MCC generated code
905:            *************************************/
906:           /**
907:            * Set the mode of the CAN peripheral.
908:            * @param requestMode
909:            * @return status result of the request
910:            */
911:           enum CAN_OP_MODE_STATUS CAN1_OperationModeSet(const enum CAN_OP_MODES requestMode)
157E0  6E03     MOVWF __activetblptr, ACCESS
912:           {
913:               enum CAN_OP_MODE_STATUS status = CAN_OP_MODE_REQUEST_SUCCESS;
157E2  0E00     MOVLW 0x0
157E4  6E02     MOVWF ___rparam_used, ACCESS
914:           
915:               if ((CAN1_OperationModeGet() == CAN_CONFIGURATION_MODE)
157E6  EC29     CALL 0x16252, 0
157E8  F0B1     NOP
157EA  0A04     XORLW 0x4
157EC  B4D8     BTFSC 0xFD8, 2, ACCESS
157EE  D007     BRA 0x57FE
157F0  0403     DECF __activetblptr, W, ACCESS
157F2  B4D8     BTFSC 0xFD8, 2, ACCESS
157F4  D004     BRA 0x57FE
157F6  0E04     MOVLW 0x4
157F8  1803     XORWF __activetblptr, W, ACCESS
157FA  A4D8     BTFSS 0xFD8, 2, ACCESS
157FC  D012     BRA 0x5822
916:                   || (requestMode == CAN_DISABLE_MODE)
917:                   || (requestMode == CAN_CONFIGURATION_MODE))
918:               {
919:                   C1CONTbits.REQOP = requestMode;
157FE  0101     MOVLB 0x1
15800  5103     MOVF __activetblptr, W, BANKED
15802  1803     XORWF __activetblptr, W, ACCESS
15804  0BF8     ANDLW 0xF8
15806  1803     XORWF __activetblptr, W, ACCESS
15808  6F03     MOVWF __activetblptr, BANKED
920:                   
921:                   while (C1CONUbits.OPMOD != requestMode)
1580A  D004     BRA 0x5814
15814  3902     SWAPF ___rparam_used, W, BANKED
15816  32E8     RRCF 0xFE8, F, ACCESS
15818  0B07     ANDLW 0x7
1581A  1803     XORWF __activetblptr, W, ACCESS
1581C  B4D8     BTFSC 0xFD8, 2, ACCESS
1581E  D003     BRA 0x5826
15820  D7F5     BRA 0x580C
922:                   {
923:                       //This condition is avoiding the system error case endless loop
924:                       if (C1INTHbits.SERRIF == 1)
1580C  A91D     BTFSS 0x1D, 4, BANKED
1580E  D002     BRA 0x5814
925:                       {
926:                           status = CAN_OP_MODE_SYS_ERROR_OCCURED;
15810  0E02     MOVLW 0x2
15812  D008     BRA 0x5824
927:                           break;
928:                       }
929:                   }
930:               }
931:               else
932:               {
933:                   status = CAN_OP_MODE_REQUEST_FAIL;
15822  0E01     MOVLW 0x1
15824  6E02     MOVWF ___rparam_used, ACCESS
934:               }
935:           
936:               return status;
15826  5002     MOVF ___rparam_used, W, ACCESS
937:           }
15828  0012     RETURN 0
938:           
939:           /**
940:            * Get the current operating mode of the CAN peripheral.
941:            * 
942:            * @return the current operating mode 
943:            */
944:           enum CAN_OP_MODES CAN1_OperationModeGet(void)
945:           {
946:               return C1CONUbits.OPMOD;
16252  0101     MOVLB 0x1
16254  3902     SWAPF ___rparam_used, W, BANKED
16256  32E8     RRCF 0xFE8, F, ACCESS
16258  0B07     ANDLW 0x7
947:           }
1625A  0012     RETURN 0
948:           #endif
---  C:/Users/ianwh/github/VLCBlib_PIC/boot.c  ----------------------------------------------------------
1:             /**
2:              * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
3:              */
4:             /*
5:               This work is licensed under the:
6:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
7:                To view a copy of this license, visit:
8:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
9:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
10:            
11:               License summary:
12:                You are free to:
13:                  Share, copy and redistribute the material in any medium or format
14:                  Adapt, remix, transform, and build upon the material
15:            
16:                The licensor cannot revoke these freedoms as long as you follow the license terms.
17:            
18:                Attribution : You must give appropriate credit, provide a link to the license,
19:                               and indicate if changes were made. You may do so in any reasonable manner,
20:                               but not in any way that suggests the licensor endorses you or your use.
21:            
22:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
23:            
24:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
25:                              your contributions under the same license as the original.
26:            
27:                No additional restrictions : You may not apply legal terms or technological measures that
28:                                              legally restrict others from doing anything the license permits.
29:            
30:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
31:            
32:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
33:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
34:            */
35:            /**
36:             * @author Ian Hogg 
37:             * @date Dec 2022
38:             * 
39:             */ 
40:            #include <xc.h>
41:            #include "vlcb.h"
42:            #include "module.h"
43:            #include "boot.h"
44:            #include "mns.h"
45:            /**
46:             * @file
47:             * @brief
48:             * Implementation of the VLCB BOOT service, supports the FCU and CBUS (PIC based)
49:             * bootloading protocol.
50:             * @details
51:             * The service definition object is called bootService.
52:             * In order to be compatible with the FCU bootloader there are additional
53:             * requirements for the parameter block which are actually supported by the MNS.
54:             *
55:             * Application code packed with the bootloader must be compiled with options:
56:             *  - XC8 linker options -> Additional options --CODEOFFSET=0x800 
57:             *  - This generates an error ::: warning: (2044) unrecognized option "--CODEOFFSET=0x800"
58:             * but this can be ignored as the option works.
59:             * 
60:             * Then the Application project must be made dependent on the Bootloader 
61:             * project by adding the Bootloader to project properties->Conf:->Loading
62:             * The project hex fill will have the .unified.hex extension.
63:             */
64:            
65:            // forward declarations
66:            static void bootPowerUp(void);
67:            static Processed bootProcessMessage(Message * m);
68:            static uint8_t bootEsdData(uint8_t id);
69:            
70:            /**
71:             * The service descriptor for the BOOT service. The application must include this
72:             * descriptor within the application's const Service * const services[] array and include the
73:             * necessary settings within module.h in order to make use of the PIC bootloading
74:             * service.
75:             */
76:            const Service bootService = {
77:                SERVICE_ID_BOOT,    // id
78:                2,                  // version 2 supporting versioning
79:                NULL,               // factoryReset
80:                bootPowerUp,        // powerUp
81:                bootProcessMessage, // processMessage
82:                NULL,               // poll
83:            #if defined(_18F66K80_FAMILY_)
84:                NULL,               // highIsr
85:                NULL,               // lowIsr
86:            #endif
87:            #ifdef VLCB_SERVICE
88:                bootEsdData,        // ESD data
89:            #endif
90:            #ifdef VLCB_DIAG
91:                NULL                // getDiagnostic
92:            #endif
93:            };
94:            
95:            // Set the EEPROM_BOOT_FLAG to 0 to ensure the application is entered
96:            // after loading using the PicKit.
97:            // Bootflag resides at top of EEPROM.
98:            /** @private */
99:            asm("PSECT eeprom_data,class=EEDATA");
100:           /** @private */
101:           asm("ORG " ___mkstr(EE_TOP));
102:           /** @private */
103:           asm("db 0");
104:           /** Used internally for calculating checksum.  */
105:           #define PRM_CKSUM1 PARAM_MANU+PARAM_MINOR_VERSION+PARAM_MODULE_ID+PARAM_NUM_EVENTS\
106:               +PARAM_NUM_EV_EVENT+PARAM_NUM_NV+PARAM_MAJOR_VERSION+(8)\
107:               +(8)+CPUM_MICROCHIP+PARAM_BUILD_VERSION\
108:               +(20)+(0x48)+(0x08)
109:           
110:           #ifdef CONSUMED_EVENTS
111:           /** Used internally for calculating checksum.  */
112:           #define PRM_CKSUM2      PRM_CKSUM1+1
113:           #else
114:           /** Used internally for calculating checksum.  */
115:           #define PRM_CKSUM2      PRM_CKSUM1
116:           #endif
117:           #ifdef PRODUCED_EVENTS
118:           /** Used internally for calculating checksum.  */
119:           #define PRM_CKSUM3      PRM_CKSUM2+2
120:           #else
121:           /** Used internally for calculating checksum.  */
122:           #define PRM_CKSUM3      PRM_CKSUM2
123:           #endif
124:           #ifdef CANID_ADDRESS
125:           /** Used internally for calculating checksum.  */
126:           #define PRM_CKSUM4      PRM_CKSUM3+PB_CAN
127:           #else
128:           /** Used internally for calculating checksum.  */
129:           #define PRM_CKSUM4      PRM_CKSUM3
130:           #endif
131:           #if defined(_18F66K80_FAMILY_)
132:           #define    PRM_CKSUM5  PRM_CKSUM4+P18F26K80
133:           #elif defined(_18FXXQ83_FAMILY_)
134:           #define    PRM_CKSUM5  PRM_CKSUM4+P18F27Q83
135:           #else
136:               Error unrecognised CPU type,
137:           #endif 
138:           
139:           /**
140:            * @private
141:            * Create the parameter block located at 0x820. This is done entirely by the 
142:            * preprocessor.
143:            */
144:           const uint8_t paramBlock[] __at(0x820) = {
145:               PARAM_MANU,         //0x820
146:               PARAM_MINOR_VERSION,//0x821
147:               PARAM_MODULE_ID,    //0x822
148:               PARAM_NUM_EVENTS,   //0x823
149:               PARAM_NUM_EV_EVENT, //0x824
150:               PARAM_NUM_NV,       //0x825
151:               PARAM_MAJOR_VERSION,//0x826
152:               0x08                // definitely BOOTABLE 
153:           #ifdef CONSUMED_EVENTS
154:                       |0x01
155:           #endif
156:           #ifdef PRODUCED_EVENTS
157:                       |0x02
158:           #endif
159:                   ,
160:           #if defined(_18F66K80_FAMILY_)
161:               P18F26K80,          //0x828
162:           #elif defined(_18FXXQ83_FAMILY_)
163:               P18F27Q83,          //0x828
164:           #else
165:               Error unrecognised CPU type,
166:           #endif 
167:               
168:           #ifdef CANID_ADDRESS
169:               PB_CAN,             //0x829 Protocol 1=
170:           #endif
171:               0,8,0,0,            //0x82a load address
172:               0,0,0,0,            //0x82e processor code
173:               CPUM_MICROCHIP,     //0x832
174:               PARAM_BUILD_VERSION,//0x833
175:               0,                  //0x834 reserved
176:               0,                  //0x835 reserved
177:               0,                  //0x836 reserved
178:               0,                  //0x837 reserved
179:               20,                 //0x838 num parameters lo
180:               0,                  //0x839 num parameters hi
181:               0x48,               //0x83a address of NAME lo
182:               0x08,               //0x83b address of NAME hi
183:               0,                  //0x83c address of NAME upper lo
184:               0,                  //0x83d address of NAME upper hi
185:               ((PRM_CKSUM5)&0xFF),  //0x83e checksum lo
186:               ((PRM_CKSUM5)>>8)     //0x83f checksum hi
187:           };
188:           
189:           
190:           static const char bl_version[] = { 'B','L','_','V','E','R','S','I','O','N','='};
191:           static uint8_t bootloaderType;
192:           static uint8_t bootloaderVersion;
193:           
194:           /**
195:            * Power up the BOOT service. Search and extract the bootloader's version.
196:            */
197:           void bootPowerUp(void) {
198:               uint24_t a;
199:               uint8_t i;
200:               uint8_t b;
201:               uint8_t found;
202:               
203:               bootloaderType = BL_TYPE_Unknown;
13DB2  0E00     MOVLW 0x0
13DB4  0105     MOVLB 0x5
13DB6  6FB1     MOVWF OSCFRQ, BANKED
204:               bootloaderVersion = 0;
13DB8  0E00     MOVLW 0x0
13DBA  6FB0     MOVWF OSCTUNE, BANKED
205:               
206:               // attempt to find the bl_version string within the bootloader
207:               for (a=0; a<0x7FF; a++) {
13DBC  0E00     MOVLW 0x0
13DBE  6E11     MOVWF 0x11, ACCESS
13DC0  0E00     MOVLW 0x0
13DC2  6E12     MOVWF 0x12, ACCESS
13DC4  0E00     MOVLW 0x0
13DC6  6E13     MOVWF 0x13, ACCESS
208:                   found = 1;
209:                   for (i=0; i<11; i++) {
13DC8  0E00     MOVLW 0x0
13DCA  6E10     MOVWF 0x10, ACCESS
210:                       b = (uint8_t)readNVM(FLASH_NVM_TYPE, a+i);
13DCC  5010     MOVF 0x10, W, ACCESS
13DCE  2411     ADDWF 0x11, W, ACCESS
13DD0  6E08     MOVWF 0x8, ACCESS
13DD2  0E00     MOVLW 0x0
13DD4  2012     ADDWFC 0x12, W, ACCESS
13DD6  6E09     MOVWF 0x9, ACCESS
13DD8  0E00     MOVLW 0x0
13DDA  2013     ADDWFC 0x13, W, ACCESS
13DDC  6E0A     MOVWF 0xA, ACCESS
13DDE  0E01     MOVLW 0x1
13DE0  ECF3     CALL 0x151E6, 0
13DE2  F0A8     NOP
13DE4  5008     MOVF 0x8, W, ACCESS
13DE6  6E0E     MOVWF 0xE, ACCESS
211:                       if (b != bl_version[i]) {
13DE8  0E35     MOVLW 0x35
13DEA  2410     ADDWF 0x10, W, ACCESS
13DEC  6EF6     MOVWF 0xFF6, ACCESS
13DEE  6AF7     CLRF 0xFF7, ACCESS
13DF0  0EFF     MOVLW 0xFF
13DF2  22F7     ADDWFC 0xFF7, F, ACCESS
13DF4  6AF8     CLRF 0xFF8, ACCESS
13DF6  0E00     MOVLW 0x0
13DF8  22F8     ADDWFC 0xFF8, F, ACCESS
13DFA  0008     TBLRD*
13DFC  50F5     MOVF 0xFF5, W, ACCESS
13DFE  180E     XORWF 0xE, W, ACCESS
13E00  B4D8     BTFSC 0xFD8, 2, ACCESS
13E02  D003     BRA 0x3E0A
212:                           found = 0;
13E04  0E00     MOVLW 0x0
13E06  6E0F     MOVWF 0xF, ACCESS
213:                           break;
13E08  D006     BRA 0x3E16
214:                       } else {
215:                           found = 1;
13E0A  0E01     MOVLW 0x1
13E0C  6E0F     MOVWF 0xF, ACCESS
216:                       }
217:                   }
13E0E  2A10     INCF 0x10, F, ACCESS
13E10  0E0A     MOVLW 0xA
13E12  6410     CPFSGT 0x10, ACCESS
13E14  D7DB     BRA 0x3DCC
218:                   if (found) {
13E16  500F     MOVF 0xF, W, ACCESS
13E18  B4D8     BTFSC 0xFD8, 2, ACCESS
13E1A  D01F     BRA 0x3E5A
219:                       bootloaderType = (uint8_t)readNVM(FLASH_NVM_TYPE, a+11);
13E1C  0E0B     MOVLW 0xB
13E1E  2411     ADDWF 0x11, W, ACCESS
13E20  6E08     MOVWF 0x8, ACCESS
13E22  0E00     MOVLW 0x0
13E24  2012     ADDWFC 0x12, W, ACCESS
13E26  6E09     MOVWF 0x9, ACCESS
13E28  0E00     MOVLW 0x0
13E2A  2013     ADDWFC 0x13, W, ACCESS
13E2C  6E0A     MOVWF 0xA, ACCESS
13E2E  0E01     MOVLW 0x1
13E30  ECF3     CALL 0x151E6, 0
13E32  F0A8     NOP
13E34  5008     MOVF 0x8, W, ACCESS
13E36  0105     MOVLB 0x5
13E38  6FB1     MOVWF OSCFRQ, BANKED
220:                       bootloaderVersion = (uint8_t)readNVM(FLASH_NVM_TYPE, a+12);
13E3A  0E0C     MOVLW 0xC
13E3C  2411     ADDWF 0x11, W, ACCESS
13E3E  6E08     MOVWF 0x8, ACCESS
13E40  0E00     MOVLW 0x0
13E42  2012     ADDWFC 0x12, W, ACCESS
13E44  6E09     MOVWF 0x9, ACCESS
13E46  0E00     MOVLW 0x0
13E48  2013     ADDWFC 0x13, W, ACCESS
13E4A  6E0A     MOVWF 0xA, ACCESS
13E4C  0E01     MOVLW 0x1
13E4E  ECF3     CALL 0x151E6, 0
13E50  F0A8     NOP
13E52  5008     MOVF 0x8, W, ACCESS
13E54  0105     MOVLB 0x5
13E56  6FB0     MOVWF OSCTUNE, BANKED
13E58  0012     RETURN 0
221:                       return;
222:                   } 
223:               }
13E5A  0E01     MOVLW 0x1
13E5C  2611     ADDWF 0x11, F, ACCESS
13E5E  0E00     MOVLW 0x0
13E60  2212     ADDWFC 0x12, F, ACCESS
13E62  0E00     MOVLW 0x0
13E64  2213     ADDWFC 0x13, F, ACCESS
13E66  5013     MOVF 0x13, W, ACCESS
13E68  E106     BNZ 0x3E76
13E6A  2811     INCF 0x11, W, ACCESS
13E6C  0E07     MOVLW 0x7
13E6E  5812     SUBWFB 0x12, W, ACCESS
13E70  B0D8     BTFSC 0xFD8, 0, ACCESS
13E72  0012     RETURN 0
13E74  D7A9     BRA 0x3DC8
224:           }
13E76  0012     RETURN 0
225:           /**
226:            * Process the bootloader specific messages. The only messages which need to be 
227:            * processed is BOOTM (also called BOOT) and MODE.
228:            * @param m the VLCB message
229:            * @return PROCESSED to indicate that the message has been processed, NOT_PROCESSED otherwise
230:            */
231:           static Processed bootProcessMessage(Message * m) {
232:               // check NN matches us
233:               if (m->bytes[0] != nn.bytes.hi) return NOT_PROCESSED;
1455C  EE20     LFSR 2, 0x2
1455E  F002     NOP
14560  5046     MOVF NVMDAT, W, ACCESS
14562  26D9     ADDWF 0xFD9, F, ACCESS
14564  5047     MOVF NVMDATH, W, ACCESS
14566  22DA     ADDWFC 0xFDA, F, ACCESS
14568  50DE     MOVF 0xFDE, W, ACCESS
1456A  1854     XORWF 0x54, W, ACCESS
1456C  B4D8     BTFSC 0xFD8, 2, ACCESS
1456E  D002     BRA 0x4574
14570  0E00     MOVLW 0x0
14572  0012     RETURN 0
234:               if (m->bytes[1] != nn.bytes.lo) return NOT_PROCESSED;
14574  EE20     LFSR 2, 0x3
14576  F003     NOP
14578  5046     MOVF NVMDAT, W, ACCESS
1457A  26D9     ADDWF 0xFD9, F, ACCESS
1457C  5047     MOVF NVMDATH, W, ACCESS
1457E  22DA     ADDWFC 0xFDA, F, ACCESS
14580  5053     MOVF 0x53, W, ACCESS
14582  18DE     XORWF 0xFDE, W, ACCESS
14584  A4D8     BTFSS 0xFD8, 2, ACCESS
14586  D7F4     BRA 0x4570
14588  D018     BRA 0x45BA
235:               
236:               switch (m->opc) {
237:           #ifdef VLCB_MODE
238:                   case OPC_MODE:
239:                       if (m->bytes[2] != MODE_BOOT) return NOT_PROCESSED;
1458A  EE20     LFSR 2, 0x4
1458C  F004     NOP
1458E  5046     MOVF NVMDAT, W, ACCESS
14590  26D9     ADDWF 0xFD9, F, ACCESS
14592  5047     MOVF NVMDATH, W, ACCESS
14594  22DA     ADDWFC 0xFDA, F, ACCESS
14596  0E0E     MOVLW 0xE
14598  18DE     XORWF 0xFDE, W, ACCESS
1459A  A4D8     BTFSS 0xFD8, 2, ACCESS
1459C  D7E9     BRA 0x4570
240:                       // FALL THROUGH
241:           #endif
242:                   case OPC_BOOT:
243:                       // Set the bootloader flag to be picked up by the bootloader
244:                       writeNVM(BOOT_FLAG_NVM_TYPE, BOOT_FLAG_ADDRESS, 0xFF); 
1459E  0EFF     MOVLW 0xFF
145A0  6E10     MOVWF 0x10, ACCESS
145A2  0E03     MOVLW 0x3
145A4  6E11     MOVWF 0x11, ACCESS
145A6  0E00     MOVLW 0x0
145A8  6E12     MOVWF 0x12, ACCESS
145AA  0EFF     MOVLW 0xFF
145AC  6E13     MOVWF 0x13, ACCESS
145AE  0E00     MOVLW 0x0
145B0  EC7E     CALL 0x156FC, 0
145B2  F0AB     NOP
245:                       RESET();     // will enter the bootloader
145B4  00FF     RESET
246:                       return PROCESSED;
145B6  0E01     MOVLW 0x1
145B8  0012     RETURN 0
247:                   default:
248:                       return NOT_PROCESSED;   // message not processed
249:               }
145BA  EE20     LFSR 2, 0x1
145BC  F001     NOP
145BE  5046     MOVF NVMDAT, W, ACCESS
145C0  26D9     ADDWF 0xFD9, F, ACCESS
145C2  5047     MOVF NVMDATH, W, ACCESS
145C4  22DA     ADDWFC 0xFDA, F, ACCESS
145C6  50DF     MOVF 0xFDF, W, ACCESS
145C8  6E48     MOVWF VREGCON, ACCESS
145CA  6A49     CLRF BORCON, ACCESS
145CC  5049     MOVF BORCON, W, ACCESS
145CE  0A00     XORLW 0x0
145D0  A4D8     BTFSS 0xFD8, 2, ACCESS
145D2  D7CE     BRA 0x4570
145D4  5048     MOVF VREGCON, W, ACCESS
145D6  0A5C     XORLW 0x5C
145D8  B4D8     BTFSC 0xFD8, 2, ACCESS
145DA  D7E1     BRA 0x459E
145DC  0A2A     XORLW 0x2A
145DE  B4D8     BTFSC 0xFD8, 2, ACCESS
145DE  B4D8     BTFSC 0xFD8, 2, ACCESS
145DE  B4D8     BTFSC 0xFD8, 2, ACCESS
250:           }
251:           
252:           /**
253:            * The BOOT service ESD bytes. Return the bootloader type and version.
254:            * @param id the identifier for the ESD requested
255:            * @return  the ESD value
256:            */
257:           uint8_t bootEsdData(uint8_t id) {
15FC2  6E02     MOVWF ___rparam_used, ACCESS
258:               switch (id) {
15FC4  D008     BRA 0x5FD6
259:                   case 1:
260:                       // The bootloader type
261:                       return bootloaderType;
15FC6  0105     MOVLB 0x5
15FC8  51B1     MOVF OSCFRQ, W, BANKED
15FCA  0012     RETURN 0
262:                   case 2:
263:                       // The bootloader version
264:                       return bootloaderVersion;
15FCC  0105     MOVLB 0x5
15FCE  51B0     MOVF OSCTUNE, W, BANKED
15FD0  0012     RETURN 0
265:                   default:
266:                       return 0;
15FD2  0E00     MOVLW 0x0
15FD4  0012     RETURN 0
267:               }
15FD6  5002     MOVF ___rparam_used, W, ACCESS
15FD8  0A01     XORLW 0x1
15FDA  B4D8     BTFSC 0xFD8, 2, ACCESS
15FDC  D7F4     BRA 0x5FC6
15FDE  0A03     XORLW 0x3
15FE0  B4D8     BTFSC 0xFD8, 2, ACCESS
15FE2  D7F4     BRA 0x5FCC
15FE2  D7F4     BRA 0x5FCC
268:           } 
---  C:/Users/ianwh/github/CANPAN2/main.c  --------------------------------------------------------------
1:             #include <xc.h>
2:             #include "module.h"
3:             #include "vlcb.h"
4:             // the services
5:             #include "mns.h"
6:             #include "nv.h"
7:             #include "can.h"
8:             #include "boot.h"
9:             #include "event_teach.h"
10:            #include "event_consumer_simple.h"
11:            #include "event_producer.h"
12:            #include "event_acknowledge.h"
13:            #include "event_coe.h"
14:            // others
15:            #include "ticktime.h"
16:            #include "timedResponse.h"
17:            #include "devincs.h"
18:            #include <stddef.h>
19:            #include "statusLeds.h"
20:            #include "nvm.h"
21:            #include "timedResponse.h"
22:            // module specific
23:            #include "canpan3Nv.h"
24:            #include "canpan3Inputs.h"
25:            #include "canpan3Events.h"
26:            
27:            /*
28:              This work is licensed under the:
29:                  Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
30:               To view a copy of this license, visit:
31:                  http://creativecommons.org/licenses/by-nc-sa/4.0/
32:               or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
33:            
34:               License summary:
35:                You are free to:
36:                  Share, copy and redistribute the material in any medium or format
37:                  Adapt, remix, transform, and build upon the material
38:            
39:                The licensor cannot revoke these freedoms as long as you follow the license terms.
40:            
41:                Attribution : You must give appropriate credit, provide a link to the license,
42:                               and indicate if changes were made. You may do so in any reasonable manner,
43:                               but not in any way that suggests the licensor endorses you or your use.
44:            
45:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
46:            
47:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
48:                              your contributions under the same license as the original.
49:            
50:                No additional restrictions : You may not apply legal terms or technological measures that
51:                                              legally restrict others from doing anything the license permits.
52:            
53:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
54:            
55:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
56:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
57:             */
58:            /**
59:             *	The Main CANMIO program supporting configurable I/O.
60:             *
61:             * @author Ian Hogg 
62:             * @date August 2024
63:             * 
64:             */ 
65:            /**
66:             * @copyright Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
67:             */ 
68:            
69:            
70:            
71:            
72:            /**************************************************************************
73:             * Application code packed with the bootloader must be compiled with options:
74:             * XC8 linker options -> Additional options --CODEOFFSET=0x800 
75:             * This generates an error
76:             * ::: warning: (2044) unrecognized option "--CODEOFFSET=0x800"
77:             * but this can be ignored as the option works
78:             * 
79:             * Then the Application project must be made dependent on the Bootloader 
80:             * project by adding the Bootloader to project properties->Conf:->Loading
81:             ***************************************************************************/
82:            
83:            /*
84:             * File:   main.c
85:             * Author: Ian Hogg
86:             * 
87:             * This is the main for the CANPAN2 module.
88:             * Based on EV and NV settings of CANPAN_4c_beta104
89:             */
90:            
91:            // TODOs
92:            // * Receipt of event on a toggle switch to update state (Toggle with monitor)
93:            // * Debounce inputs - if needed
94:            //
95:            // Once CANPAN compatible version is released then additional enhancements
96:            // * Add NVs for LED brightness control
97:            // * Add additional timer to turn a cathode on late or turn off early according to brightness
98:            // * Dual button set/reset for 1 event
99:            
100:           
101:           // forward declarations
102:           void __init(void);
103:           uint8_t checkCBUS( void);
104:           void ISRHigh(void);
105:           void initialise(void);
106:           void configIO(uint8_t io);
107:           void factoryReset(void);
108:           void setType(uint8_t i, uint8_t type);
109:           void factoryResetEE(void);
110:           void factoryResetFlash(void);
111:           void factoryResetGlobalEvents(void);
112:           extern void initOutputs(void);
113:           extern void initLeds(void);
114:           extern void processActions(void);
115:           extern void processOutputs(void);
116:           #if defined(_18F66K80_FAMILY_)
117:           extern void inputIsr(void);
118:           extern void outputIsr(void);
119:           #endif
120:           
121:           static TickValue   startTime;
122:           static uint8_t        started;
123:           TickValue   lastServoStartTime;
124:           static TickValue   lastInputScanTime;
125:           static TickValue   lastActionPollTime;
126:           static TickValue   flashTime;
127:           
128:           const Service * const services[] = {
129:               &canService,
130:               &mnsService,
131:               &nvService,
132:               &bootService,
133:               &eventTeachService,
134:               &eventConsumerService,
135:               &eventProducerService,
136:               &eventCoeService,
137:               &eventAckService
138:           };
139:           
140:           
141:           /**
142:            * Called at first run to initialise all the non volatile memory. 
143:            * Also called if the PB hold down special sequence at power up is done.
144:            * Also called as a result of a NNRSM request.
145:            */
146:           void APP_factoryReset(void) {
147:               uint8_t io;
148:               
149:               factoryResetGlobalEvents();
16266  EC17     CALL 0x1222E, 0
16268  F091     NOP
150:           
151:               flushFlashBlock();
1626A  EC22     CALL 0x15244, 0
1626C  F0A9     NOP
152:           }
1626E  0012     RETURN 0
153:           
154:           /**
155:            * Called if the PB is held down during power up.
156:            * Normally would perform any test functionality to help a builder check the hardware.
157:            */
158:           void APP_testMode(void) {
162A6  0012     RETURN 0
159:               
160:           }
14D10  A6B1     BTFSS 0xFB1, 3, ACCESS
161:           
162:           /**
163:            * Called upon power up.
164:            */
165:           void setup(void) {
166:           #if defined(_18FXXQ83_FAMILY_)
167:               uint8_t pu;
168:           #endif
169:               uint8_t nv;
170:               
171:               // use CAN as the module's transport
172:               transport = &canTransport;
13CE2  0EF9     MOVLW 0xF9
13CE4  0105     MOVLB 0x5
13CE6  6F9B     MOVWF 0x9B, BANKED
13CE8  0EFF     MOVLW 0xFF
13CEA  6F9C     MOVWF 0x9C, BANKED
173:           
174:               /**
175:                * The order of initialisation is important.
176:                */
177:           #if defined(_18F66K80_FAMILY_)
178:               INTCON2bits.RBPU = 0;
179:               // default to all digital IO
180:               ANCON0 = 0x00;
181:               ANCON1 = 0x00;
182:           #endif
183:           #if defined(_18FXXQ83_FAMILY_)
184:               WPUA = 0b00001000;  // ensure the pushbutton pullup is still enabled
13CEC  0E08     MOVLW 0x8
13CEE  0104     MOVLB 0x4
13CF0  6F01     MOVWF ___rparam_used, BANKED
185:               WPUB = 0;
13CF2  0E00     MOVLW 0x0
13CF4  6F09     MOVWF 0x9, BANKED
186:               WPUC = 0;
13CF6  0E00     MOVLW 0x0
13CF8  6F11     MOVWF 0x11, BANKED
187:               ANSELA = 0x00;
13CFA  0E00     MOVLW 0x0
13CFC  6F00     MOVWF s, BANKED
188:               ANSELB = 0x00;
13CFE  0E00     MOVLW 0x0
13D00  6F08     MOVWF 0x8, BANKED
189:               ANSELC = 0x00;
13D02  0E00     MOVLW 0x0
13D04  6F10     MOVWF 0x10, BANKED
190:           #endif
191:           
192:               initOutputs();
13D06  ECD9     CALL 0x143B2, 0
13D08  F0A1     NOP
193:               initLeds();
13D0A  ECCF     CALL 0x15F9E, 0
13D0C  F0AF     NOP
194:               initInputs();
13D0E  EC95     CALL 0x1512A, 0
13D10  F0A8     NOP
195:               
196:               // Lock the PPS
197:           /*    PPSLOCK = 0x55; //Required sequence
198:               PPSLOCK = 0xAA; //Required sequence
199:               PPSLOCKbits.PPSLOCKED = 1; //Set PPSLOCKED bit
200:           */
201:               // enable interrupts, all init now done
202:               ei(); 
13D12  8ED6     BSF 0xFD6, 7, ACCESS
203:           
204:               startTime.val = tickGet();
13D14  ECD8     CALL 0x153B0, 0
13D16  F0A9     NOP
13D18  C502     MOVFF i, startTime
13D1A  F58C     NOP
13D1C  C503     MOVFF opc, 0x58D
13D1E  F58D     NOP
13D20  C504     MOVFF s, 0x58E
13D22  F58E     NOP
13D24  C505     MOVFF i, 0x58F
13D26  F58F     NOP
205:               lastServoStartTime.val = startTime.val;
13D28  C58C     MOVFF startTime, lastServoStartTime
13D2A  F588     NOP
13D2C  C58D     MOVFF 0x58D, 0x589
13D2E  F589     NOP
13D30  C58E     MOVFF 0x58E, 0x58A
13D32  F58A     NOP
13D34  C58F     MOVFF 0x58F, 0x58B
13D36  F58B     NOP
206:               lastInputScanTime.val = startTime.val;
13D38  C58C     MOVFF startTime, lastInputScanTime
13D3A  F584     NOP
13D3C  C58D     MOVFF 0x58D, 0x585
13D3E  F585     NOP
13D40  C58E     MOVFF 0x58E, 0x586
13D42  F586     NOP
13D44  C58F     MOVFF 0x58F, 0x587
13D46  F587     NOP
207:               lastActionPollTime.val = startTime.val;
13D48  C58C     MOVFF startTime, lastActionPollTime
13D4A  F665     NOP
13D4C  C58D     MOVFF 0x58D, 0x666
13D4E  F666     NOP
13D50  C58E     MOVFF 0x58E, 0x667
13D52  F667     NOP
13D54  C58F     MOVFF 0x58F, 0x668
13D56  F668     NOP
208:               flashTime.val = startTime.val;
13D58  C58C     MOVFF startTime, flashTime
13D5A  F580     NOP
13D5C  C58D     MOVFF 0x58D, 0x581
13D5E  F581     NOP
13D60  C58E     MOVFF 0x58E, 0x582
13D62  F582     NOP
13D64  C58F     MOVFF 0x58F, 0x583
13D66  F583     NOP
209:           
210:               started = FALSE;
13D68  0E00     MOVLW 0x0
13D6A  0105     MOVLB 0x5
13D6C  6FB5     MOVWF SCANPR, BANKED
211:               
212:               nv = (uint8_t)getNV(NV_STARTUP);
13D6E  0E01     MOVLW 0x1
13D70  ECB9     CALL 0x15B72, 0
13D72  F0AD     NOP
13D74  5002     MOVF ___rparam_used, W, ACCESS
13D76  6E21     MOVWF 0x21, ACCESS
213:               /* This is done with bit checks as that's what the original CANPAN code did */
214:               switch (nv) {
13D78  D00E     BRA 0x3D96
215:                   case NV_STARTUP_RESTORE:
216:                       loadInputs();
13D7A  EC30     CALL 0x15660, 0
13D7C  F0AB     NOP
217:                       break;
13D7E  0012     RETURN 0
218:                   case NV_STARTUP_NOTHING:
219:                       canpanScanReady = 1;
13D80  0E01     MOVLW 0x1
13D82  0105     MOVLB 0x5
13D84  6FB6     MOVWF DMA1PR, BANKED
220:                       break;
13D86  0012     RETURN 0
221:                   case NV_STARTUP_SCAN:
222:                       canpanScanReady = 0;
13D88  0E00     MOVLW 0x0
13D8A  0105     MOVLB 0x5
13D8C  6FB6     MOVWF DMA1PR, BANKED
223:                       break;
13D8E  0012     RETURN 0
224:                   case NV_STARTUP_ALLOFF:
225:                       canpanSetAllSwitchOff();
13D90  ECD6     CALL 0x15BAC, 0
13D92  F0AD     NOP
226:                       break;
13D94  0012     RETURN 0
227:               }
13D96  5021     MOVF 0x21, W, ACCESS
13D98  0A00     XORLW 0x0
13D9A  B4D8     BTFSC 0xFD8, 2, ACCESS
13D9C  D7EE     BRA 0x3D7A
13D9E  0A01     XORLW 0x1
13DA0  B4D8     BTFSC 0xFD8, 2, ACCESS
13DA2  D7EE     BRA 0x3D80
13DA4  0A03     XORLW 0x3
13DA6  B4D8     BTFSC 0xFD8, 2, ACCESS
13DA8  D7EF     BRA 0x3D88
13DAA  0A01     XORLW 0x1
13DAC  A4D8     BTFSS 0xFD8, 2, ACCESS
13DAC  A4D8     BTFSS 0xFD8, 2, ACCESS
13DAC  A4D8     BTFSS 0xFD8, 2, ACCESS
228:           }
229:           
230:           /**
231:            * The loop code call repeatedly from VLCB.
232:            */
233:           void loop(void) {
234:               // Startup delay for CBUS about 2 seconds to let other modules get powered up - ISR will be running so incoming packets processed
235:               if (!started && (tickTimeSince(startTime) >  TWO_SECOND)) {
13C0E  0105     MOVLB 0x5
13C10  51B5     MOVF SCANPR, W, BANKED
13C12  A4D8     BTFSS 0xFD8, 2, ACCESS
13C14  D01B     BRA 0x3C4C
13C16  ECD8     CALL 0x153B0, 0
13C18  F0A9     NOP
13C1A  0105     MOVLB 0x5
13C1C  518C     MOVF SPI1CLK, W, BANKED
13C1E  5C02     SUBWF ___rparam_used, W, ACCESS
13C20  6E3C     MOVWF 0x3C, ACCESS
13C22  518D     MOVF SPI2RXB, W, BANKED
13C24  5803     SUBWFB __activetblptr, W, ACCESS
13C26  6E3D     MOVWF 0x3D, ACCESS
13C28  518E     MOVF SPI2TXB, W, BANKED
13C2A  5804     SUBWFB __activetblptr, W, ACCESS
13C2C  6E3E     MOVWF 0x3E, ACCESS
13C2E  518F     MOVF SPI2TCNT, W, BANKED
13C30  5805     SUBWFB 0x5, W, ACCESS
13C32  6E3F     MOVWF 0x3F, ACCESS
13C34  503F     MOVF 0x3F, W, ACCESS
13C36  E108     BNZ 0x3C48
13C38  0E49     MOVLW 0x49
13C3A  5C3C     SUBWF 0x3C, W, ACCESS
13C3C  0EE8     MOVLW 0xE8
13C3E  583D     SUBWFB 0x3D, W, ACCESS
13C40  0E01     MOVLW 0x1
13C42  583E     SUBWFB 0x3E, W, ACCESS
13C44  A0D8     BTFSS 0xFD8, 0, ACCESS
13C46  D002     BRA 0x3C4C
236:                   started = TRUE;
13C48  0E01     MOVLW 0x1
13C4A  6FB5     MOVWF SCANPR, BANKED
237:                   // sendProducedEvent(HAPPENING_SOD, EVENT_ON);
238:               }
239:           
240:               if (started) {
13C4C  51B5     MOVF SCANPR, W, BANKED
13C4E  B4D8     BTFSC 0xFD8, 2, ACCESS
13C50  0012     RETURN 0
241:                   if (tickTimeSince(lastInputScanTime) > 2*ONE_MILI_SECOND) {
13C52  ECD8     CALL 0x153B0, 0
13C54  F0A9     NOP
13C56  0105     MOVLB 0x5
13C58  5184     MOVF SPI1CON0, W, BANKED
13C5A  5C02     SUBWF ___rparam_used, W, ACCESS
13C5C  6E3C     MOVWF 0x3C, ACCESS
13C5E  5185     MOVF SPI1CON1, W, BANKED
13C60  5803     SUBWFB __activetblptr, W, ACCESS
13C62  6E3D     MOVWF 0x3D, ACCESS
13C64  5186     MOVF SPI1CON2, W, BANKED
13C66  5804     SUBWFB __activetblptr, W, ACCESS
13C68  6E3E     MOVWF 0x3E, ACCESS
13C6A  5187     MOVF SPI1STATUS, W, BANKED
13C6C  5805     SUBWFB 0x5, W, ACCESS
13C6E  6E3F     MOVWF 0x3F, ACCESS
13C70  503F     MOVF 0x3F, W, ACCESS
13C72  103E     IORWF 0x3E, W, ACCESS
13C74  103D     IORWF 0x3D, W, ACCESS
13C76  E104     BNZ 0x3C80
13C78  0E7D     MOVLW 0x7D
13C7A  5C3C     SUBWF 0x3C, W, ACCESS
13C7C  A0D8     BTFSS 0xFD8, 0, ACCESS
13C7E  D00C     BRA 0x3C98
242:                       inputScan();    // Strobe inputs for changes
13C80  ECEB     CALL 0x125D6, 0
13C82  F092     NOP
243:                       lastInputScanTime.val = tickGet();
13C84  ECD8     CALL 0x153B0, 0
13C86  F0A9     NOP
13C88  C502     MOVFF i, lastInputScanTime
13C8A  F584     NOP
13C8C  C503     MOVFF opc, 0x585
13C8E  F585     NOP
13C90  C504     MOVFF s, 0x586
13C92  F586     NOP
13C94  C505     MOVFF i, 0x587
13C96  F587     NOP
244:                   }
245:                   
246:                   if (tickTimeSince(flashTime) > 2*HALF_SECOND) {
13C98  ECD8     CALL 0x153B0, 0
13C9A  F0A9     NOP
13C9C  0105     MOVLB 0x5
13C9E  5180     MOVF SPI1RXB, W, BANKED
13CA0  5C02     SUBWF ___rparam_used, W, ACCESS
13CA2  6E3C     MOVWF 0x3C, ACCESS
13CA4  5181     MOVF SPI1TXB, W, BANKED
13CA6  5803     SUBWFB __activetblptr, W, ACCESS
13CA8  6E3D     MOVWF 0x3D, ACCESS
13CAA  5182     MOVF SPI1TCNT, W, BANKED
13CAC  5804     SUBWFB __activetblptr, W, ACCESS
13CAE  6E3E     MOVWF 0x3E, ACCESS
13CB0  5183     MOVF SPI1TCNTH, W, BANKED
13CB2  5805     SUBWFB 0x5, W, ACCESS
13CB4  6E3F     MOVWF 0x3F, ACCESS
13CB6  503F     MOVF 0x3F, W, ACCESS
13CB8  103E     IORWF 0x3E, W, ACCESS
13CBA  E106     BNZ 0x3CC8
13CBC  0E25     MOVLW 0x25
13CBE  5C3C     SUBWF 0x3C, W, ACCESS
13CC0  0EF4     MOVLW 0xF4
13CC2  583D     SUBWFB 0x3D, W, ACCESS
13CC4  A0D8     BTFSS 0xFD8, 0, ACCESS
13CC6  0012     RETURN 0
247:                       doFlash();    // update flashing LEDs
13CC8  EC35     CALL 0x1466A, 0
13CCA  F0A3     NOP
248:                       flashTime.val = tickGet();
13CCC  ECD8     CALL 0x153B0, 0
13CCE  F0A9     NOP
13CD0  C502     MOVFF i, flashTime
13CD2  F580     NOP
13CD4  C503     MOVFF opc, 0x581
13CD6  F581     NOP
13CD8  C504     MOVFF s, 0x582
13CDA  F582     NOP
13CDC  C505     MOVFF i, 0x583
13CDE  F583     NOP
249:                   }
250:               }
251:           }
13CE0  0012     RETURN 0
252:           
253:           // Application functions required by MERGLCB library
254:           
255:           
256:           /**
257:            * Check to see if now is a good time to start a flash write.
258:            * It is a bad time if we are currently doing a servo pulse.
259:            * 
260:            * If a servo pulse timer is currently running then the NVM routine will keep 
261:            * calling this until the timer expires.
262:            * 
263:            * @return GOOD_TIME if OK else BAD_TIME
264:            */
265:           ValidTime APP_isSuitableTimeToWriteFlash(void){
266:               return GOOD_TIME;
1629E  0E01     MOVLW 0x1
267:           }
162A0  0012     RETURN 0
268:           
269:           /**
270:            * This application doesn't need to process any messages in a special way.
271:            */
272:           Processed APP_postProcessMessage(Message * m) {
273:               return NOT_PROCESSED;
1629A  0E00     MOVLW 0x0
274:           }
1629C  0012     RETURN 0
275:           
276:           /**
277:            * This is needed by the library to get the current event state. 
278:            *
279:           EventState APP_GetEventState(Happening h) {
280:               uint8_t flags;
281:               uint8_t happeningIndex;
282:               Boolean disable_off;
283:               
284:               
285:               // The TRIGGER_INVERTED has already been taken into account when saved in outputState. No need to check again
286:               return outputState[io]?EVENT_ON:EVENT_OFF;
287:           
288:           }*/
289:           
290:           
291:           #if defined(_18F66K80_FAMILY_)
292:           
293:           // APP Interrupt service routines
294:           void APP_lowIsr(void) {
295:               outputIsr();
296:           }
297:           
298:           // Interrupt service routines
299:           void APP_highIsr(void) {
300:           
301:           }
302:           #endif
---  C:/Users/ianwh/github/CANPAN2/canpan3Outputs.c  ----------------------------------------------------
1:             /*
2:               This work is licensed under the:
3:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
4:                To view a copy of this license, visit:
5:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
6:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
7:             
8:                License summary:
9:                 You are free to:
10:                  Share, copy and redistribute the material in any medium or format
11:                  Adapt, remix, transform, and build upon the material
12:            
13:                The licensor cannot revoke these freedoms as long as you follow the license terms.
14:            
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:            
19:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
20:            
21:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
22:                              your contributions under the same license as the original.
23:            
24:                No additional restrictions : You may not apply legal terms or technological measures that
25:                                              legally restrict others from doing anything the license permits.
26:            
27:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
28:            
29:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
30:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
31:             */
32:            /**
33:             *	The CANPAN program.
34:             *
35:             * @author Ian Hogg 
36:             * @date October 2024
37:             * 
38:             */ 
39:            #include <xc.h>
40:            #include "module.h"
41:            #include "canpan3Outputs.h"
42:            
43:            // RB4 - RB7 are used to drive the LED Anodes
44:            // MSSP SSI Master is used to provide 8 bits for cathodes
45:            
46:            static unsigned char current_row = 0;
47:            unsigned char ledMatrix[NUM_LED_ROWS];
48:            
49:            void initOutputs(void) {
50:                uint8_t i;
51:                
52:                for (i=0; i< NUM_LED_ROWS; i++) {
143B2  0E00     MOVLW 0x0
143B4  6E02     MOVWF ___rparam_used, ACCESS
53:                    ledMatrix[i] = 0;
143B6  0E7C     MOVLW 0x7C
143B8  2402     ADDWF ___rparam_used, W, ACCESS
143BA  6ED9     MOVWF 0xFD9, ACCESS
143BC  6ADA     CLRF 0xFDA, ACCESS
143BE  0E05     MOVLW 0x5
143C0  22DA     ADDWFC 0xFDA, F, ACCESS
143C2  6ADF     CLRF 0xFDF, ACCESS
54:                }
143C4  2A02     INCF ___rparam_used, F, ACCESS
143C6  0E03     MOVLW 0x3
143C8  6402     CPFSGT ___rparam_used, ACCESS
143CA  D7F5     BRA 0x43B6
55:                TRISCbits.TRISC6 = 0;   // anode driver output
143CC  9CC8     BCF 0xFC8, 6, ACCESS
56:                TRISCbits.TRISC7 = 0;   // anode driver output
143CE  9EC8     BCF 0xFC8, 7, ACCESS
57:                TRISBbits.TRISB4 = 0;   // anode driver output
143D0  98C7     BCF 0xFC7, 4, ACCESS
58:                TRISBbits.TRISB5 = 0;   // anode driver output
143D2  9AC7     BCF 0xFC7, 5, ACCESS
59:                
60:                LATBbits.LATB4 = 0;    // LED anode drivers off
143D4  98BF     BCF 0xFBF, 4, ACCESS
61:                LATBbits.LATB5 = 0;
143D6  9ABF     BCF 0xFBF, 5, ACCESS
62:                LATCbits.LATC6 = 0;
143D8  9CC0     BCF 0xFC0, 6, ACCESS
63:                LATCbits.LATC7 = 0;
143DA  9EC0     BCF 0xFC0, 7, ACCESS
64:                
65:                // Cathode driver output enable
66:                TRISCbits.TRISC2 = 0;
143DC  94C8     BCF 0xFC8, 2, ACCESS
67:                LATCbits.LATC2 = 0;     // disabled.
143DE  94C0     BCF 0xFC0, 2, ACCESS
68:                
69:                // latch
70:                TRISCbits.TRISC4 = 0;
143E0  98C8     BCF 0xFC8, 4, ACCESS
71:                LATCbits.LATC4 = 0;     // unlatch
143E2  98C0     BCF 0xFC0, 4, ACCESS
72:                
73:                //Set up the MSSP to drive the switch matrix
74:                TRISCbits.TRISC3 = 0;   //clock
143E4  96C8     BCF 0xFC8, 3, ACCESS
75:                LATCbits.LATC3 = 0;
143E6  96C0     BCF 0xFC0, 3, ACCESS
76:                TRISCbits.TRISC5 = 0;   // data
143E8  9AC8     BCF 0xFC8, 5, ACCESS
77:                LATCbits.LATC5 = 0;
143EA  9AC0     BCF 0xFC0, 5, ACCESS
78:                
79:                SPI1CON0 = 0x03; // MSb first, host mode, Total bit count Mode=1, transmit only
143EC  0E03     MOVLW 0x3
143EE  0100     MOVLB 0x0
143F0  6F84     MOVWF SPI1CON0, BANKED
80:                SPI1CON1 = 0x44; // clock edge, SSP=0 for active low and latches when it goes low
143F2  0E44     MOVLW 0x44
143F4  6F85     MOVWF SPI1CON1, BANKED
81:                SPI1CON2 = 0x02; // transmitter on, receiver off
143F6  0E02     MOVLW 0x2
143F8  6F86     MOVWF SPI1CON2, BANKED
82:                    
83:                SPI1TCNTH=0;     // 1 byte
143FA  0E00     MOVLW 0x0
143FC  6F83     MOVWF SPI1TCNTH, BANKED
84:                SPI1TCNTL=1;     // 1 byte
143FE  0E01     MOVLW 0x1
14400  6F82     MOVWF SPI1TCNT, BANKED
85:                SPI1TWIDTH=0;   // 8 bits
14402  0E00     MOVLW 0x0
14404  6F88     MOVWF SPI1TWIDTH, BANKED
86:            
87:                SPI1CLK = 0x00; // Clock from Fosc
14406  0E00     MOVLW 0x0
14408  6F8C     MOVWF SPI1CLK, BANKED
88:                SPI1BAUD = 15;  // Fosc/32
1440A  0E0F     MOVLW 0xF
1440C  6F89     MOVWF SPI1BAUD, BANKED
89:            
90:                // set up PPS to the correct pins
91:                RC5PPS = 0x32; // SPI1SDO
1440E  0E32     MOVLW 0x32
14410  0102     MOVLB 0x2
14412  6F16     MOVWF 0x16, BANKED
92:                RC3PPS = 0x31; // SPI1SCK
14414  0E31     MOVLW 0x31
14416  6F14     MOVWF 0x14, BANKED
93:                RC4PPS = 0x33; // SPI1SS, latch
14418  0E33     MOVLW 0x33
1441A  6F15     MOVWF 0x15, BANKED
94:            
95:                // ready
96:                SPI1CON0bits.EN = 1;
1441C  0100     MOVLB 0x0
1441E  8F84     BSF SPI1CON0, 7, BANKED
97:               
98:                // Set up TMR2 to generate interrupt every 2ms
99:                T2CONbits.CKPS = 5;     // clock prescalar 1:32
14420  0103     MOVLB 0x3
14422  5124     MOVF 0x24, W, BANKED
14424  0B8F     ANDLW 0x8F
14426  0950     IORLW 0x50
14428  6F24     MOVWF 0x24, BANKED
100:               T2CONbits.OUTPS = 0;    // clock postscalar 1:1
1442A  0EF0     MOVLW 0xF0
1442C  1724     ANDWF 0x24, F, BANKED
101:               T2CLKCON = 1;           // Fosc/4 clock source
1442E  0E01     MOVLW 0x1
14430  6F26     MOVWF 0x26, BANKED
102:               T2PR = 250;             // duration
14432  0EFA     MOVLW 0xFA
14434  6F23     MOVWF 0x23, BANKED
103:               T2HLTbits.MODE = 0;     // free run mode
14436  0EE0     MOVLW 0xE0
14438  1725     ANDWF 0x25, F, BANKED
104:               
105:               PIR3bits.TMR2IF = 0;    // no outstanding interrupt
1443A  96B1     BCF 0xFB1, 3, ACCESS
106:               PIE3bits.TMR2IE = 1;    // enable interrupts
1443C  86A1     BSF 0xFA1, 3, ACCESS
107:               T2CONbits.ON = 1;       // enable timer
1443E  8F24     BSF 0x24, 7, BANKED
108:           }
14440  0012     RETURN 0
109:           
110:           // Called every 2ms
111:           #if defined(_18F66K80_FAMILY_)
112:           void outputIsr(void) 
113:           #endif
114:           #if defined(_18FXXQ83_FAMILY_)
115:           void __interrupt(irq(IRQ_TMR2), base(IVT_BASE)) processOutputs(void) 
116:           #endif
117:           {
118:               uint8_t i;
119:               uint8_t cathodes;
120:               
121:               if (PIR3bits.TMR2IF) {
14D10  A6B1     BTFSS 0xFB1, 3, ACCESS
14D12  0011     RETFIE 1
122:                   current_row++;
14D14  0105     MOVLB 0x5
14D16  2BB2     INCF OSCSTAT, F, BANKED
123:                   current_row &= 0x3;
14D18  0E03     MOVLW 0x3
14D1A  17B2     ANDWF OSCSTAT, F, BANKED
124:                   
125:                   // disable the cathode driver
126:                   LATCbits.LATC2 = 1; // OE
14D1C  84C0     BSF 0xFC0, 2, ACCESS
127:                   // also turn the anodes off
128:                   LATBbits.LATB4 = 0;
14D1E  98BF     BCF 0xFBF, 4, ACCESS
129:                   LATBbits.LATB5 = 0;
14D20  9ABF     BCF 0xFBF, 5, ACCESS
130:                   LATCbits.LATC6 = 0;
14D22  9CC0     BCF 0xFC0, 6, ACCESS
131:                   LATCbits.LATC7 = 0;
14D24  9EC0     BCF 0xFC0, 7, ACCESS
132:           
133:                   cathodes = ledMatrix[current_row];
14D26  0E7C     MOVLW 0x7C
14D28  25B2     ADDWF OSCSTAT, W, BANKED
14D2A  6ED9     MOVWF 0xFD9, ACCESS
14D2C  6ADA     CLRF 0xFDA, ACCESS
14D2E  0E05     MOVLW 0x5
14D30  22DA     ADDWFC 0xFDA, F, ACCESS
14D32  50DF     MOVF 0xFDF, W, ACCESS
14D34  6E01     MOVWF ___rparam_used, ACCESS
134:                   SPI1TCNTH=0;     // 1 byte
14D36  0E00     MOVLW 0x0
14D38  0100     MOVLB 0x0
14D3A  6F83     MOVWF SPI1TCNTH, BANKED
135:                   SPI1TCNTL=1;     // 1 byte
14D3C  0E01     MOVLW 0x1
14D3E  6F82     MOVWF SPI1TCNT, BANKED
136:                   SPI1TWIDTH=0;   // 8 bits
14D40  0E00     MOVLW 0x0
14D42  6F88     MOVWF SPI1TWIDTH, BANKED
137:                   
138:                   SPI1TXB = cathodes; // do the write and send the data
14D44  C501     MOVFF __pcstackCOMRAM, SPI1TXB
14D46  F081     NOP
139:           
140:                   // wait for data to be sent and latched to form the anode outputs
141:                   // This takes quite a few cycles but we have to ensure the cathodes have the
142:                   // right data before turning on the anodes otherwise we don't get a clean display.
143:                   //while (SPI1CON2bits.BUSY)
144:                   //while (! SPI1INTFbits.SRMTIF)
145:                   //while (SPI1INTFbits.TCZIF)
146:                   while (! SPI1STATUSbits.TXBE)
147:                       ;
14D48  BB87     BTFSC SPI1STATUS, 5, BANKED
14D4A  D009     BRA 0x4D5E
14D4C  D7FD     BRA 0x4D48
148:                   
149:                   // It can take up to 365ns for the TLC5917 outputs to output correct data (LE to OUT)
150:                   // This is 5 instruction cycles (5 * 62.5 ns)
151:                   // following code before enabling the cathodes is more than 5 instructions
152:           
153:                   // turn the relevant anode driver on
154:                   switch (current_row) {
155:                       case 0:
156:                           LATBbits.LATB4 = 1;
14D4E  88BF     BSF 0xFBF, 4, ACCESS
157:                           break;
14D50  D014     BRA 0x4D7A
158:                       case 1:
159:                           LATBbits.LATB5 = 1;
14D52  8ABF     BSF 0xFBF, 5, ACCESS
160:                           break;
14D54  D012     BRA 0x4D7A
161:                       case 2:
162:                           LATCbits.LATC6 = 1;
14D56  8CC0     BSF 0xFC0, 6, ACCESS
163:                           break;
14D58  D010     BRA 0x4D7A
164:                       case 3:
165:                           LATCbits.LATC7 = 1;
14D5A  8EC0     BSF 0xFC0, 7, ACCESS
166:                           break;
14D5C  D00E     BRA 0x4D7A
167:                   }
14D5E  0105     MOVLB 0x5
14D60  51B2     MOVF OSCSTAT, W, BANKED
14D62  0A00     XORLW 0x0
14D64  B4D8     BTFSC 0xFD8, 2, ACCESS
14D66  D7F3     BRA 0x4D4E
14D68  0A01     XORLW 0x1
14D6A  B4D8     BTFSC 0xFD8, 2, ACCESS
14D6C  D7F2     BRA 0x4D52
14D6E  0A03     XORLW 0x3
14D70  B4D8     BTFSC 0xFD8, 2, ACCESS
14D72  D7F1     BRA 0x4D56
14D74  0A01     XORLW 0x1
14D76  B4D8     BTFSC 0xFD8, 2, ACCESS
14D78  D7F0     BRA 0x4D5A
168:                   
169:                   // enable the cathode driver
170:                   LATCbits.LATC2 = 0; //OE 
14D7A  94C0     BCF 0xFC0, 2, ACCESS
171:                   // clear the timer interrupt flag ready for next timer expiry
172:                   PIR3bits.TMR2IF = 0;
14D7C  96B1     BCF 0xFB1, 3, ACCESS
173:               }
174:           }
14D7E  0011     RETFIE 1
16100  0101     MOVLB 0x1
16102  A778     BTFSS WDTCON0, 3, BANKED
16104  D005     BRA 0x6110
175:           
176:           
177:           
178:           /**
179:            * Turn on an LED. No is 0-31.
180:            * @param no
181:            */
182:           void setLed(uint8_t no) {
15A48  6E0C     MOVWF 0xC, ACCESS
183:               ledMatrix[no/8] |= (1 << (no%8));
15A4A  C50C     MOVFF txWaiting, index
15A4C  F50A     NOP
15A4E  0E07     MOVLW 0x7
15A50  160A     ANDWF 0xA, F, ACCESS
15A52  0E01     MOVLW 0x1
15A54  6E0B     MOVWF 0xB, ACCESS
15A56  2A0A     INCF 0xA, F, ACCESS
15A58  D002     BRA 0x5A5E
15A5A  90D8     BCF 0xFD8, 0, ACCESS
15A5C  360B     RLCF 0xB, F, ACCESS
15A5E  2E0A     DECFSZ 0xA, F, ACCESS
15A60  D7FC     BRA 0x5A5A
15A62  C50C     MOVFF txWaiting, i
15A64  F502     NOP
15A66  6A03     CLRF __activetblptr, ACCESS
15A68  0E00     MOVLW 0x0
15A6A  6E05     MOVWF 0x5, ACCESS
15A6C  0E08     MOVLW 0x8
15A6E  6E04     MOVWF __activetblptr, ACCESS
15A70  EC77     CALL 0x146EE, 0
15A72  F0A3     NOP
15A74  0E7C     MOVLW 0x7C
15A76  2402     ADDWF ___rparam_used, W, ACCESS
15A78  6ED9     MOVWF 0xFD9, ACCESS
15A7A  0E05     MOVLW 0x5
15A7C  2003     ADDWFC __activetblptr, W, ACCESS
15A7E  6EDA     MOVWF 0xFDA, ACCESS
15A80  500B     MOVF 0xB, W, ACCESS
15A82  12DF     IORWF 0xFDF, F, ACCESS
184:           }
15A84  0012     RETURN 0
185:           
186:           /**
187:            * Turn an LED off. No is 0-31
188:            */
189:           void clearLed(uint8_t no) {
1593E  6E0D     MOVWF 0xD, ACCESS
190:               ledMatrix[no/8] &= ~(1 << (no%8));
15940  C50D     MOVFF i, index
15942  F50A     NOP
15944  0E07     MOVLW 0x7
15946  160A     ANDWF 0xA, F, ACCESS
15948  0E01     MOVLW 0x1
1594A  6E0B     MOVWF 0xB, ACCESS
1594C  2A0A     INCF 0xA, F, ACCESS
1594E  D002     BRA 0x5954
15950  90D8     BCF 0xFD8, 0, ACCESS
15952  360B     RLCF 0xB, F, ACCESS
15954  2E0A     DECFSZ 0xA, F, ACCESS
15956  D7FC     BRA 0x5950
15958  500B     MOVF 0xB, W, ACCESS
1595A  0AFF     XORLW 0xFF
1595C  6E0C     MOVWF 0xC, ACCESS
1595E  C50D     MOVFF i, i
15960  F502     NOP
15962  6A03     CLRF __activetblptr, ACCESS
15964  0E00     MOVLW 0x0
15966  6E05     MOVWF 0x5, ACCESS
15968  0E08     MOVLW 0x8
1596A  6E04     MOVWF __activetblptr, ACCESS
1596C  EC77     CALL 0x146EE, 0
1596E  F0A3     NOP
15970  0E7C     MOVLW 0x7C
15972  2402     ADDWF ___rparam_used, W, ACCESS
15974  6ED9     MOVWF 0xFD9, ACCESS
15976  0E05     MOVLW 0x5
15978  2003     ADDWFC __activetblptr, W, ACCESS
1597A  6EDA     MOVWF 0xFDA, ACCESS
1597C  500C     MOVF 0xC, W, ACCESS
1597E  16DF     ANDWF 0xFDF, F, ACCESS
191:           }
15980  0012     RETURN 0
192:           
193:           /**
194:            * Test if an LED is on.
195:            * @param no
196:            * @return 0 if OFF or non zero if ON
197:            */
198:           uint8_t testLed(uint8_t no) {
199:               return ledMatrix[no/8] & (1 << (no%8));
200:           }
201:           
---  C:/Users/ianwh/github/CANPAN2/canpan3Nv.c  ---------------------------------------------------------
1:             /*
2:               This work is licensed under the:
3:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
4:                To view a copy of this license, visit:
5:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
6:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
7:             
8:                License summary:
9:                 You are free to:
10:                  Share, copy and redistribute the material in any medium or format
11:                  Adapt, remix, transform, and build upon the material
12:            
13:                The licensor cannot revoke these freedoms as long as you follow the license terms.
14:            
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:            
19:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
20:            
21:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
22:                              your contributions under the same license as the original.
23:            
24:                No additional restrictions : You may not apply legal terms or technological measures that
25:                                              legally restrict others from doing anything the license permits.
26:            
27:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
28:            
29:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
30:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
31:             */
32:            /**
33:             *	The CANPAN program.
34:             *
35:             * @author Ian Hogg 
36:             * @date October 2024
37:             * 
38:             */ 
39:            
40:            #include <xc.h>
41:            #include "module.h"
42:            #include "canpan3Nv.h"
43:            #include "nv.h"
44:                    
45:            /**
46:             * The Application specific NV defaults are defined here.
47:             */
48:            uint8_t APP_nvDefault(uint8_t index) {
16218  6E02     MOVWF ___rparam_used, ACCESS
49:                if (index < NV_NUM) {
1621A  5002     MOVF ___rparam_used, W, ACCESS
1621C  B4D8     BTFSC 0xFD8, 2, ACCESS
1621E  D002     BRA 0x6224
50:                    // Global NVs
51:                    switch(index) {
52:                        case NV_STARTUP:
53:                            return NV_STARTUP_RESTORE;
16220  0E00     MOVLW 0x0
16222  0012     RETURN 0
54:                    }
16224  5002     MOVF ___rparam_used, W, ACCESS
16224  5002     MOVF ___rparam_used, W, ACCESS
16224  5002     MOVF ___rparam_used, W, ACCESS
55:                }
56:                return 0;
57:            }
58:            
59:            /**
60:             * We validate NV values here.
61:             * We currently only validate the TYPE.
62:             */
63:            NvValidation APP_nvValidate(uint8_t index, uint8_t value)  {
64:                if (value > 3) {
1622A  0E03     MOVLW 0x3
1622C  6402     CPFSGT ___rparam_used, ACCESS
1622E  D002     BRA 0x6234
65:                    return INVALID;
16230  0E00     MOVLW 0x0
16232  0012     RETURN 0
66:                }
67:                return VALID;
16234  0E01     MOVLW 0x1
68:            }
16236  0012     RETURN 0
69:            
70:            /**
71:             * We perform the necessary action when an NV changes value.
72:             */
73:            void APP_nvValueChanged(uint8_t index, uint8_t value, uint8_t oldValue) {
74:            }
162A4  0012     RETURN 0
---  C:/Users/ianwh/github/CANPAN2/canpan3Leds.c  -------------------------------------------------------
1:             /*
2:               This work is licensed under the:
3:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
4:                To view a copy of this license, visit:
5:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
6:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
7:             
8:                License summary:
9:                 You are free to:
10:                  Share, copy and redistribute the material in any medium or format
11:                  Adapt, remix, transform, and build upon the material
12:            
13:                The licensor cannot revoke these freedoms as long as you follow the license terms.
14:            
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:            
19:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
20:            
21:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
22:                              your contributions under the same license as the original.
23:            
24:                No additional restrictions : You may not apply legal terms or technological measures that
25:                                              legally restrict others from doing anything the license permits.
26:            
27:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
28:            
29:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
30:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
31:             */
32:            /**
33:             *	The CANPAN program.
34:             *
35:             * @author Ian Hogg 
36:             * @date October 2024
37:             * 
38:             */ 
39:            
40:            #include <xc.h>
41:            #include "module.h"
42:            #include "canpan3Leds.h"
43:            #include "canpan3Outputs.h"
44:            
45:            static enum canpan3LedState ledStates[NUM_LEDS];
46:            static uint8_t flashToggle;
47:            
48:            /**
49:             * Initialise the LEDs.
50:             */
51:            void initLeds(void) {
52:                uint8_t i;
53:                
54:                for (i=0; i<NUM_LEDS; i++) {
15F9E  0E00     MOVLW 0x0
15FA0  6E02     MOVWF ___rparam_used, ACCESS
55:                    ledStates[i] = CANPANLED_OFF;
15FA2  0E00     MOVLW 0x0
15FA4  2402     ADDWF ___rparam_used, W, ACCESS
15FA6  6ED9     MOVWF 0xFD9, ACCESS
15FA8  6ADA     CLRF 0xFDA, ACCESS
15FAA  0E06     MOVLW 0x6
15FAC  22DA     ADDWFC 0xFDA, F, ACCESS
15FAE  0E01     MOVLW 0x1
15FB0  6EDF     MOVWF 0xFDF, ACCESS
56:                }
15FB2  2A02     INCF ___rparam_used, F, ACCESS
15FB4  0E1F     MOVLW 0x1F
15FB6  6402     CPFSGT ___rparam_used, ACCESS
15FB8  D7F4     BRA 0x5FA2
57:                flashToggle = 0;
15FBA  0E00     MOVLW 0x0
15FBC  0105     MOVLB 0x5
15FBE  6F9D     MOVWF 0x9D, BANKED
58:            }
15FC0  0012     RETURN 0
59:            
60:            /**
61:             * Set the specified LED to the given state.
62:             * @param led
63:             * @param state
64:             */
65:            void setLedState(uint8_t ledNo, enum canpan3LedState state) {
15512  6E11     MOVWF 0x11, ACCESS
66:                ledStates[ledNo] = state;
15514  0E00     MOVLW 0x0
15516  2411     ADDWF 0x11, W, ACCESS
15518  6ED9     MOVWF 0xFD9, ACCESS
1551A  6ADA     CLRF 0xFDA, ACCESS
1551C  0E06     MOVLW 0x6
1551E  22DA     ADDWFC 0xFDA, F, ACCESS
15520  C50E     MOVFF evNum, INDF2
15522  F4DF     NOP
67:                switch (ledStates[ledNo]) {
15524  D008     BRA 0x5536
68:                    case CANPANLED_ON:
69:                        setLed(ledNo);
15526  5011     MOVF 0x11, W, ACCESS
15528  EC24     CALL 0x15A48, 0
1552A  F0AD     NOP
70:                        break;
1552C  0012     RETURN 0
71:                    case CANPANLED_OFF:
72:                        clearLed(ledNo);
1552E  5011     MOVF 0x11, W, ACCESS
15530  EC9F     CALL 0x1593E, 0
15532  F0AC     NOP
73:                        break;
15534  0012     RETURN 0
74:                    case CANPANLED_FLASH:
75:                    case CANPANLED_ANTIFLASH:
76:                        // flashing states get dealt with by the doFlash function
77:                        break;
78:                }
15536  0E00     MOVLW 0x0
15538  2411     ADDWF 0x11, W, ACCESS
1553A  6ED9     MOVWF 0xFD9, ACCESS
1553C  6ADA     CLRF 0xFDA, ACCESS
1553E  0E06     MOVLW 0x6
15540  22DA     ADDWFC 0xFDA, F, ACCESS
15542  50DF     MOVF 0xFDF, W, ACCESS
15544  6E0F     MOVWF 0xF, ACCESS
15546  6A10     CLRF 0x10, ACCESS
15548  5010     MOVF 0x10, W, ACCESS
1554A  0A00     XORLW 0x0
1554C  A4D8     BTFSS 0xFD8, 2, ACCESS
1554E  0012     RETURN 0
15550  500F     MOVF 0xF, W, ACCESS
15552  0A00     XORLW 0x0
15554  B4D8     BTFSC 0xFD8, 2, ACCESS
15556  D7E7     BRA 0x5526
15558  0A01     XORLW 0x1
1555A  B4D8     BTFSC 0xFD8, 2, ACCESS
1555C  D7E8     BRA 0x552E
1555E  0A03     XORLW 0x3
15560  B4D8     BTFSC 0xFD8, 2, ACCESS
15560  B4D8     BTFSC 0xFD8, 2, ACCESS
15560  B4D8     BTFSC 0xFD8, 2, ACCESS
15560  B4D8     BTFSC 0xFD8, 2, ACCESS
79:                
80:            }
81:            
82:            /**
83:             * Call regularly at required flash rate.
84:             */
85:            void doFlash(void) {
86:                uint8_t ledNo;
87:                
88:                for (ledNo=0; ledNo<NUM_LEDS; ledNo++) {
1466A  0E00     MOVLW 0x0
1466C  6E10     MOVWF 0x10, ACCESS
1466E  D018     BRA 0x46A0
89:                    switch (ledStates[ledNo]) {
90:                        case CANPANLED_FLASH:
91:                            if (flashToggle) {
14670  0105     MOVLB 0x5
14672  519D     MOVF 0x9D, W, BANKED
14674  B4D8     BTFSC 0xFD8, 2, ACCESS
14676  D004     BRA 0x4680
92:                                setLed(ledNo);
14678  5010     MOVF 0x10, W, ACCESS
1467A  EC24     CALL 0x15A48, 0
1467C  F0AD     NOP
93:                            } else {
1467E  D02A     BRA 0x46D4
94:                                clearLed(ledNo);
14680  5010     MOVF 0x10, W, ACCESS
14682  EC9F     CALL 0x1593E, 0
14684  F0AC     NOP
14686  D026     BRA 0x46D4
95:                            }
96:                            break;
97:                        case CANPANLED_ANTIFLASH:
98:                            if (flashToggle) {
14688  0105     MOVLB 0x5
1468A  519D     MOVF 0x9D, W, BANKED
1468C  B4D8     BTFSC 0xFD8, 2, ACCESS
1468E  D004     BRA 0x4698
99:                                clearLed(ledNo);
14690  5010     MOVF 0x10, W, ACCESS
14692  EC9F     CALL 0x1593E, 0
14694  F0AC     NOP
100:                           } else {
14696  D01E     BRA 0x46D4
101:                               setLed(ledNo);
14698  5010     MOVF 0x10, W, ACCESS
1469A  EC24     CALL 0x15A48, 0
1469C  F0AD     NOP
1469E  D01A     BRA 0x46D4
102:                           }
103:                           break;
104:                       case CANPANLED_ON:
105:                       case CANPANLED_OFF:
106:                           // these have already been handled in the setter above
107:                           break;
108:                   }
146A0  0E00     MOVLW 0x0
146A2  2410     ADDWF 0x10, W, ACCESS
146A4  6ED9     MOVWF 0xFD9, ACCESS
146A6  6ADA     CLRF 0xFDA, ACCESS
146A8  0E06     MOVLW 0x6
146AA  22DA     ADDWFC 0xFDA, F, ACCESS
146AC  50DF     MOVF 0xFDF, W, ACCESS
146AE  6E0E     MOVWF 0xE, ACCESS
146B0  6A0F     CLRF 0xF, ACCESS
146B2  500F     MOVF 0xF, W, ACCESS
146B4  0A00     XORLW 0x0
146B6  A4D8     BTFSS 0xFD8, 2, ACCESS
146B8  D00D     BRA 0x46D4
146BA  500E     MOVF 0xE, W, ACCESS
146BC  0A00     XORLW 0x0
146BE  B4D8     BTFSC 0xFD8, 2, ACCESS
146C0  D009     BRA 0x46D4
146C2  0A01     XORLW 0x1
146C4  B4D8     BTFSC 0xFD8, 2, ACCESS
146C6  D006     BRA 0x46D4
146C8  0A03     XORLW 0x3
146CA  B4D8     BTFSC 0xFD8, 2, ACCESS
146CC  D7D1     BRA 0x4670
146CE  0A01     XORLW 0x1
146D0  B4D8     BTFSC 0xFD8, 2, ACCESS
146D2  D7DA     BRA 0x4688
109:               }
146D4  2A10     INCF 0x10, F, ACCESS
146D6  0E1F     MOVLW 0x1F
146D8  6410     CPFSGT 0x10, ACCESS
146DA  D7E2     BRA 0x46A0
110:               flashToggle = !flashToggle;
146DC  0105     MOVLB 0x5
146DE  519D     MOVF 0x9D, W, BANKED
146E0  A4D8     BTFSS 0xFD8, 2, ACCESS
146E2  D002     BRA 0x46E8
146E4  0E01     MOVLW 0x1
146E6  D001     BRA 0x46EA
146E8  0E00     MOVLW 0x0
146EA  6F9D     MOVWF 0x9D, BANKED
111:           }
146EC  0012     RETURN 0
---  C:/Users/ianwh/github/CANPAN2/canpan3Inputs.c  -----------------------------------------------------
1:             /*
2:               This work is licensed under the:
3:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
4:                To view a copy of this license, visit:
5:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
6:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
7:             
8:                License summary:
9:                 You are free to:
10:                  Share, copy and redistribute the material in any medium or format
11:                  Adapt, remix, transform, and build upon the material
12:            
13:                The licensor cannot revoke these freedoms as long as you follow the license terms.
14:            
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:            
19:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
20:            
21:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
22:                              your contributions under the same license as the original.
23:            
24:                No additional restrictions : You may not apply legal terms or technological measures that
25:                                              legally restrict others from doing anything the license permits.
26:            
27:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
28:            
29:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
30:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
31:             */
32:            /**
33:             *	The CANPAN program.
34:             *
35:             * @author Ian Hogg 
36:             * @date October 2024
37:             * 
38:             */ 
39:            #include <xc.h>
40:            #include "module.h"
41:            #include "mns.h"
42:            #include "event_teach.h"
43:            #include "timedResponse.h"
44:            #include "event_producer.h"
45:            #include "nvm.h"
46:            #include "canpan3Events.h"
47:            
48:            static uint8_t buttonState[NUM_BUTTON_COLUMNS];
49:            uint8_t outputState[NUM_BUTTONS];
50:            
51:            #define EE_ADDR_SWITCHES    0x0000
52:            
53:            static uint8_t column;  // Column number
54:            uint8_t canpanScanReady;   /// indicates if the code has had chance to read all the buttons
55:            
56:            #define MODE_UNKNOWN    0
57:            #define MODE_ON_OFF     1
58:            #define MODE_ONOFF_ONLY 2
59:            #define MODE_TOGGLE     3
60:            
61:            // forward declarations
62:            void driveColumn(void);
63:            uint8_t findEventForSwitch(uint8_t buttonNo);
64:            TimedResponseResult sodTRCallback(uint8_t type, uint8_t serviceIndex, uint8_t step);
65:            void canpanSendProducedEvent(uint8_t tableIndex, uint8_t onOff, uint8_t sv);
66:            EventState getSwitchEventState(uint8_t switchNo);
67:            
68:            /**
69:             * Initialise the input (buttons) circuitry.
70:             */
71:            void initInputs(void) {
72:                uint8_t i;
73:                canpanScanReady = 0;
1512A  0E00     MOVLW 0x0
1512C  0105     MOVLB 0x5
1512E  6FB6     MOVWF DMA1PR, BANKED
74:                // Column drivers
75:                TRISAbits.TRISA0=0;
15130  90C6     BCF 0xFC6, 0, ACCESS
76:                TRISAbits.TRISA1=0;
15132  92C6     BCF 0xFC6, 1, ACCESS
77:                TRISAbits.TRISA2=0;
15134  94C6     BCF 0xFC6, 2, ACCESS
78:                // Row inputs
79:                TRISBbits.TRISB0=1;
15136  80C7     BSF 0xFC7, 0, ACCESS
80:                TRISBbits.TRISB1=1;
15138  82C7     BSF 0xFC7, 1, ACCESS
81:                TRISCbits.TRISC0=1;
1513A  80C8     BSF 0xFC8, 0, ACCESS
82:                TRISCbits.TRISC1=1;
1513C  82C8     BSF 0xFC8, 1, ACCESS
83:                
84:            #if defined(_18F66K80_FAMILY_)
85:                INTCON2.RPBU = 0x0; // enable pull-ups
86:                WPUB = 0xFF;
87:            #endif
88:            #if defined(_18FXXQ83_FAMILY_)
89:                WPUB = 0b00000011;    // enable pull-ups
1513E  0E03     MOVLW 0x3
15140  0104     MOVLB 0x4
15142  6F09     MOVWF 0x9, BANKED
90:                WPUC = 0b00000011;
15144  0E03     MOVLW 0x3
15146  6F11     MOVWF 0x11, BANKED
91:            #endif
92:                // start the column outputs
93:                column = 0;
15148  0E00     MOVLW 0x0
1514A  0105     MOVLB 0x5
1514C  6FB3     MOVWF OSCEN, BANKED
94:                driveColumn();
1514E  EC08     CALL 0x15610, 0
15150  F0AB     NOP
95:                for (i=0; i<NUM_BUTTONS; i++) {
15152  0E00     MOVLW 0x0
15154  6E03     MOVWF __activetblptr, ACCESS
96:                    outputState[i] = 0;     // default 0 but maybe loaded from EEPROM later
15156  0E20     MOVLW 0x20
15158  2403     ADDWF __activetblptr, W, ACCESS
1515A  6ED9     MOVWF 0xFD9, ACCESS
1515C  6ADA     CLRF 0xFDA, ACCESS
1515E  0E06     MOVLW 0x6
15160  22DA     ADDWFC 0xFDA, F, ACCESS
15162  6ADF     CLRF 0xFDF, ACCESS
97:                }
15164  2A03     INCF __activetblptr, F, ACCESS
15166  0E1F     MOVLW 0x1F
15168  6403     CPFSGT __activetblptr, ACCESS
1516A  D7F5     BRA 0x5156
98:                for (i=0; i<NUM_BUTTON_COLUMNS; i++) {
1516C  0E00     MOVLW 0x0
1516E  6E03     MOVWF __activetblptr, ACCESS
99:                    buttonState[i] = 0;
15170  0E5D     MOVLW 0x5D
15172  2403     ADDWF __activetblptr, W, ACCESS
15174  6ED9     MOVWF 0xFD9, ACCESS
15176  6ADA     CLRF 0xFDA, ACCESS
15178  0E06     MOVLW 0x6
1517A  22DA     ADDWFC 0xFDA, F, ACCESS
1517C  6ADF     CLRF 0xFDF, ACCESS
100:               }
1517E  2A03     INCF __activetblptr, F, ACCESS
1517E  2A03     INCF __activetblptr, F, ACCESS
1517E  2A03     INCF __activetblptr, F, ACCESS
1517E  2A03     INCF __activetblptr, F, ACCESS
1517E  2A03     INCF __activetblptr, F, ACCESS
101:           }
102:           
103:           /**
104:            * Scan the input buttons. Gets called every 2ms from the main loop. Each scan handles 1 row of 4 switches.
105:            * 8 scans are needed for a scan of all buttons taking 16ms.
106:            * For switches/buttons EV#1 must be set to 1. EV#2 is switch number. EV#3 is the switch mode
107:            */
108:           void inputScan(void) {
109:               uint8_t row;
110:               uint8_t i;
111:               uint8_t diff;
112:               uint8_t tableIndex;
113:               uint8_t sv;
114:               uint8_t mode;
115:               uint8_t onOff;
116:               uint8_t buttonNo;
117:               Word producedEventNN;
118:               Word producedEventEN;
119:               uint8_t opc;
120:           
121:               
122:               // read the row
123:               row = (uint8_t)((PORTC & 0x03) << 2);
125D6  C4D0     MOVFF PORTC, needed
125D8  F532     NOP
125DA  0E03     MOVLW 0x3
125DC  1632     ANDWF 0x32, F, ACCESS
125DE  90D8     BCF 0xFD8, 0, ACCESS
125E0  3632     RLCF 0x32, F, ACCESS
125E2  90D8     BCF 0xFD8, 0, ACCESS
125E4  3432     RLCF 0x32, W, ACCESS
125E6  6E37     MOVWF 0x37, ACCESS
124:               row |= (PORTB & 0x03);  // get the row value
125E8  50CF     MOVF 0xFCF, W, ACCESS
125EA  0B03     ANDLW 0x3
125EC  1237     IORWF 0x37, F, ACCESS
125:               diff = row ^ buttonState[column];   // has the row changed since last read?
125EE  0E5D     MOVLW 0x5D
125F0  0105     MOVLB 0x5
125F2  25B3     ADDWF OSCEN, W, BANKED
125F4  6ED9     MOVWF 0xFD9, ACCESS
125F6  6ADA     CLRF 0xFDA, ACCESS
125F8  0E06     MOVLW 0x6
125FA  22DA     ADDWFC 0xFDA, F, ACCESS
125FC  50DF     MOVF 0xFDF, W, ACCESS
125FE  1837     XORWF 0x37, W, ACCESS
12600  6E34     MOVWF 0x34, ACCESS
126:               
127:               // work out what has changed since last read.
128:               // Go through the bits of the row
129:               for (i=0; i<NUM_BUTTON_ROWS; i++) {
12602  0E00     MOVLW 0x0
12604  6E38     MOVWF BOOTREG, ACCESS
130:                   if (diff & (1 << i)) {
12606  C538     MOVFF nodeNumber, needed
12608  F532     NOP
1260A  0E01     MOVLW 0x1
1260C  6E33     MOVWF 0x33, ACCESS
1260E  2A32     INCF 0x32, F, ACCESS
12610  D002     BRA 0x2616
12612  90D8     BCF 0xFD8, 0, ACCESS
12614  3633     RLCF 0x33, F, ACCESS
12616  2E32     DECFSZ 0x32, F, ACCESS
12618  D7FC     BRA 0x2612
1261A  5033     MOVF 0x33, W, ACCESS
1261C  1434     ANDWF 0x34, W, ACCESS
1261E  0900     IORLW 0x0
12620  B4D8     BTFSC 0xFD8, 2, ACCESS
12622  D0A8     BRA 0x2774
131:                       // has this particular switch changed?
132:                       onOff = !!(row & (1 << i));
12624  C538     MOVFF nodeNumber, needed
12626  F532     NOP
12628  0E01     MOVLW 0x1
1262A  6E33     MOVWF 0x33, ACCESS
1262C  2A32     INCF 0x32, F, ACCESS
1262E  D002     BRA 0x2634
12630  90D8     BCF 0xFD8, 0, ACCESS
12632  3633     RLCF 0x33, F, ACCESS
12634  2E32     DECFSZ 0x32, F, ACCESS
12636  D7FC     BRA 0x2630
12638  5033     MOVF 0x33, W, ACCESS
1263A  1437     ANDWF 0x37, W, ACCESS
1263C  0900     IORLW 0x0
1263E  B4D8     BTFSC 0xFD8, 2, ACCESS
12640  D002     BRA 0x2646
12642  0E01     MOVLW 0x1
12644  D001     BRA 0x2648
12646  0E00     MOVLW 0x0
12648  6E3A     MOVWF CLKRCLK, ACCESS
133:                       buttonNo = column*NUM_BUTTON_ROWS + i;
1264A  0105     MOVLB 0x5
1264C  51B3     MOVF OSCEN, W, BANKED
1264E  0D04     MULLW 0x4
12650  50F3     MOVF 0xFF3, W, ACCESS
12652  2438     ADDWF BOOTREG, W, ACCESS
12654  6E3B     MOVWF 0x3B, ACCESS
134:                       if (mode_flags & FLAG_MODE_LEARN) {
12656  A1B4     BTFSS PRLOCK, 0, BANKED
12658  D00E     BRA 0x2676
135:                           // when in teach mode we actually send a ARON1 instead of the event
136:                           sendMessage5(OPC_ARON1, nn.bytes.hi, nn.bytes.lo, 0, 0, buttonNo+1);
1265A  C554     MOVFF 0x554, data1
1265C  F525     NOP
1265E  C553     MOVFF nn, data2
12660  F526     NOP
12662  0E00     MOVLW 0x0
12664  6E27     MOVWF 0x27, ACCESS
12666  0E00     MOVLW 0x0
12668  6E28     MOVWF 0x28, ACCESS
1266A  283B     INCF 0x3B, W, ACCESS
1266C  6E29     MOVWF 0x29, ACCESS
1266E  0EB3     MOVLW 0xB3
12670  EC7D     CALL 0x15EFA, 0
12672  F0AF     NOP
137:                       } else {
12674  D07F     BRA 0x2774
138:                           tableIndex = findEventForSwitch(buttonNo);
12676  503B     MOVF 0x3B, W, ACCESS
12678  EC57     CALL 0x156AE, 0
1267A  F0AB     NOP
1267C  6E35     MOVWF 0x35, ACCESS
139:                           if (tableIndex != NO_INDEX) {
1267E  2835     INCF 0x35, W, ACCESS
12680  B4D8     BTFSC 0xFD8, 2, ACCESS
12682  D078     BRA 0x2774
140:                               sv = evs[EV_SWITCHSV];
12684  C652     MOVFF 0x652, nEv
12686  F539     NOP
141:                               // determine the switch mode using the SV event variable
142:                               mode = MODE_ON_OFF;
12688  0E01     MOVLW 0x1
1268A  6E36     MOVWF 0x36, ACCESS
143:                               if (sv & SV_ON_OFF) {
1268C  A039     BTFSS CLKRCON, 0, ACCESS
1268E  D002     BRA 0x2694
144:                                   mode = MODE_ON_OFF;
12690  0E01     MOVLW 0x1
12692  D007     BRA 0x26A2
145:                               } else if (sv & SV_ON_ONLY) {
12694  A439     BTFSS CLKRCON, 2, ACCESS
12696  D002     BRA 0x269C
146:                                   mode = MODE_ONOFF_ONLY;
12698  0E02     MOVLW 0x2
1269A  D003     BRA 0x26A2
147:                               } else if (sv & SV_TOGGLE) {
1269C  A639     BTFSS CLKRCON, 3, ACCESS
1269E  D002     BRA 0x26A4
148:                                   mode = MODE_TOGGLE;
126A0  0E03     MOVLW 0x3
126A2  6E36     MOVWF 0x36, ACCESS
149:                               }
150:                               // When in learn mode we'll act as if it is ON/OFF mode to send an ARON1
151:                               if (mode_flags & FLAG_MODE_LEARN) {
126A4  0105     MOVLB 0x5
126A6  A1B4     BTFSS PRLOCK, 0, BANKED
126A8  D002     BRA 0x26AE
152:                                   mode = MODE_ON_OFF;
126AA  0E01     MOVLW 0x1
126AC  6E36     MOVWF 0x36, ACCESS
153:                               }
154:                               if (mode != MODE_UNKNOWN){
126AE  5036     MOVF 0x36, W, ACCESS
126B0  A4D8     BTFSS 0xFD8, 2, ACCESS
126B2  D03C     BRA 0x272C
126B4  D05F     BRA 0x2774
155:           
156:                                   switch(mode) {
157:                                       case MODE_ON_OFF:
158:                                           if (sv & SV_POLARITY) {   // invert
126B6  A239     BTFSS CLKRCON, 1, ACCESS
126B8  D007     BRA 0x26C8
159:                                               onOff = !onOff;
126BA  503A     MOVF CLKRCLK, W, ACCESS
126BC  A4D8     BTFSS 0xFD8, 2, ACCESS
126BE  D002     BRA 0x26C4
126C0  0E01     MOVLW 0x1
126C2  D001     BRA 0x26C6
126C4  0E00     MOVLW 0x0
126C6  6E3A     MOVWF CLKRCLK, ACCESS
160:                                           }
161:                                           outputState[buttonNo] = onOff;
126C8  0E20     MOVLW 0x20
126CA  243B     ADDWF 0x3B, W, ACCESS
126CC  6ED9     MOVWF 0xFD9, ACCESS
126CE  6ADA     CLRF 0xFDA, ACCESS
126D0  0E06     MOVLW 0x6
126D2  22DA     ADDWFC 0xFDA, F, ACCESS
126D4  C53A     MOVFF ev, INDF2
126D6  F4DF     NOP
162:                                           break;
126D8  D033     BRA 0x2740
163:                                       case MODE_ONOFF_ONLY:
164:                                           if (sv & SV_POLARITY) {   // invert
126DA  A239     BTFSS CLKRCON, 1, ACCESS
126DC  D004     BRA 0x26E6
165:                                               if (onOff) {    // don't send ON event
126DE  503A     MOVF CLKRCLK, W, ACCESS
126E0  A4D8     BTFSS 0xFD8, 2, ACCESS
126E2  D048     BRA 0x2774
126E4  D7F1     BRA 0x26C8
166:                                                   continue;
167:                                               }
168:                                           } else {
169:                                               if (! onOff) {
126E6  503A     MOVF CLKRCLK, W, ACCESS
126E8  B4D8     BTFSC 0xFD8, 2, ACCESS
126EA  D044     BRA 0x2774
126EC  D7ED     BRA 0x26C8
170:                                                   continue;   // don't send OFF event
171:                                               }
172:                                           }
173:                                           outputState[buttonNo] = onOff;
174:                                           break;
175:                                       case MODE_TOGGLE:
176:                                           if (onOff) {
126EE  503A     MOVF CLKRCLK, W, ACCESS
126F0  B4D8     BTFSC 0xFD8, 2, ACCESS
126F2  D040     BRA 0x2774
177:                                               outputState[buttonNo] = ! outputState[buttonNo];
126F4  0E20     MOVLW 0x20
126F6  243B     ADDWF 0x3B, W, ACCESS
126F8  6ED9     MOVWF 0xFD9, ACCESS
126FA  6ADA     CLRF 0xFDA, ACCESS
126FC  0E06     MOVLW 0x6
126FE  22DA     ADDWFC 0xFDA, F, ACCESS
12700  0E20     MOVLW 0x20
12702  243B     ADDWF 0x3B, W, ACCESS
12704  6EE1     MOVWF 0xFE1, ACCESS
12706  6AE2     CLRF 0xFE2, ACCESS
12708  0E06     MOVLW 0x6
1270A  22E2     ADDWFC 0xFE2, F, ACCESS
1270C  50E7     MOVF 0xFE7, W, ACCESS
1270E  A4D8     BTFSS 0xFD8, 2, ACCESS
12710  D002     BRA 0x2716
12712  0E01     MOVLW 0x1
12714  D001     BRA 0x2718
12716  0E00     MOVLW 0x0
12718  6EDF     MOVWF 0xFDF, ACCESS
178:                                           } else {
179:                                               continue;   // don't react when button is released
180:                                           }
181:                                           onOff = outputState[buttonNo];
1271A  0E20     MOVLW 0x20
1271C  243B     ADDWF 0x3B, W, ACCESS
1271E  6ED9     MOVWF 0xFD9, ACCESS
12720  6ADA     CLRF 0xFDA, ACCESS
12722  0E06     MOVLW 0x6
12724  22DA     ADDWFC 0xFDA, F, ACCESS
12726  50DF     MOVF 0xFDF, W, ACCESS
12728  6E3A     MOVWF CLKRCLK, ACCESS
182:                                           break;
1272A  D00A     BRA 0x2740
183:                                   }
1272C  5036     MOVF 0x36, W, ACCESS
1272E  0A01     XORLW 0x1
12730  B4D8     BTFSC 0xFD8, 2, ACCESS
12732  D7C1     BRA 0x26B6
12734  0A03     XORLW 0x3
12736  B4D8     BTFSC 0xFD8, 2, ACCESS
12738  D7D0     BRA 0x26DA
1273A  0A01     XORLW 0x1
1273C  B4D8     BTFSC 0xFD8, 2, ACCESS
1273E  D7D7     BRA 0x26EE
184:                                   writeNVM(EEPROM_NVM_TYPE, EE_ADDR_SWITCHES + buttonNo, outputState[buttonNo]);
12740  503B     MOVF 0x3B, W, ACCESS
12742  6E10     MOVWF 0x10, ACCESS
12744  6A11     CLRF 0x11, ACCESS
12746  6A12     CLRF 0x12, ACCESS
12748  0E20     MOVLW 0x20
1274A  243B     ADDWF 0x3B, W, ACCESS
1274C  6ED9     MOVWF 0xFD9, ACCESS
1274E  6ADA     CLRF 0xFDA, ACCESS
12750  0E06     MOVLW 0x6
12752  22DA     ADDWFC 0xFDA, F, ACCESS
12754  50DF     MOVF 0xFDF, W, ACCESS
12756  6E13     MOVWF 0x13, ACCESS
12758  0E00     MOVLW 0x0
1275A  EC7E     CALL 0x156FC, 0
1275C  F0AB     NOP
185:                                   if (canpanScanReady) {
1275E  0105     MOVLB 0x5
12760  51B6     MOVF DMA1PR, W, BANKED
12762  B4D8     BTFSC 0xFD8, 2, ACCESS
12764  D007     BRA 0x2774
186:                                       // send the event.
187:                                       canpanSendProducedEvent(tableIndex, onOff, sv);
12766  C53A     MOVFF ev, data6
12768  F52A     NOP
1276A  C539     MOVFF nEv, opc
1276C  F52B     NOP
1276E  5035     MOVF 0x35, W, ACCESS
12770  EC63     CALL 0x14EC6, 0
12772  F0A7     NOP
188:                                   }
189:                               }
190:                           }
191:                       }
192:                   }
193:               }
12774  2A38     INCF BOOTREG, F, ACCESS
12776  0E03     MOVLW 0x3
12778  6438     CPFSGT BOOTREG, ACCESS
1277A  D745     BRA 0x2606
194:               // save the state
195:               buttonState[column] = row;
1277C  0E5D     MOVLW 0x5D
1277E  0105     MOVLB 0x5
12780  25B3     ADDWF OSCEN, W, BANKED
12782  6ED9     MOVWF 0xFD9, ACCESS
12784  6ADA     CLRF 0xFDA, ACCESS
12786  0E06     MOVLW 0x6
12788  22DA     ADDWFC 0xFDA, F, ACCESS
1278A  C537     MOVFF tableIndex, INDF2
1278C  F4DF     NOP
196:               
197:               // Output the column driver
198:               column++;
1278E  2BB3     INCF OSCEN, F, BANKED
199:               if (column >= NUM_BUTTON_COLUMNS) {
12790  0E07     MOVLW 0x7
12792  65B3     CPFSGT OSCEN, BANKED
12794  D004     BRA 0x279E
200:                   // After 1 scan we'll be ready to send events
201:                   canpanScanReady = 1;
12796  0E01     MOVLW 0x1
12798  6FB6     MOVWF DMA1PR, BANKED
202:                   column=0;
1279A  0E00     MOVLW 0x0
1279C  6FB3     MOVWF OSCEN, BANKED
203:               }
204:               driveColumn();
1279E  EC08     CALL 0x15610, 0
127A0  F0AB     NOP
205:           }
127A2  0012     RETURN 0
206:           
207:           
208:           /**
209:            * Used at initialisation if NV1 = ALLOFF. Turns off (or on if inverted) all 
210:            * the switch output states.
211:            */
212:           void canpanSetAllSwitchOff(void) {
213:               uint8_t buttonNo;
214:               uint8_t tableIndex;
215:               
216:               for (buttonNo=0; buttonNo<NUM_BUTTONS; buttonNo++) {
15BAC  0E00     MOVLW 0x0
15BAE  6E20     MOVWF 0x20, ACCESS
217:                   tableIndex = findEventForSwitch(buttonNo);
15BB0  5020     MOVF 0x20, W, ACCESS
15BB2  EC57     CALL 0x156AE, 0
15BB4  F0AB     NOP
15BB6  6E1F     MOVWF 0x1F, ACCESS
218:                   getEVs(tableIndex);
15BB8  501F     MOVF 0x1F, W, ACCESS
15BBA  EC2D     CALL 0x14E5A, 0
15BBC  F0A7     NOP
219:                   outputState[buttonNo] = (evs[EV_SWITCHSV]&SV_POLARITY) ? 1:0;
15BBE  0E20     MOVLW 0x20
15BC0  2420     ADDWF 0x20, W, ACCESS
15BC2  6ED9     MOVWF 0xFD9, ACCESS
15BC4  6ADA     CLRF 0xFDA, ACCESS
15BC6  0E06     MOVLW 0x6
15BC8  22DA     ADDWFC 0xFDA, F, ACCESS
15BCA  0106     MOVLB 0x6
15BCC  A352     BTFSS 0x52, 1, BANKED
15BCE  D002     BRA 0x5BD4
15BD0  0E01     MOVLW 0x1
15BD2  D001     BRA 0x5BD6
15BD4  0E00     MOVLW 0x0
15BD6  6EDF     MOVWF 0xFDF, ACCESS
220:               }
15BD8  2A20     INCF 0x20, F, ACCESS
15BD8  2A20     INCF 0x20, F, ACCESS
15BD8  2A20     INCF 0x20, F, ACCESS
15BD8  2A20     INCF 0x20, F, ACCESS
15BD8  2A20     INCF 0x20, F, ACCESS
221:           }
222:           
223:           void canpanSendProducedEvent(uint8_t tableIndex, uint8_t onOff, uint8_t sv) {
14EC6  6E2C     MOVWF 0x2C, ACCESS
224:               uint8_t opc;
225:               Word producedEventNN;
226:               Word producedEventEN;
227:               
228:               producedEventNN.word = getNN(tableIndex);
14EC8  502C     MOVF 0x2C, W, ACCESS
14ECA  EC9A     CALL 0x13F34, 0
14ECC  F09F     NOP
14ECE  C50E     MOVFF evNum, m
14ED0  F530     NOP
14ED2  C50F     MOVFF interruptEnabled, evVal
14ED4  F531     NOP
229:               producedEventEN.word = getEN(tableIndex);
14ED6  502C     MOVF 0x2C, W, ACCESS
14ED8  ECC0     CALL 0x14D80, 0
14EDA  F0A6     NOP
14EDC  C50E     MOVFF evNum, service
14EDE  F52E     NOP
14EE0  C50F     MOVFF interruptEnabled, tableIndex
14EE2  F52F     NOP
230:               if ((sv & SV_SHORT) || (producedEventNN.word == 0)) {
14EE4  BA2B     BTFSC 0x2B, 5, ACCESS
14EE6  D004     BRA 0x4EF0
14EE8  5030     MOVF 0x30, W, ACCESS
14EEA  1031     IORWF 0x31, W, ACCESS
14EEC  A4D8     BTFSS 0xFD8, 2, ACCESS
14EEE  D00C     BRA 0x4F08
231:                   // Short event
232:                   if (onOff) {
14EF0  502A     MOVF 0x2A, W, ACCESS
14EF2  B4D8     BTFSC 0xFD8, 2, ACCESS
14EF4  D002     BRA 0x4EFA
233:                       opc = OPC_ASON;
14EF6  0E98     MOVLW 0x98
14EF8  D001     BRA 0x4EFC
234:                   } else {
235:                       opc = OPC_ASOF;
14EFA  0E99     MOVLW 0x99
14EFC  6E2D     MOVWF 0x2D, ACCESS
236:                   }
237:                   producedEventNN.word = nn.word;
14EFE  C553     MOVFF nn, m
14F00  F530     NOP
14F02  C554     MOVFF 0x554, evVal
14F04  F531     NOP
238:               } else {
14F06  D007     BRA 0x4F16
239:                   // Long event
240:                   if (onOff) {
14F08  502A     MOVF 0x2A, W, ACCESS
14F0A  B4D8     BTFSC 0xFD8, 2, ACCESS
14F0C  D002     BRA 0x4F12
241:                       opc = OPC_ACON;
14F0E  0E90     MOVLW 0x90
14F10  D001     BRA 0x4F14
242:                   } else {
243:                       opc = OPC_ACOF;
14F12  0E91     MOVLW 0x91
14F14  6E2D     MOVWF 0x2D, ACCESS
244:                   }
245:               }
246:           
247:               sendMessage4(opc, producedEventNN.bytes.hi, producedEventNN.bytes.lo, 
14F16  C531     MOVFF evVal, data1
14F18  F525     NOP
14F1A  C530     MOVFF m, data2
14F1C  F526     NOP
14F1E  C52F     MOVFF tableIndex, data3
14F20  F527     NOP
14F22  C52E     MOVFF service, data4
14F24  F528     NOP
14F26  502D     MOVF 0x2D, W, ACCESS
14F28  EC92     CALL 0x15F24, 0
14F2A  F0AF     NOP
248:                       producedEventEN.bytes.hi, producedEventEN.bytes.lo);
249:           
250:               incrementProducerCounter();
14F2C  EC38     CALL 0x16270, 0
14F2E  F0B1     NOP
251:           }
14F30  0012     RETURN 0
252:           
253:           void driveColumn(void) {
254:               LATAbits.LATA0 = (column & 0x01)?1:0;
15610  0105     MOVLB 0x5
15612  A1B3     BTFSS OSCEN, 0, BANKED
15614  D003     BRA 0x561C
15616  6A02     CLRF ___rparam_used, ACCESS
15618  2A02     INCF ___rparam_used, F, ACCESS
1561A  D001     BRA 0x561E
1561C  6A02     CLRF ___rparam_used, ACCESS
1561E  50BE     MOVF 0xFBE, W, ACCESS
15620  1802     XORWF ___rparam_used, W, ACCESS
15622  0BFE     ANDLW 0xFE
15624  1802     XORWF ___rparam_used, W, ACCESS
15626  6EBE     MOVWF 0xFBE, ACCESS
255:               LATAbits.LATA1 = (column & 0x02)?1:0;
15628  0105     MOVLB 0x5
1562A  A3B3     BTFSS OSCEN, 1, BANKED
1562C  D003     BRA 0x5634
1562E  6A02     CLRF ___rparam_used, ACCESS
15630  2A02     INCF ___rparam_used, F, ACCESS
15632  D001     BRA 0x5636
15634  6A02     CLRF ___rparam_used, ACCESS
15636  4602     RLNCF ___rparam_used, F, ACCESS
15638  50BE     MOVF 0xFBE, W, ACCESS
1563A  1802     XORWF ___rparam_used, W, ACCESS
1563C  0BFD     ANDLW 0xFD
1563E  1802     XORWF ___rparam_used, W, ACCESS
15640  6EBE     MOVWF 0xFBE, ACCESS
256:               LATAbits.LATA2 = (column & 0x04)?1:0;
15642  0105     MOVLB 0x5
15644  A5B3     BTFSS OSCEN, 2, BANKED
15646  D003     BRA 0x564E
15648  6A02     CLRF ___rparam_used, ACCESS
1564A  2A02     INCF ___rparam_used, F, ACCESS
1564C  D001     BRA 0x5650
1564E  6A02     CLRF ___rparam_used, ACCESS
15650  4602     RLNCF ___rparam_used, F, ACCESS
15652  4602     RLNCF ___rparam_used, F, ACCESS
15654  50BE     MOVF 0xFBE, W, ACCESS
15656  1802     XORWF ___rparam_used, W, ACCESS
15658  0BFB     ANDLW 0xFB
1565A  1802     XORWF ___rparam_used, W, ACCESS
1565C  6EBE     MOVWF 0xFBE, ACCESS
257:           }
1565E  0012     RETURN 0
258:           
259:           uint8_t findEventForSwitch(uint8_t switchNo) {
156AE  6E1D     MOVWF 0x1D, ACCESS
260:               uint8_t tableIndex;
261:               for (tableIndex=0; tableIndex < NUM_EVENTS; tableIndex++) {
156B0  0E00     MOVLW 0x0
156B2  6E1E     MOVWF 0x1E, ACCESS
262:                   getEVs(tableIndex);
156B4  501E     MOVF 0x1E, W, ACCESS
156B6  EC2D     CALL 0x14E5A, 0
156B8  F0A7     NOP
263:                   if ((evs[EV_TYPE] == CANPAN_PRODUCED) || (evs[EV_TYPE] == CANPAN_SELF_SOD)) {
156BA  0106     MOVLB 0x6
156BC  0550     DECF 0x50, W, BANKED
156BE  B4D8     BTFSC 0xFD8, 2, ACCESS
156C0  D004     BRA 0x56CA
156C2  0E03     MOVLW 0x3
156C4  1950     XORWF 0x50, W, BANKED
156C6  A4D8     BTFSS 0xFD8, 2, ACCESS
156C8  D013     BRA 0x56F0
264:                       if (evs[EV_SWITCHNO] == switchNo+1) {
156CA  5151     MOVF 0x51, W, BANKED
156CC  6E19     MOVWF 0x19, ACCESS
156CE  6A1A     CLRF 0x1A, ACCESS
156D0  501D     MOVF 0x1D, W, ACCESS
156D2  6E1B     MOVWF 0x1B, ACCESS
156D4  6A1C     CLRF 0x1C, ACCESS
156D6  0E01     MOVLW 0x1
156D8  261B     ADDWF 0x1B, F, ACCESS
156DA  0E00     MOVLW 0x0
156DC  221C     ADDWFC 0x1C, F, ACCESS
156DE  5019     MOVF 0x19, W, ACCESS
156E0  181B     XORWF 0x1B, W, ACCESS
156E2  E106     BNZ 0x56F0
156E4  501A     MOVF 0x1A, W, ACCESS
156E6  181C     XORWF 0x1C, W, ACCESS
156E8  A4D8     BTFSS 0xFD8, 2, ACCESS
156EA  D002     BRA 0x56F0
265:                           return tableIndex;
156EC  501E     MOVF 0x1E, W, ACCESS
156EE  0012     RETURN 0
266:                       }
267:                   }
268:               }
156F0  2A1E     INCF 0x1E, F, ACCESS
156F2  0EFD     MOVLW 0xFD
156F4  641E     CPFSGT 0x1E, ACCESS
156F6  D7DE     BRA 0x56B4
269:               return NO_INDEX;
156F8  0EFF     MOVLW 0xFF
270:           }
156FA  0012     RETURN 0
271:           
272:           /**
273:            * Do the start of day by sending the current state of all produced events.
274:            * Use TimedResponse so we don't overload the bus.
275:            * This sets things up so that timedResponse will call back into APP_doSOD() 
276:            * whenever another response is required.
277:            */
278:           void doSoD(void) {
279:               startTimedResponse(TIMED_RESPONSE_SOD, findServiceIndex(SERVICE_ID_PRODUCER), sodTRCallback);
16176  0E05     MOVLW 0x5
16178  EC18     CALL 0x14C30, 0
1617A  F0A6     NOP
1617C  6E06     MOVWF 0x6, ACCESS
1617E  0EC2     MOVLW 0xC2
16180  6E07     MOVWF 0x7, ACCESS
16182  0E5A     MOVLW 0x5A
16184  6E08     MOVWF 0x8, ACCESS
16186  0E01     MOVLW 0x1
16188  6E09     MOVWF 0x9, ACCESS
1618A  0E01     MOVLW 0x1
1618C  ECE2     CALL 0x159C4, 0
1618E  F0AC     NOP
280:           }
16190  0012     RETURN 0
281:           
282:           /**
283:            * Send one response CBUS message and increment the step counter ready for the next call.
284:            * 
285:            * Here I use step 0 to 254 to go through all possible events.
286:            *  
287:            * This is the callback used by the start of day responses.
288:            * @param type always set to TIMED_RESPONSE_SOD
289:            * @param serviceIndex indicates the service requesting the responses
290:            * @param step loops through each event tableIndex
291:            * @return whether all of the responses have been sent yet.
292:            */
293:           TimedResponseResult sodTRCallback(uint8_t type, uint8_t serviceIndex, uint8_t tableIndex) {
294:               EventState value;
295:               uint8_t sv;
296:           
297:               if (tableIndex >= NUM_EVENTS) {
15AC2  0EFD     MOVLW 0xFD
15AC4  6433     CPFSGT 0x33, ACCESS
15AC6  D002     BRA 0x5ACC
298:                   return TIMED_RESPONSE_RESULT_FINISHED;
15AC8  0E00     MOVLW 0x0
15ACA  0012     RETURN 0
299:               }
300:               // The step is used to index through the events 
301:               value = APP_GetEventIndexState(tableIndex);
15ACC  5033     MOVF 0x33, W, ACCESS
15ACE  EC39     CALL 0x15872, 0
15AD0  F0AC     NOP
15AD2  6E35     MOVWF 0x35, ACCESS
302:               
303:               if (value != EVENT_UNKNOWN) {
15AD4  2835     INCF 0x35, W, ACCESS
15AD6  B4D8     BTFSC 0xFD8, 2, ACCESS
15AD8  D010     BRA 0x5AFA
304:                   sv = evs[EV_SWITCHSV];
15ADA  C652     MOVFF 0x652, nodeNumber
15ADC  F534     NOP
305:                   if (!(sv & SV_ONLY)) { // Don't send ON ONLY nor OFF ONLY
15ADE  B434     BTFSC 0x34, 2, ACCESS
15AE0  D00C     BRA 0x5AFA
306:                       canpanSendProducedEvent(tableIndex, value==EVENT_ON, evs[EV_SWITCHSV]);
15AE2  0435     DECF 0x35, W, ACCESS
15AE4  A4D8     BTFSS 0xFD8, 2, ACCESS
15AE6  D002     BRA 0x5AEC
15AE8  0E01     MOVLW 0x1
15AEA  D001     BRA 0x5AEE
15AEC  0E00     MOVLW 0x0
15AEE  6E2A     MOVWF 0x2A, ACCESS
15AF0  C652     MOVFF 0x652, opc
15AF2  F52B     NOP
15AF4  5033     MOVF 0x33, W, ACCESS
15AF6  EC63     CALL 0x14EC6, 0
15AF8  F0A7     NOP
307:                   }
308:               }
309:               return TIMED_RESPONSE_RESULT_NEXT;
15AFA  0E02     MOVLW 0x2
310:           }
15AFC  0012     RETURN 0
311:           
312:           
313:           /**
314:            * Load the switch state in from EEPROM
315:            */
316:           void loadInputs(void) {
317:               uint8_t tableIndex;
318:               uint8_t buttonNo;
319:           
320:               for (tableIndex=0; tableIndex < NUM_EVENTS; tableIndex++) {
15660  0E00     MOVLW 0x0
15662  6E1E     MOVWF 0x1E, ACCESS
321:                   getEVs(tableIndex);
15664  501E     MOVF 0x1E, W, ACCESS
15666  EC2D     CALL 0x14E5A, 0
15668  F0A7     NOP
322:                   if (APP_isProducedEvent(tableIndex)) {
1566A  501E     MOVF 0x1E, W, ACCESS
1566C  ECBA     CALL 0x15D74, 0
1566E  F0AE     NOP
15670  0900     IORLW 0x0
15672  B4D8     BTFSC 0xFD8, 2, ACCESS
15674  D017     BRA 0x56A4
323:                       if (evs[EV_SWITCHSV] & SV_TOGGLE) {
15676  0106     MOVLB 0x6
15678  A752     BTFSS 0x52, 3, BANKED
1567A  D014     BRA 0x56A4
324:                           buttonNo = evs[EV_SWITCHNO] - 1;
1567C  0551     DECF 0x51, W, BANKED
1567E  6E1D     MOVWF 0x1D, ACCESS
325:                           if (buttonNo < NUM_BUTTONS)
15680  0E20     MOVLW 0x20
15682  601D     CPFSLT 0x1D, ACCESS
15684  D00F     BRA 0x56A4
326:                           outputState[buttonNo] = (uint8_t)readNVM(EEPROM_NVM_TYPE, EE_ADDR_SWITCHES+buttonNo);
15686  501D     MOVF 0x1D, W, ACCESS
15688  6E08     MOVWF 0x8, ACCESS
1568A  6A09     CLRF 0x9, ACCESS
1568C  6A0A     CLRF 0xA, ACCESS
1568E  0E00     MOVLW 0x0
15690  ECF3     CALL 0x151E6, 0
15692  F0A8     NOP
15694  0E20     MOVLW 0x20
15696  241D     ADDWF 0x1D, W, ACCESS
15698  6ED9     MOVWF 0xFD9, ACCESS
1569A  6ADA     CLRF 0xFDA, ACCESS
1569C  0E06     MOVLW 0x6
1569E  22DA     ADDWFC 0xFDA, F, ACCESS
156A0  C508     MOVFF index, INDF2
156A2  F4DF     NOP
327:                       }
328:                   }
329:               }
156A4  2A1E     INCF 0x1E, F, ACCESS
156A4  2A1E     INCF 0x1E, F, ACCESS
156A4  2A1E     INCF 0x1E, F, ACCESS
156A4  2A1E     INCF 0x1E, F, ACCESS
156A4  2A1E     INCF 0x1E, F, ACCESS
330:           }
---  C:/Users/ianwh/github/CANPAN2/canpan3Events.c  -----------------------------------------------------
1:             /*
2:               This work is licensed under the:
3:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
4:                To view a copy of this license, visit:
5:                   http://creativecommons.org/licenses/by-nc-sa/4.0/
6:                or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
7:             
8:                License summary:
9:                 You are free to:
10:                  Share, copy and redistribute the material in any medium or format
11:                  Adapt, remix, transform, and build upon the material
12:            
13:                The licensor cannot revoke these freedoms as long as you follow the license terms.
14:            
15:                Attribution : You must give appropriate credit, provide a link to the license,
16:                               and indicate if changes were made. You may do so in any reasonable manner,
17:                               but not in any way that suggests the licensor endorses you or your use.
18:            
19:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
20:            
21:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
22:                              your contributions under the same license as the original.
23:            
24:                No additional restrictions : You may not apply legal terms or technological measures that
25:                                              legally restrict others from doing anything the license permits.
26:            
27:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
28:            
29:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
30:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
31:             */
32:            /**
33:             *	The CANPAN program.
34:             *
35:             * @author Ian Hogg 
36:             * @date October 2024
37:             * 
38:             */ 
39:            #include <xc.h>
40:            #include "module.h"
41:            #include "event_teach.h"
42:            #include "mns.h"
43:            #include "canpan3Events.h"
44:            #include "canpan3Leds.h"
45:            #include "canpan3Inputs.h"
46:            
47:            uint8_t APP_isProducedEvent(uint8_t tableIndex);
48:            
49:            void factoryResetGlobalEvents(void) {
50:                uint8_t i;
51:            
52:                // set up the default switch/button events
53:                for (i=1; i<= NUM_BUTTONS; i++) {
1222E  0E01     MOVLW 0x1
12230  6E3A     MOVWF CLKRCLK, ACCESS
12232  0E20     MOVLW 0x20
12234  643A     CPFSGT CLKRCLK, ACCESS
12236  D001     BRA 0x223A
12238  0012     RETURN 0
54:                    // write 3 EVs for the buttons/switches produced events
55:                    addEvent(nn.word, i, EV_TYPE, CANPAN_PRODUCED, TRUE);
1223A  C553     MOVFF nn, data7
1223C  F523     NOP
1223E  C554     MOVFF 0x554, opc
12240  F524     NOP
12242  C53A     MOVFF ev, data1
12244  F525     NOP
12246  6A26     CLRF 0x26, ACCESS
12248  0E00     MOVLW 0x0
1224A  6E27     MOVWF 0x27, ACCESS
1224C  0E01     MOVLW 0x1
1224E  6E28     MOVWF 0x28, ACCESS
12250  0E01     MOVLW 0x1
12252  6E29     MOVWF 0x29, ACCESS
12254  ECD2     CALL 0x127A4, 0
12256  F093     NOP
56:                    addEvent(nn.word, i, EV_SWITCHNO, i, TRUE);
12258  C553     MOVFF nn, data7
1225A  F523     NOP
1225C  C554     MOVFF 0x554, opc
1225E  F524     NOP
12260  C53A     MOVFF ev, data1
12262  F525     NOP
12264  6A26     CLRF 0x26, ACCESS
12266  0E01     MOVLW 0x1
12268  6E27     MOVWF 0x27, ACCESS
1226A  C53A     MOVFF ev, data4
1226C  F528     NOP
1226E  0E01     MOVLW 0x1
12270  6E29     MOVWF 0x29, ACCESS
12272  ECD2     CALL 0x127A4, 0
12274  F093     NOP
57:                    addEvent(nn.word, i, EV_SWITCHSV, SV_TOGGLE | SV_COE, TRUE);
12276  C553     MOVFF nn, data7
12278  F523     NOP
1227A  C554     MOVFF 0x554, opc
1227C  F524     NOP
1227E  C53A     MOVFF ev, data1
12280  F525     NOP
12282  6A26     CLRF 0x26, ACCESS
12284  0E02     MOVLW 0x2
12286  6E27     MOVWF 0x27, ACCESS
12288  0E18     MOVLW 0x18
1228A  6E28     MOVWF 0x28, ACCESS
1228C  0E01     MOVLW 0x1
1228E  6E29     MOVWF 0x29, ACCESS
12290  ECD2     CALL 0x127A4, 0
12292  F093     NOP
58:                    // write the EVs so that these default events also turn on an LED for testing
59:                    addEvent(nn.word, i, EV_LEDFLAGS1, ((uint16_t)1<<(i-1))&0xFF, TRUE);
12294  C553     MOVFF nn, data7
12296  F523     NOP
12298  C554     MOVFF 0x554, opc
1229A  F524     NOP
1229C  C53A     MOVFF ev, data1
1229E  F525     NOP
122A0  6A26     CLRF 0x26, ACCESS
122A2  0E04     MOVLW 0x4
122A4  6E27     MOVWF 0x27, ACCESS
122A6  C53A     MOVFF ev, nodeNumber
122A8  F538     NOP
122AA  0EFF     MOVLW 0xFF
122AC  2638     ADDWF BOOTREG, F, ACCESS
122AE  0E01     MOVLW 0x1
122B0  6E39     MOVWF CLKRCON, ACCESS
122B2  2A38     INCF BOOTREG, F, ACCESS
122B4  D002     BRA 0x22BA
122B6  90D8     BCF 0xFD8, 0, ACCESS
122B8  3639     RLCF CLKRCON, F, ACCESS
122BA  2E38     DECFSZ BOOTREG, F, ACCESS
122BC  D7FC     BRA 0x22B6
122BE  5039     MOVF CLKRCON, W, ACCESS
122C0  6E28     MOVWF 0x28, ACCESS
122C2  0E01     MOVLW 0x1
122C4  6E29     MOVWF 0x29, ACCESS
122C6  ECD2     CALL 0x127A4, 0
122C8  F093     NOP
60:                    addEvent(nn.word, i, EV_LEDFLAGS2, ((uint16_t)1<<(i-9))&0xFF, TRUE);
122CA  C553     MOVFF nn, data7
122CC  F523     NOP
122CE  C554     MOVFF 0x554, opc
122D0  F524     NOP
122D2  C53A     MOVFF ev, data1
122D4  F525     NOP
122D6  6A26     CLRF 0x26, ACCESS
122D8  0E05     MOVLW 0x5
122DA  6E27     MOVWF 0x27, ACCESS
122DC  C53A     MOVFF ev, nodeNumber
122DE  F538     NOP
122E0  0EF7     MOVLW 0xF7
122E2  2638     ADDWF BOOTREG, F, ACCESS
122E4  0E01     MOVLW 0x1
122E6  6E39     MOVWF CLKRCON, ACCESS
122E8  2A38     INCF BOOTREG, F, ACCESS
122EA  D002     BRA 0x22F0
122EC  90D8     BCF 0xFD8, 0, ACCESS
122EE  3639     RLCF CLKRCON, F, ACCESS
122F0  2E38     DECFSZ BOOTREG, F, ACCESS
122F2  D7FC     BRA 0x22EC
122F4  5039     MOVF CLKRCON, W, ACCESS
122F6  6E28     MOVWF 0x28, ACCESS
122F8  0E01     MOVLW 0x1
122FA  6E29     MOVWF 0x29, ACCESS
122FC  ECD2     CALL 0x127A4, 0
122FE  F093     NOP
61:                    addEvent(nn.word, i, EV_LEDFLAGS3, ((uint16_t)1<<(i-17))&0xFF, TRUE);
12300  C553     MOVFF nn, data7
12302  F523     NOP
12304  C554     MOVFF 0x554, opc
12306  F524     NOP
12308  C53A     MOVFF ev, data1
1230A  F525     NOP
1230C  6A26     CLRF 0x26, ACCESS
1230E  0E06     MOVLW 0x6
12310  6E27     MOVWF 0x27, ACCESS
12312  C53A     MOVFF ev, nodeNumber
12314  F538     NOP
12316  0EEF     MOVLW 0xEF
12318  2638     ADDWF BOOTREG, F, ACCESS
1231A  0E01     MOVLW 0x1
1231C  6E39     MOVWF CLKRCON, ACCESS
1231E  2A38     INCF BOOTREG, F, ACCESS
12320  D002     BRA 0x2326
12322  90D8     BCF 0xFD8, 0, ACCESS
12324  3639     RLCF CLKRCON, F, ACCESS
12326  2E38     DECFSZ BOOTREG, F, ACCESS
12328  D7FC     BRA 0x2322
1232A  5039     MOVF CLKRCON, W, ACCESS
1232C  6E28     MOVWF 0x28, ACCESS
1232E  0E01     MOVLW 0x1
12330  6E29     MOVWF 0x29, ACCESS
12332  ECD2     CALL 0x127A4, 0
12334  F093     NOP
62:                    addEvent(nn.word, i, EV_LEDFLAGS4, ((uint16_t)1<<(i-25))&0xFF, TRUE);
12336  C553     MOVFF nn, data7
12338  F523     NOP
1233A  C554     MOVFF 0x554, opc
1233C  F524     NOP
1233E  C53A     MOVFF ev, data1
12340  F525     NOP
12342  6A26     CLRF 0x26, ACCESS
12344  0E07     MOVLW 0x7
12346  6E27     MOVWF 0x27, ACCESS
12348  C53A     MOVFF ev, nodeNumber
1234A  F538     NOP
1234C  0EE7     MOVLW 0xE7
1234E  2638     ADDWF BOOTREG, F, ACCESS
12350  0E01     MOVLW 0x1
12352  6E39     MOVWF CLKRCON, ACCESS
12354  2A38     INCF BOOTREG, F, ACCESS
12356  D002     BRA 0x235C
12358  90D8     BCF 0xFD8, 0, ACCESS
1235A  3639     RLCF CLKRCON, F, ACCESS
1235C  2E38     DECFSZ BOOTREG, F, ACCESS
1235E  D7FC     BRA 0x2358
12360  5039     MOVF CLKRCON, W, ACCESS
12362  6E28     MOVWF 0x28, ACCESS
12364  0E01     MOVLW 0x1
12366  6E29     MOVWF 0x29, ACCESS
12368  ECD2     CALL 0x127A4, 0
1236A  F093     NOP
63:                    addEvent(nn.word, i, EV_LEDPOLARITY1, 0, TRUE);
1236C  C553     MOVFF nn, data7
1236E  F523     NOP
12370  C554     MOVFF 0x554, opc
12372  F524     NOP
12374  C53A     MOVFF ev, data1
12376  F525     NOP
12378  6A26     CLRF 0x26, ACCESS
1237A  0E08     MOVLW 0x8
1237C  6E27     MOVWF 0x27, ACCESS
1237E  0E00     MOVLW 0x0
12380  6E28     MOVWF 0x28, ACCESS
12382  0E01     MOVLW 0x1
12384  6E29     MOVWF 0x29, ACCESS
12386  ECD2     CALL 0x127A4, 0
12388  F093     NOP
64:                    addEvent(nn.word, i, EV_LEDPOLARITY2, 0, TRUE);
1238A  C553     MOVFF nn, data7
1238C  F523     NOP
1238E  C554     MOVFF 0x554, opc
12390  F524     NOP
12392  C53A     MOVFF ev, data1
12394  F525     NOP
12396  6A26     CLRF 0x26, ACCESS
12398  0E09     MOVLW 0x9
1239A  6E27     MOVWF 0x27, ACCESS
1239C  0E00     MOVLW 0x0
1239E  6E28     MOVWF 0x28, ACCESS
123A0  0E01     MOVLW 0x1
123A2  6E29     MOVWF 0x29, ACCESS
123A4  ECD2     CALL 0x127A4, 0
123A6  F093     NOP
65:                    addEvent(nn.word, i, EV_LEDPOLARITY3, 0, TRUE);
123A8  C553     MOVFF nn, data7
123AA  F523     NOP
123AC  C554     MOVFF 0x554, opc
123AE  F524     NOP
123B0  C53A     MOVFF ev, data1
123B2  F525     NOP
123B4  6A26     CLRF 0x26, ACCESS
123B6  0E0A     MOVLW 0xA
123B8  6E27     MOVWF 0x27, ACCESS
123BA  0E00     MOVLW 0x0
123BC  6E28     MOVWF 0x28, ACCESS
123BE  0E01     MOVLW 0x1
123C0  6E29     MOVWF 0x29, ACCESS
123C2  ECD2     CALL 0x127A4, 0
123C4  F093     NOP
66:                    addEvent(nn.word, i, EV_LEDPOLARITY4, 0, TRUE);
123C6  C553     MOVFF nn, data7
123C8  F523     NOP
123CA  C554     MOVFF 0x554, opc
123CC  F524     NOP
123CE  C53A     MOVFF ev, data1
123D0  F525     NOP
123D2  6A26     CLRF 0x26, ACCESS
123D4  0E0B     MOVLW 0xB
123D6  6E27     MOVWF 0x27, ACCESS
123D8  0E00     MOVLW 0x0
123DA  6E28     MOVWF 0x28, ACCESS
123DC  0E01     MOVLW 0x1
123DE  6E29     MOVWF 0x29, ACCESS
123E0  ECD2     CALL 0x127A4, 0
123E2  F093     NOP
67:                    addEvent(nn.word, i, EV_LEDMODE, LM_ONOFF, TRUE);
123E4  C553     MOVFF nn, data7
123E6  F523     NOP
123E8  C554     MOVFF 0x554, opc
123EA  F524     NOP
123EC  C53A     MOVFF ev, data1
123EE  F525     NOP
123F0  6A26     CLRF 0x26, ACCESS
123F2  0E0C     MOVLW 0xC
123F4  6E27     MOVWF 0x27, ACCESS
123F6  0EFF     MOVLW 0xFF
123F8  6E28     MOVWF 0x28, ACCESS
123FA  0E01     MOVLW 0x1
123FC  6E29     MOVWF 0x29, ACCESS
123FE  ECD2     CALL 0x127A4, 0
12400  F093     NOP
68:                }
12402  2A3A     INCF CLKRCLK, F, ACCESS
12402  2A3A     INCF CLKRCLK, F, ACCESS
69:            }
70:            
71:            uint8_t APP_addEvent(uint16_t nodeNumber, uint16_t eventNumber, uint8_t evNum, uint8_t evVal, Boolean forceOwnNN) {
72:                return addEvent(nodeNumber, eventNumber, evNum, evVal, forceOwnNN);
160BE  C538     MOVFF nodeNumber, data7
160C0  F523     NOP
160C2  C539     MOVFF nEv, opc
160C4  F524     NOP
160C6  C53A     MOVFF ev, data1
160C8  F525     NOP
160CA  C53B     MOVFF buttonNo, data2
160CC  F526     NOP
160CE  C53C     MOVFF nodeNumber, data3
160D0  F527     NOP
160D2  C53D     MOVFF i, data4
160D4  F528     NOP
160D6  C53E     MOVFF i, data5
160D8  F529     NOP
160DA  ECD2     CALL 0x127A4, 0
160DC  F093     NOP
73:            }
160DE  0012     RETURN 0
74:            
75:            /**
76:             * The CANPAN represents the event type in EV#1 however it also uses Bit 4 of EV#3 to control
77:             * self consumption of produced events. 
78:             * 
79:             * @param tableIndex
80:             * @return 
81:             */
82:            uint8_t APP_isConsumedEvent(uint8_t tableIndex) {
15462  6E1A     MOVWF 0x1A, ACCESS
83:                int16_t ev;
84:                
85:                ev = getEv(tableIndex, EV_TYPE);
15464  0E00     MOVLW 0x0
15466  6E0E     MOVWF 0xE, ACCESS
15468  501A     MOVF 0x1A, W, ACCESS
1546A  ECCF     CALL 0x14F9E, 0
1546C  F0A7     NOP
1546E  C50E     MOVFF evNum, eventNumber
15470  F51B     NOP
15472  C50F     MOVFF interruptEnabled, len
15474  F51C     NOP
86:                if (ev < 0) {
15476  AE1C     BTFSS 0x1C, 7, ACCESS
15478  D002     BRA 0x547E
87:                    // error
88:                    return 0;
1547A  0E00     MOVLW 0x0
1547C  0012     RETURN 0
89:                }
90:                if (ev == CANPAN_CONSUMED) {    // normal consumed event
1547E  501B     MOVF 0x1B, W, ACCESS
15480  101C     IORWF 0x1C, W, ACCESS
15482  A4D8     BTFSS 0xFD8, 2, ACCESS
15484  D002     BRA 0x548A
91:                    return 1;
15486  0E01     MOVLW 0x1
15488  0012     RETURN 0
92:                }
93:                if ((ev == CANPAN_SOD)||(ev == CANPAN_SELF_SOD)) {    // SoD consumed event
1548A  0E02     MOVLW 0x2
1548C  181B     XORWF 0x1B, W, ACCESS
1548E  101C     IORWF 0x1C, W, ACCESS
15490  B4D8     BTFSC 0xFD8, 2, ACCESS
15492  D7F9     BRA 0x5486
15494  0E03     MOVLW 0x3
15496  181B     XORWF 0x1B, W, ACCESS
15498  101C     IORWF 0x1C, W, ACCESS
1549A  B4D8     BTFSC 0xFD8, 2, ACCESS
1549C  D7F4     BRA 0x5486
94:                    return 1;
95:                }
96:                ev = getEv(tableIndex, EV_SWITCHSV);
1549E  0E02     MOVLW 0x2
154A0  6E0E     MOVWF 0xE, ACCESS
154A2  501A     MOVF 0x1A, W, ACCESS
154A4  ECCF     CALL 0x14F9E, 0
154A6  F0A7     NOP
154A8  C50E     MOVFF evNum, eventNumber
154AA  F51B     NOP
154AC  C50F     MOVFF interruptEnabled, len
154AE  F51C     NOP
97:                if (ev < 0) {
154B0  BE1C     BTFSC 0x1C, 7, ACCESS
154B2  D7E3     BRA 0x547A
98:                    return 0;
99:                }
100:               return (ev & SV_COE);       // self consumed event
154B4  501B     MOVF 0x1B, W, ACCESS
154B6  0B10     ANDLW 0x10
101:           }
154B8  0012     RETURN 0
102:           
103:           /**
104:            * The CANPAN represents the event type in EV#1. 
105:            * 
106:            * @param tableIndex
107:            * @return 
108:            */
109:           uint8_t APP_isProducedEvent(uint8_t tableIndex) {
15D74  6E1A     MOVWF 0x1A, ACCESS
110:               int16_t ev;
111:               
112:               ev = getEv(tableIndex, EV_TYPE);
15D76  0E00     MOVLW 0x0
15D78  6E0E     MOVWF 0xE, ACCESS
15D7A  501A     MOVF 0x1A, W, ACCESS
15D7C  ECCF     CALL 0x14F9E, 0
15D7E  F0A7     NOP
15D80  C50E     MOVFF evNum, eventNumber
15D82  F51B     NOP
15D84  C50F     MOVFF interruptEnabled, len
15D86  F51C     NOP
113:               if ((ev == CANPAN_PRODUCED) || (ev == CANPAN_SELF_SOD)) {
15D88  041B     DECF 0x1B, W, ACCESS
15D8A  101C     IORWF 0x1C, W, ACCESS
15D8C  B4D8     BTFSC 0xFD8, 2, ACCESS
15D8E  D005     BRA 0x5D9A
15D90  0E03     MOVLW 0x3
15D92  181B     XORWF 0x1B, W, ACCESS
15D94  101C     IORWF 0x1C, W, ACCESS
15D96  A4D8     BTFSS 0xFD8, 2, ACCESS
15D98  D002     BRA 0x5D9E
114:                   return 1;
15D9A  0E01     MOVLW 0x1
15D9C  0012     RETURN 0
115:               }
116:               return 0;
15D9E  0E00     MOVLW 0x0
117:           }
15DA0  0012     RETURN 0
118:           
119:           /**
120:            * Special handling when we receive a switch produced event for a toggle switch.
121:            * We update the internal toggle state to match that of the event.
122:            * 
123:            * @param m
124:            */
125:           Processed APP_preProcessMessage(Message * m) {
126:               uint8_t tableIndex;
127:               uint16_t enn;
128:               uint8_t switchNo;
129:               uint8_t ev;
130:               
131:               if (m->len < 5) return NOT_PROCESSED;
12E4C  C520     MOVFF data4, FSR2
12E4E  F4D9     NOP
12E50  C521     MOVFF data5, FSR2H
12E52  F4DA     NOP
12E54  0E05     MOVLW 0x5
12E56  60DF     CPFSLT 0xFDF, ACCESS
12E58  D002     BRA 0x2E5E
12E5A  0E00     MOVLW 0x0
12E5C  0012     RETURN 0
132:               
133:               enn = ((uint16_t)m->bytes[0])*256+m->bytes[1];
12E5E  EE20     LFSR 2, 0x3
12E60  F003     NOP
12E62  5020     MOVF 0x20, W, ACCESS
12E64  26D9     ADDWF 0xFD9, F, ACCESS
12E66  5021     MOVF 0x21, W, ACCESS
12E68  22DA     ADDWFC 0xFDA, F, ACCESS
12E6A  50DF     MOVF 0xFDF, W, ACCESS
12E6C  6E22     MOVWF 0x22, ACCESS
12E6E  EE20     LFSR 2, 0x2
12E70  F002     NOP
12E72  5020     MOVF 0x20, W, ACCESS
12E74  26D9     ADDWF 0xFD9, F, ACCESS
12E76  5021     MOVF 0x21, W, ACCESS
12E78  22DA     ADDWFC 0xFDA, F, ACCESS
12E7A  50DF     MOVF 0xFDF, W, ACCESS
12E7C  6E23     MOVWF 0x23, ACCESS
12E7E  5022     MOVF 0x22, W, ACCESS
12E80  6E26     MOVWF 0x26, ACCESS
12E82  C523     MOVFF data7, data3
12E84  F527     NOP
134:               
135:               switch (m->opc) {
12E86  D005     BRA 0x2E92
136:                   case OPC_ASON:
137:           #ifdef HANDLE_DATA_EVENTS
138:                   case OPC_ASON1:
139:                   case OPC_ASON2:
140:                   case OPC_ASON3:
141:           #endif
142:           		enn = 0;
12E88  0E00     MOVLW 0x0
12E8A  6E27     MOVWF 0x27, ACCESS
12E8C  0E00     MOVLW 0x0
12E8E  6E26     MOVWF 0x26, ACCESS
143:           		// fall through
144:                   case OPC_ACON:
145:           #ifdef HANDLE_DATA_EVENTS
146:                   case OPC_ACON1:
147:                   case OPC_ACON2:
148:                   case OPC_ACON3:
149:           #endif
150:                       break;
12E90  D03F     BRA 0x2F10
151:                   case OPC_ASOF:
152:           #ifdef HANDLE_DATA_EVENTS
153:                   case OPC_ASOF1:
154:                   case OPC_ASOF2:
155:                   case OPC_ASOF3:
156:           #endif
157:           		enn = 0;
158:           		// fall through
159:                   case OPC_ACOF:
160:           #ifdef HANDLE_DATA_EVENTS
161:                   case OPC_ACOF1:
162:                   case OPC_ACOF2:
163:                   case OPC_ACOF3:
164:           #endif
165:                       break;
166:                   default:
167:                       return NOT_PROCESSED;
168:               }
12E92  EE20     LFSR 2, 0x1
12E94  F001     NOP
12E96  5020     MOVF 0x20, W, ACCESS
12E98  26D9     ADDWF 0xFD9, F, ACCESS
12E9A  5021     MOVF 0x21, W, ACCESS
12E9C  22DA     ADDWFC 0xFDA, F, ACCESS
12E9E  50DF     MOVF 0xFDF, W, ACCESS
12EA0  6E22     MOVWF 0x22, ACCESS
12EA2  6A23     CLRF 0x23, ACCESS
12EA4  5023     MOVF 0x23, W, ACCESS
12EA6  0A00     XORLW 0x0
12EA8  A4D8     BTFSS 0xFD8, 2, ACCESS
12EAA  D7D7     BRA 0x2E5A
12EAC  5022     MOVF 0x22, W, ACCESS
12EAE  0A90     XORLW 0x90
12EB0  B4D8     BTFSC 0xFD8, 2, ACCESS
12EB2  D02E     BRA 0x2F10
12EB4  0A01     XORLW 0x1
12EB6  B4D8     BTFSC 0xFD8, 2, ACCESS
12EB8  D02B     BRA 0x2F10
12EBA  0A09     XORLW 0x9
12EBC  B4D8     BTFSC 0xFD8, 2, ACCESS
12EBE  D7E4     BRA 0x2E88
12EC0  0A01     XORLW 0x1
12EC2  B4D8     BTFSC 0xFD8, 2, ACCESS
12EC4  D7E1     BRA 0x2E88
12EC6  0A29     XORLW 0x29
12EC8  B4D8     BTFSC 0xFD8, 2, ACCESS
12ECA  D022     BRA 0x2F10
12ECC  0A01     XORLW 0x1
12ECE  B4D8     BTFSC 0xFD8, 2, ACCESS
12ED0  D01F     BRA 0x2F10
12ED2  0A09     XORLW 0x9
12ED4  B4D8     BTFSC 0xFD8, 2, ACCESS
12ED6  D7D8     BRA 0x2E88
12ED8  0A01     XORLW 0x1
12EDA  B4D8     BTFSC 0xFD8, 2, ACCESS
12EDC  D7D5     BRA 0x2E88
12EDE  0A69     XORLW 0x69
12EE0  B4D8     BTFSC 0xFD8, 2, ACCESS
12EE2  D016     BRA 0x2F10
12EE4  0A01     XORLW 0x1
12EE6  B4D8     BTFSC 0xFD8, 2, ACCESS
12EE8  D013     BRA 0x2F10
12EEA  0A09     XORLW 0x9
12EEC  B4D8     BTFSC 0xFD8, 2, ACCESS
12EEE  D7CC     BRA 0x2E88
12EF0  0A01     XORLW 0x1
12EF2  B4D8     BTFSC 0xFD8, 2, ACCESS
12EF4  D7C9     BRA 0x2E88
12EF6  0A29     XORLW 0x29
12EF8  B4D8     BTFSC 0xFD8, 2, ACCESS
12EFA  D00A     BRA 0x2F10
12EFC  0A01     XORLW 0x1
12EFE  B4D8     BTFSC 0xFD8, 2, ACCESS
12F00  D007     BRA 0x2F10
12F02  0A09     XORLW 0x9
12F04  B4D8     BTFSC 0xFD8, 2, ACCESS
12F06  D7C0     BRA 0x2E88
12F08  0A01     XORLW 0x1
12F0A  B4D8     BTFSC 0xFD8, 2, ACCESS
12F0C  D7BD     BRA 0x2E88
12F0E  D7A5     BRA 0x2E5A
169:               
170:               // events only here
171:               tableIndex = findEvent(enn, ((uint16_t)m->bytes[2])*256+m->bytes[3]);
12F10  C526     MOVFF data2, tableIndex
12F12  F519     NOP
12F14  C527     MOVFF data3, txFifoObj
12F16  F51A     NOP
12F18  EE20     LFSR 2, 0x5
12F1A  F005     NOP
12F1C  5020     MOVF 0x20, W, ACCESS
12F1E  26D9     ADDWF 0xFD9, F, ACCESS
12F20  5021     MOVF 0x21, W, ACCESS
12F22  22DA     ADDWFC 0xFDA, F, ACCESS
12F24  50DF     MOVF 0xFDF, W, ACCESS
12F26  6E22     MOVWF 0x22, ACCESS
12F28  EE20     LFSR 2, 0x4
12F2A  F004     NOP
12F2C  5020     MOVF 0x20, W, ACCESS
12F2E  26D9     ADDWF 0xFD9, F, ACCESS
12F30  5021     MOVF 0x21, W, ACCESS
12F32  22DA     ADDWFC 0xFDA, F, ACCESS
12F34  50DF     MOVF 0xFDF, W, ACCESS
12F36  6E23     MOVWF 0x23, ACCESS
12F38  5022     MOVF 0x22, W, ACCESS
12F3A  6E1B     MOVWF 0x1B, ACCESS
12F3C  C523     MOVFF data7, len
12F3E  F51C     NOP
12F40  ECA5     CALL 0x1574A, 0
12F42  F0AB     NOP
12F44  6E29     MOVWF 0x29, ACCESS
172:               if (tableIndex == NO_INDEX) return NOT_PROCESSED;
12F46  2829     INCF 0x29, W, ACCESS
12F48  B4D8     BTFSC 0xFD8, 2, ACCESS
12F4A  D787     BRA 0x2E5A
173:               if (APP_isProducedEvent(tableIndex)) { // can we produce this event?
12F4C  5029     MOVF 0x29, W, ACCESS
12F4E  ECBA     CALL 0x15D74, 0
12F50  F0AE     NOP
12F52  0900     IORLW 0x0
12F54  B4D8     BTFSC 0xFD8, 2, ACCESS
12F56  D781     BRA 0x2E5A
174:                   // If receive an event for a Toggle switch then update our outputState[]
175:                   ev = (uint8_t)getEv(tableIndex, EV_SWITCHSV);
12F58  0E02     MOVLW 0x2
12F5A  6E0E     MOVWF 0xE, ACCESS
12F5C  5029     MOVF 0x29, W, ACCESS
12F5E  ECCF     CALL 0x14F9E, 0
12F60  F0A7     NOP
12F62  500E     MOVF 0xE, W, ACCESS
12F64  6E25     MOVWF 0x25, ACCESS
176:                   if (ev & SV_TOGGLE) {
12F66  A625     BTFSS 0x25, 3, ACCESS
12F68  D778     BRA 0x2E5A
177:                       switchNo = (uint8_t)getEv(tableIndex, EV_SWITCHNO) - 1;
12F6A  0E01     MOVLW 0x1
12F6C  6E0E     MOVWF 0xE, ACCESS
12F6E  5029     MOVF 0x29, W, ACCESS
12F70  ECCF     CALL 0x14F9E, 0
12F72  F0A7     NOP
12F74  040E     DECF 0xE, W, ACCESS
12F76  6E28     MOVWF 0x28, ACCESS
178:                       if (switchNo < NUM_BUTTONS) {
12F78  0E20     MOVLW 0x20
12F7A  6028     CPFSLT 0x28, ACCESS
12F7C  D76E     BRA 0x2E5A
179:                           outputState[switchNo] = !(m->opc & 1);  // on or off
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
12F7E  0E20     MOVLW 0x20
180:                       }
181:                       return NOT_PROCESSED;   // Not processed as we want service to handle the event
182:                   }
183:               }
184:               return NOT_PROCESSED;
185:           }
186:           
187:           /**
188:            * Update the ledStates array for all the LEDs impacted by the event according 
189:            * to the event's EVs.
190:            * 
191:            * @param tableIndex the index of the event data
192:            * @param m event message pointer
193:            * @return 
194:            */
195:           Processed APP_processConsumedEvent(uint8_t tableIndex, Message *m) {
1296E  6E1E     MOVWF 0x1E, ACCESS
196:               uint8_t onOff;
197:               uint8_t ledMode;
198:               uint8_t ledNo;
199:               uint8_t flags;
200:               uint8_t polarity;
201:               
202:               onOff = !(m->opc & 1);
12970  EE20     LFSR 2, 0x1
12972  F001     NOP
12974  5019     MOVF 0x19, W, ACCESS
12976  26D9     ADDWF 0xFD9, F, ACCESS
12978  501A     MOVF 0x1A, W, ACCESS
1297A  22DA     ADDWFC 0xFDA, F, ACCESS
1297C  B0DF     BTFSC 0xFDF, 0, ACCESS
1297E  D002     BRA 0x2984
12980  0E01     MOVLW 0x1
12982  D001     BRA 0x2986
12984  0E00     MOVLW 0x0
12986  6E22     MOVWF 0x22, ACCESS
203:               if (getEVs(tableIndex)) {   
12988  501E     MOVF 0x1E, W, ACCESS
1298A  EC2D     CALL 0x14E5A, 0
1298C  F0A7     NOP
1298E  0900     IORLW 0x0
12990  B4D8     BTFSC 0xFD8, 2, ACCESS
12992  D002     BRA 0x2998
204:                   // something went wrong
205:                   return PROCESSED;
12994  0E01     MOVLW 0x1
12996  0012     RETURN 0
206:               }
207:               if (onOff && ((evs[EV_TYPE] == CANPAN_SOD)||(evs[EV_TYPE] == CANPAN_SELF_SOD))) {
12998  5022     MOVF 0x22, W, ACCESS
1299A  B4D8     BTFSC 0xFD8, 2, ACCESS
1299C  D00C     BRA 0x29B6
1299E  0E02     MOVLW 0x2
129A0  0106     MOVLB 0x6
129A2  1950     XORWF 0x50, W, BANKED
129A4  B4D8     BTFSC 0xFD8, 2, ACCESS
129A6  D004     BRA 0x29B0
129A8  0E03     MOVLW 0x3
129AA  1950     XORWF 0x50, W, BANKED
129AC  A4D8     BTFSS 0xFD8, 2, ACCESS
129AE  D003     BRA 0x29B6
208:                   doSoD();
129B0  ECBB     CALL 0x16176, 0
129B2  F0B0     NOP
129B4  D7EF     BRA 0x2994
209:                   return PROCESSED;
210:               }
211:               // using the EVs and the event on/off state we work out the new LED state
212:               ledMode = evs[EV_LEDMODE];
129B6  C65C     MOVFF 0x65C, data3
129B8  F51F     NOP
213:               for (ledNo=0; ledNo<NUM_LEDS; ledNo++) {
129BA  0E00     MOVLW 0x0
129BC  6E23     MOVWF 0x23, ACCESS
214:                   flags = evs[EV_LEDFLAGS1 + ledNo/8] & (1 << (ledNo%8));
129BE  C523     MOVFF data7, i
129C0  F502     NOP
129C2  6A03     CLRF __activetblptr, ACCESS
129C4  0E00     MOVLW 0x0
129C6  6E05     MOVWF 0x5, ACCESS
129C8  0E08     MOVLW 0x8
129CA  6E04     MOVWF __activetblptr, ACCESS
129CC  EC77     CALL 0x146EE, 0
129CE  F0A3     NOP
129D0  0E54     MOVLW 0x54
129D2  2402     ADDWF ___rparam_used, W, ACCESS
129D4  6ED9     MOVWF 0xFD9, ACCESS
129D6  0E06     MOVLW 0x6
129D8  2003     ADDWFC __activetblptr, W, ACCESS
129DA  6EDA     MOVWF 0xFDA, ACCESS
129DC  50DF     MOVF 0xFDF, W, ACCESS
129DE  6E1B     MOVWF 0x1B, ACCESS
129E0  C523     MOVFF data7, len
129E2  F51C     NOP
129E4  0E07     MOVLW 0x7
129E6  161C     ANDWF 0x1C, F, ACCESS
129E8  0E01     MOVLW 0x1
129EA  6E1D     MOVWF 0x1D, ACCESS
129EC  2A1C     INCF 0x1C, F, ACCESS
129EE  D002     BRA 0x29F4
129F0  90D8     BCF 0xFD8, 0, ACCESS
129F2  361D     RLCF 0x1D, F, ACCESS
129F4  2E1C     DECFSZ 0x1C, F, ACCESS
129F6  D7FC     BRA 0x29F0
129F8  501D     MOVF 0x1D, W, ACCESS
129FA  141B     ANDWF 0x1B, W, ACCESS
129FC  6E20     MOVWF 0x20, ACCESS
215:                   if (flags) {
129FE  5020     MOVF 0x20, W, ACCESS
12A00  B4D8     BTFSC 0xFD8, 2, ACCESS
12A02  D08B     BRA 0x2B1A
216:                       // this LED is impacted
217:                       polarity = evs[EV_LEDPOLARITY1 + ledNo/8]& (1 << (ledNo%8));
12A04  C523     MOVFF data7, i
12A06  F502     NOP
12A08  6A03     CLRF __activetblptr, ACCESS
12A0A  0E00     MOVLW 0x0
12A0C  6E05     MOVWF 0x5, ACCESS
12A0E  0E08     MOVLW 0x8
12A10  6E04     MOVWF __activetblptr, ACCESS
12A12  EC77     CALL 0x146EE, 0
12A14  F0A3     NOP
12A16  0E58     MOVLW 0x58
12A18  2402     ADDWF ___rparam_used, W, ACCESS
12A1A  6ED9     MOVWF 0xFD9, ACCESS
12A1C  0E06     MOVLW 0x6
12A1E  2003     ADDWFC __activetblptr, W, ACCESS
12A20  6EDA     MOVWF 0xFDA, ACCESS
12A22  50DF     MOVF 0xFDF, W, ACCESS
12A24  6E1B     MOVWF 0x1B, ACCESS
12A26  C523     MOVFF data7, len
12A28  F51C     NOP
12A2A  0E07     MOVLW 0x7
12A2C  161C     ANDWF 0x1C, F, ACCESS
12A2E  0E01     MOVLW 0x1
12A30  6E1D     MOVWF 0x1D, ACCESS
12A32  2A1C     INCF 0x1C, F, ACCESS
12A34  D002     BRA 0x2A3A
12A36  90D8     BCF 0xFD8, 0, ACCESS
12A38  361D     RLCF 0x1D, F, ACCESS
12A3A  2E1C     DECFSZ 0x1C, F, ACCESS
12A3C  D7FC     BRA 0x2A36
12A3E  501D     MOVF 0x1D, W, ACCESS
12A40  141B     ANDWF 0x1B, W, ACCESS
12A42  6E21     MOVWF 0x21, ACCESS
218:                       switch(ledMode) {
12A44  D05D     BRA 0x2B00
219:                           case LM_ONOFF:
220:                               if (polarity) {
12A46  5021     MOVF 0x21, W, ACCESS
12A48  B4D8     BTFSC 0xFD8, 2, ACCESS
12A4A  D00F     BRA 0x2A6A
221:                                   // inverted
222:                                   if (onOff) {
12A4C  5022     MOVF 0x22, W, ACCESS
12A4E  B4D8     BTFSC 0xFD8, 2, ACCESS
12A50  D006     BRA 0x2A5E
223:                                       setLedState(ledNo, CANPANLED_OFF);
12A52  0E01     MOVLW 0x1
12A54  6E0E     MOVWF 0xE, ACCESS
12A56  5023     MOVF 0x23, W, ACCESS
12A58  EC89     CALL 0x15512, 0
12A5A  F0AA     NOP
224:                                   } else {
12A5C  D05E     BRA 0x2B1A
225:                                       setLedState(ledNo, CANPANLED_ON);
12A5E  0E00     MOVLW 0x0
12A60  6E0E     MOVWF 0xE, ACCESS
12A62  5023     MOVF 0x23, W, ACCESS
12A64  EC89     CALL 0x15512, 0
12A66  F0AA     NOP
12A68  D058     BRA 0x2B1A
226:                                   }
227:                                   
228:                               } else {
229:                                   // normal
230:                                   if (onOff) {
12A6A  5022     MOVF 0x22, W, ACCESS
12A6C  B4D8     BTFSC 0xFD8, 2, ACCESS
12A6E  D006     BRA 0x2A7C
231:                                       setLedState(ledNo, CANPANLED_ON);
12A70  0E00     MOVLW 0x0
12A72  6E0E     MOVWF 0xE, ACCESS
12A74  5023     MOVF 0x23, W, ACCESS
12A76  EC89     CALL 0x15512, 0
12A78  F0AA     NOP
232:                                   } else {
12A7A  D04F     BRA 0x2B1A
233:                                       setLedState(ledNo, CANPANLED_OFF);
12A7C  0E01     MOVLW 0x1
12A7E  6E0E     MOVWF 0xE, ACCESS
12A80  5023     MOVF 0x23, W, ACCESS
12A82  EC89     CALL 0x15512, 0
12A84  F0AA     NOP
12A86  D049     BRA 0x2B1A
234:                                   }
235:                               }
236:                               break;
237:                           case LM_ONONLY:
238:                               if (onOff) {
12A88  5022     MOVF 0x22, W, ACCESS
12A8A  B4D8     BTFSC 0xFD8, 2, ACCESS
12A8C  D046     BRA 0x2B1A
239:                                   if (polarity) {
12A8E  5021     MOVF 0x21, W, ACCESS
12A90  B4D8     BTFSC 0xFD8, 2, ACCESS
12A92  D006     BRA 0x2AA0
240:                                       setLedState(ledNo, CANPANLED_OFF);
12A94  0E01     MOVLW 0x1
12A96  6E0E     MOVWF 0xE, ACCESS
12A98  5023     MOVF 0x23, W, ACCESS
12A9A  EC89     CALL 0x15512, 0
12A9C  F0AA     NOP
241:                                   } else {
12A9E  D03D     BRA 0x2B1A
242:                                       setLedState(ledNo, CANPANLED_ON);
12AA0  0E00     MOVLW 0x0
12AA2  6E0E     MOVWF 0xE, ACCESS
12AA4  5023     MOVF 0x23, W, ACCESS
12AA6  EC89     CALL 0x15512, 0
12AA8  F0AA     NOP
12AAA  D037     BRA 0x2B1A
243:                                   }
244:                               }
245:                               break;
246:                           case LM_OFFONLY:
247:                               if (!onOff) {
12AAC  5022     MOVF 0x22, W, ACCESS
12AAE  A4D8     BTFSS 0xFD8, 2, ACCESS
12AB0  D034     BRA 0x2B1A
248:                                   if (polarity) {
12AB2  5021     MOVF 0x21, W, ACCESS
12AB4  B4D8     BTFSC 0xFD8, 2, ACCESS
12AB6  D006     BRA 0x2AC4
249:                                       setLedState(ledNo, CANPANLED_ON);
12AB8  0E00     MOVLW 0x0
12ABA  6E0E     MOVWF 0xE, ACCESS
12ABC  5023     MOVF 0x23, W, ACCESS
12ABE  EC89     CALL 0x15512, 0
12AC0  F0AA     NOP
250:                                   } else {
12AC2  D02B     BRA 0x2B1A
251:                                       setLedState(ledNo, CANPANLED_OFF);
12AC4  0E01     MOVLW 0x1
12AC6  6E0E     MOVWF 0xE, ACCESS
12AC8  5023     MOVF 0x23, W, ACCESS
12ACA  EC89     CALL 0x15512, 0
12ACC  F0AA     NOP
12ACE  D025     BRA 0x2B1A
252:                                   }
253:                               }
254:                               break;
255:                           case LM_FLASH:
256:                               if (onOff) {
12AD0  5022     MOVF 0x22, W, ACCESS
12AD2  B4D8     BTFSC 0xFD8, 2, ACCESS
12AD4  D00F     BRA 0x2AF4
257:                                   if (polarity) {
12AD6  5021     MOVF 0x21, W, ACCESS
12AD8  B4D8     BTFSC 0xFD8, 2, ACCESS
12ADA  D006     BRA 0x2AE8
258:                                       setLedState(ledNo, CANPANLED_ANTIFLASH);
12ADC  0E03     MOVLW 0x3
12ADE  6E0E     MOVWF 0xE, ACCESS
12AE0  5023     MOVF 0x23, W, ACCESS
12AE2  EC89     CALL 0x15512, 0
12AE4  F0AA     NOP
259:                                   } else {
12AE6  D019     BRA 0x2B1A
260:                                       setLedState(ledNo, CANPANLED_FLASH);
12AE8  0E02     MOVLW 0x2
12AEA  6E0E     MOVWF 0xE, ACCESS
12AEC  5023     MOVF 0x23, W, ACCESS
12AEE  EC89     CALL 0x15512, 0
12AF0  F0AA     NOP
12AF2  D013     BRA 0x2B1A
261:                                   }
262:                               } else {
263:                                   setLedState(ledNo, CANPANLED_OFF);
12AF4  0E01     MOVLW 0x1
12AF6  6E0E     MOVWF 0xE, ACCESS
12AF8  5023     MOVF 0x23, W, ACCESS
12AFA  EC89     CALL 0x15512, 0
12AFC  F0AA     NOP
12AFE  D00D     BRA 0x2B1A
264:                               }
265:                               break;
266:                       }
12B00  501F     MOVF 0x1F, W, ACCESS
12B02  0AF8     XORLW 0xF8
12B04  B4D8     BTFSC 0xFD8, 2, ACCESS
12B06  D7E4     BRA 0x2AD0
12B08  0A05     XORLW 0x5
12B0A  B4D8     BTFSC 0xFD8, 2, ACCESS
12B0C  D7CF     BRA 0x2AAC
12B0E  0A03     XORLW 0x3
12B10  B4D8     BTFSC 0xFD8, 2, ACCESS
12B12  D7BA     BRA 0x2A88
12B14  0A01     XORLW 0x1
12B16  B4D8     BTFSC 0xFD8, 2, ACCESS
12B18  D796     BRA 0x2A46
267:                   }
268:               }
12B1A  2A23     INCF 0x23, F, ACCESS
12B1A  2A23     INCF 0x23, F, ACCESS
12B1A  2A23     INCF 0x23, F, ACCESS
12B1A  2A23     INCF 0x23, F, ACCESS
12B1A  2A23     INCF 0x23, F, ACCESS
269:               return PROCESSED;
270:           }
271:           
272:           
273:           /**
274:            * Gets the current event state of a produced event by table index.
275:            * @param tableIndex
276:            * @return 
277:            */
278:           EventState APP_GetEventIndexState(uint8_t tableIndex) {
15872  6E1D     MOVWF 0x1D, ACCESS
279:               uint8_t switchNo;
280:               
281:               // check this is a produced event
282:               if ( ! APP_isProducedEvent(tableIndex)) {
15874  501D     MOVF 0x1D, W, ACCESS
15876  ECBA     CALL 0x15D74, 0
15878  F0AE     NOP
1587A  0900     IORLW 0x0
1587C  A4D8     BTFSS 0xFD8, 2, ACCESS
1587E  D002     BRA 0x5884
283:                   return EVENT_UNKNOWN;
15880  0EFF     MOVLW 0xFF
15882  0012     RETURN 0
284:               }
285:               // get the switch number
286:               getEVs(tableIndex);
15884  501D     MOVF 0x1D, W, ACCESS
15886  EC2D     CALL 0x14E5A, 0
15888  F0A7     NOP
287:               switchNo = evs[EV_SWITCHNO];
1588A  C651     MOVFF 0x651, data2
1588C  F51E     NOP
288:               if ((switchNo < 1) || (switchNo > NUM_BUTTONS)) {
1588E  501E     MOVF 0x1E, W, ACCESS
15890  B4D8     BTFSC 0xFD8, 2, ACCESS
15892  D7F6     BRA 0x5880
15894  0E20     MOVLW 0x20
15896  641E     CPFSGT 0x1E, ACCESS
15898  D001     BRA 0x589C
1589A  D7F2     BRA 0x5880
289:                   return EVENT_UNKNOWN;
290:               }
291:               // look at the state
292:               return outputState[switchNo-1] ? EVENT_ON : EVENT_OFF;
1589C  0E1F     MOVLW 0x1F
1589E  241E     ADDWF 0x1E, W, ACCESS
158A0  6ED9     MOVWF 0xFD9, ACCESS
158A2  6ADA     CLRF 0xFDA, ACCESS
158A4  0E06     MOVLW 0x6
158A6  22DA     ADDWFC 0xFDA, F, ACCESS
158A8  50DF     MOVF 0xFDF, W, ACCESS
158AA  B4D8     BTFSC 0xFD8, 2, ACCESS
158AC  D002     BRA 0x58B2
158AE  0E01     MOVLW 0x1
158B0  0012     RETURN 0
158B2  0E00     MOVLW 0x0
293:           }
158B4  0012     RETURN 0
---  C:/Users/ianwh/AppData/Local/Temp/xcAs1ds8/driver_tmp_1.s  -----------------------------------------
1582A  0EA2     MOVLW 0xA2
1582C  6EF6     MOVWF 0xFF6, ACCESS
1582E  0E62     MOVLW 0x62
15830  6EF7     MOVWF 0xFF7, ACCESS
15832  0E01     MOVLW 0x1
15834  6EF8     MOVWF 0xFF8, ACCESS
15836  0009     TBLRD*+
15838  C4F5     MOVFF TABLAT, __pdataBANK5
1583C  0009     TBLRD*+
1583E  C4F5     MOVFF TABLAT, 0x5FC
15842  EE01     LFSR 0, 0x600
15846  0EE0     MOVLW 0xE0
15848  6AEE     CLRF 0xFEE, ACCESS
1584A  06E8     DECF 0xFE8, F, ACCESS
1584C  E1FD     BNZ 0x5848
1584E  EE01     LFSR 0, 0x560
15852  0E80     MOVLW 0x80
15854  6AEE     CLRF 0xFEE, ACCESS
15856  06E8     DECF 0xFE8, F, ACCESS
15858  E1FD     BNZ 0x5854
1585A  6A54     CLRF 0x54, ACCESS
1585C  6A53     CLRF 0x53, ACCESS
1585E  0104     MOVLB 0x4
15860  0E00     MOVLW 0x0
15862  6F5D     MOVWF 0x5D, BANKED
15864  0E09     MOVLW 0x9
15866  6F5E     MOVWF 0x5E, BANKED
15868  0E00     MOVLW 0x0
1586A  6F5F     MOVWF 0x5F, BANKED
1586C  0100     MOVLB 0x0
1586E  EF04     GOTO 0x15008
---  C:/Program Files/Microchip/xc8/v2.46/pic/sources/c99/common/memcpy.c  ------------------------------
1:             #include <stdlib.h>
2:             
3:             void *
4:             memcpy(void * d1, const void * s1, register size_t n)
5:             {
6:             
7:             	register char *		d;
8:             	register const char *	s;
9:             	register unsigned char tmp;
10:            
11:            	s = s1;
158B6  C504     MOVFF s, index
158B8  F50B     NOP
158BA  C505     MOVFF i, txWaiting
158BC  F50C     NOP
12:            	d = d1;
158BE  C502     MOVFF i, d
158C0  F509     NOP
158C2  C503     MOVFF opc, index
158C4  F50A     NOP
13:            	while(n--) {
158C6  D010     BRA 0x58E8
158E8  0606     DECF 0x6, F, ACCESS
158EA  A0D8     BTFSS 0xFD8, 0, ACCESS
158EC  0607     DECF 0x7, F, ACCESS
158EE  2806     INCF 0x6, W, ACCESS
158F0  E1EB     BNZ 0x58C8
158F2  2807     INCF 0x7, W, ACCESS
158F4  B4D8     BTFSC 0xFD8, 2, ACCESS
158F6  0012     RETURN 0
14:            		tmp = *s++;
158C8  C50B     MOVFF index, FSR2
158CA  F4D9     NOP
158CC  C50C     MOVFF txWaiting, FSR2H
158CE  F4DA     NOP
158D0  50DF     MOVF 0xFDF, W, ACCESS
158D2  6E08     MOVWF 0x8, ACCESS
158D4  4A0B     INFSNZ 0xB, F, ACCESS
158D6  2A0C     INCF 0xC, F, ACCESS
15:            		*d++ = tmp;
158D8  C509     MOVFF d, FSR2
158DA  F4D9     NOP
158DC  C50A     MOVFF index, FSR2H
158DE  F4DA     NOP
158E0  C508     MOVFF index, INDF2
158E2  F4DF     NOP
158E4  4A09     INFSNZ 0x9, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
158E6  2A0A     INCF 0xA, F, ACCESS
16:            	}
17:            	return d1;
18:            }
19:            
---  C:/Program Files/Microchip/xc8/v2.46/pic/sources/c99/common/awdiv.c  -------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
146EE  0E00     MOVLW 0x0
146F0  6E07     MOVWF 0x7, ACCESS
14:            	if(divisor < 0) {
146F2  AE05     BTFSS 0x5, 7, ACCESS
146F4  D006     BRA 0x4702
15:            		divisor = -divisor;
146F6  6C04     NEGF __activetblptr, ACCESS
146F8  1E05     COMF 0x5, F, ACCESS
146FA  B0D8     BTFSC 0xFD8, 0, ACCESS
146FC  2A05     INCF 0x5, F, ACCESS
16:            		sign = 1;
146FE  0E01     MOVLW 0x1
14700  6E07     MOVWF 0x7, ACCESS
17:            	}
18:            	if(dividend < 0) {
14702  AE03     BTFSS __activetblptr, 7, ACCESS
14704  D006     BRA 0x4712
19:            		dividend = -dividend;
14706  6C02     NEGF ___rparam_used, ACCESS
14708  1E03     COMF __activetblptr, F, ACCESS
1470A  B0D8     BTFSC 0xFD8, 0, ACCESS
1470C  2A03     INCF __activetblptr, F, ACCESS
20:            		sign ^= 1;
1470E  0E01     MOVLW 0x1
14710  1A07     XORWF 0x7, F, ACCESS
21:            	}
22:            	quotient = 0;
14712  0E00     MOVLW 0x0
14714  6E09     MOVWF 0x9, ACCESS
14716  0E00     MOVLW 0x0
14718  6E08     MOVWF 0x8, ACCESS
23:            	if(divisor != 0) {
1471A  5004     MOVF __activetblptr, W, ACCESS
1471C  1005     IORWF 0x5, W, ACCESS
1471E  B4D8     BTFSC 0xFD8, 2, ACCESS
14720  D01C     BRA 0x475A
24:            		counter = 1;
14722  0E01     MOVLW 0x1
14724  6E06     MOVWF 0x6, ACCESS
25:            		while(((unsigned int)divisor & 0x8000U) == 0) {
14726  D004     BRA 0x4730
14730  AE05     BTFSS 0x5, 7, ACCESS
14732  D7FA     BRA 0x4728
26:            			divisor <<= 1;
14728  90D8     BCF 0xFD8, 0, ACCESS
1472A  3604     RLCF __activetblptr, F, ACCESS
1472C  3605     RLCF 0x5, F, ACCESS
27:            			counter++;
1472E  2A06     INCF 0x6, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
14734  90D8     BCF 0xFD8, 0, ACCESS
14736  3608     RLCF 0x8, F, ACCESS
14738  3609     RLCF 0x9, F, ACCESS
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
1473A  5004     MOVF __activetblptr, W, ACCESS
1473C  5C02     SUBWF ___rparam_used, W, ACCESS
1473E  5005     MOVF 0x5, W, ACCESS
14740  5803     SUBWFB __activetblptr, W, ACCESS
14742  A0D8     BTFSS 0xFD8, 0, ACCESS
14744  D005     BRA 0x4750
32:            				dividend -= divisor;
14746  5004     MOVF __activetblptr, W, ACCESS
14748  5E02     SUBWF ___rparam_used, F, ACCESS
1474A  5005     MOVF 0x5, W, ACCESS
1474C  5A03     SUBWFB __activetblptr, F, ACCESS
33:            				quotient |= 1;
1474E  8008     BSF 0x8, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
14750  90D8     BCF 0xFD8, 0, ACCESS
14752  3205     RRCF 0x5, F, ACCESS
14754  3204     RRCF __activetblptr, F, ACCESS
36:            		} while(--counter != 0);
14756  2E06     DECFSZ 0x6, F, ACCESS
14758  D7ED     BRA 0x4734
37:            	}
38:            	if(sign)
1475A  5007     MOVF 0x7, W, ACCESS
1475C  B4D8     BTFSC 0xFD8, 2, ACCESS
1475E  D004     BRA 0x4768
39:            		quotient = -quotient;
14760  6C08     NEGF 0x8, ACCESS
14762  1E09     COMF 0x9, F, ACCESS
14764  B0D8     BTFSC 0xFD8, 0, ACCESS
14766  2A09     INCF 0x9, F, ACCESS
40:            	return quotient;
14768  C508     MOVFF index, i
1476A  F502     NOP
1476C  C509     MOVFF d, opc
1476E  F503     NOP
41:            }
14770  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.46/pic/sources/c99/common/__lldiv.c  -----------------------------
1:             // long unsigned unsigned division
2:             
3:             unsigned long int
4:             #ifdef __PICC__
5:             __lldiv(unsigned long int divisor, unsigned long int dividend)
6:             #else
7:             __lldiv(unsigned long int dividend, unsigned long int divisor)
8:             #endif
9:             {
10:            	unsigned long int	quotient;
11:            	unsigned char	counter;
12:            
13:            	quotient = 0;
147F4  0E00     MOVLW 0x0
147F6  6E14     MOVWF 0x14, ACCESS
147F8  0E00     MOVLW 0x0
147FA  6E15     MOVWF 0x15, ACCESS
147FC  0E00     MOVLW 0x0
147FE  6E16     MOVWF 0x16, ACCESS
14800  0E00     MOVLW 0x0
14802  6E17     MOVWF 0x17, ACCESS
14:            	if(divisor != 0) {
14804  5010     MOVF 0x10, W, ACCESS
14806  1011     IORWF 0x11, W, ACCESS
14808  1012     IORWF 0x12, W, ACCESS
1480A  1013     IORWF 0x13, W, ACCESS
1480C  B4D8     BTFSC 0xFD8, 2, ACCESS
1480E  D02A     BRA 0x4864
15:            		counter = 1;
14810  0E01     MOVLW 0x1
14812  6E18     MOVWF 0x18, ACCESS
16:            		while((divisor & 0x80000000UL) == 0) {
14814  D006     BRA 0x4822
14822  AE13     BTFSS 0x13, 7, ACCESS
14824  D7F8     BRA 0x4816
17:            			divisor <<= 1;
14816  90D8     BCF 0xFD8, 0, ACCESS
14818  3610     RLCF 0x10, F, ACCESS
1481A  3611     RLCF 0x11, F, ACCESS
1481C  3612     RLCF 0x12, F, ACCESS
1481E  3613     RLCF 0x13, F, ACCESS
18:            			counter++;
14820  2A18     INCF 0x18, F, ACCESS
19:            		}
20:            		do {
21:            			quotient <<= 1;
14826  90D8     BCF 0xFD8, 0, ACCESS
14828  3614     RLCF 0x14, F, ACCESS
1482A  3615     RLCF 0x15, F, ACCESS
1482C  3616     RLCF 0x16, F, ACCESS
1482E  3617     RLCF 0x17, F, ACCESS
22:            			if(divisor <= dividend) {
14830  5010     MOVF 0x10, W, ACCESS
14832  5C0C     SUBWF 0xC, W, ACCESS
14834  5011     MOVF 0x11, W, ACCESS
14836  580D     SUBWFB 0xD, W, ACCESS
14838  5012     MOVF 0x12, W, ACCESS
1483A  580E     SUBWFB 0xE, W, ACCESS
1483C  5013     MOVF 0x13, W, ACCESS
1483E  580F     SUBWFB 0xF, W, ACCESS
14840  A0D8     BTFSS 0xFD8, 0, ACCESS
14842  D009     BRA 0x4856
23:            				dividend -= divisor;
14844  5010     MOVF 0x10, W, ACCESS
14846  5E0C     SUBWF 0xC, F, ACCESS
14848  5011     MOVF 0x11, W, ACCESS
1484A  5A0D     SUBWFB 0xD, F, ACCESS
1484C  5012     MOVF 0x12, W, ACCESS
1484E  5A0E     SUBWFB 0xE, F, ACCESS
14850  5013     MOVF 0x13, W, ACCESS
14852  5A0F     SUBWFB 0xF, F, ACCESS
24:            				quotient |= 1;
14854  8014     BSF 0x14, 0, ACCESS
25:            			}
26:            			divisor >>= 1;
14856  90D8     BCF 0xFD8, 0, ACCESS
14858  3213     RRCF 0x13, F, ACCESS
1485A  3212     RRCF 0x12, F, ACCESS
1485C  3211     RRCF 0x11, F, ACCESS
1485E  3210     RRCF 0x10, F, ACCESS
27:            		} while(--counter != 0);
14860  2E18     DECFSZ 0x18, F, ACCESS
14862  D7E1     BRA 0x4826
28:            	}
29:            	return quotient;
14864  C514     MOVFF incomingCanId, txWaiting
14866  F50C     NOP
14868  C515     MOVFF lo, i
1486A  F50D     NOP
1486C  C516     MOVFF i, evNum
1486E  F50E     NOP
14870  C517     MOVFF tableIndex, interruptEnabled
14872  F50F     NOP
30:            }
14874  0012     RETURN 0
---  C:/Program Files/Microchip/xc8/v2.46/pic/sources/c99/common/Umul32.c  ------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
15568  0E00     MOVLW 0x0
1556A  6E0A     MOVWF 0xA, ACCESS
1556C  0E00     MOVLW 0x0
1556E  6E0B     MOVWF 0xB, ACCESS
15570  0E00     MOVLW 0x0
15572  6E0C     MOVWF 0xC, ACCESS
15574  0E00     MOVLW 0x0
15576  6E0D     MOVWF 0xD, ACCESS
120:           	do {
121:           		if(multiplier & 1)
15578  A002     BTFSS ___rparam_used, 0, ACCESS
1557A  D008     BRA 0x558C
122:           			product += multiplicand;
1557C  5006     MOVF 0x6, W, ACCESS
1557E  260A     ADDWF 0xA, F, ACCESS
15580  5007     MOVF 0x7, W, ACCESS
15582  220B     ADDWFC 0xB, F, ACCESS
15584  5008     MOVF 0x8, W, ACCESS
15586  220C     ADDWFC 0xC, F, ACCESS
15588  5009     MOVF 0x9, W, ACCESS
1558A  220D     ADDWFC 0xD, F, ACCESS
123:           		multiplicand <<= 1;
1558C  90D8     BCF 0xFD8, 0, ACCESS
1558E  3606     RLCF 0x6, F, ACCESS
15590  3607     RLCF 0x7, F, ACCESS
15592  3608     RLCF 0x8, F, ACCESS
15594  3609     RLCF 0x9, F, ACCESS
124:           		multiplier >>= 1;
15596  90D8     BCF 0xFD8, 0, ACCESS
15598  3205     RRCF 0x5, F, ACCESS
1559A  3204     RRCF __activetblptr, F, ACCESS
1559C  3203     RRCF __activetblptr, F, ACCESS
1559E  3202     RRCF ___rparam_used, F, ACCESS
125:           	} while(multiplier != 0);
155A0  5002     MOVF ___rparam_used, W, ACCESS
155A2  1003     IORWF __activetblptr, W, ACCESS
155A4  1004     IORWF __activetblptr, W, ACCESS
155A6  1005     IORWF 0x5, W, ACCESS
155A8  A4D8     BTFSS 0xFD8, 2, ACCESS
155AA  D7E6     BRA 0x5578
126:           
127:           #endif
128:           	return product;
155AC  C50A     MOVFF index, i
155AE  F502     NOP
155B0  C50B     MOVFF index, opc
155B2  F503     NOP
155B4  C50C     MOVFF txWaiting, s
155B6  F504     NOP
155B8  C50D     MOVFF i, i
155BA  F505     NOP
129:           }
155BC  0012     RETURN 0
---  C:/Users/ianwh/github/CBUS_PIC_Bootloader/main.c  --------------------------------------------------
1:             /*
2:             
3:              Copyright (C) Ian Hogg
4:             
5:              Routines for CBUS event management - part of CBUS libraries for PIC 18F
6:             
7:               This work is licensed under the:
8:                   Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
9:                To view a copy of this license, visit:
10:                  http://creativecommons.org/licenses/by-nc-sa/4.0/
11:               or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
12:            
13:               License summary:
14:                You are free to:
15:                  Share, copy and redistribute the material in any medium or format
16:                  Adapt, remix, transform, and build upon the material
17:            
18:                The licensor cannot revoke these freedoms as long as you follow the license terms.
19:            
20:                Attribution : You must give appropriate credit, provide a link to the license,
21:                               and indicate if changes were made. You may do so in any reasonable manner,
22:                               but not in any way that suggests the licensor endorses you or your use.
23:            
24:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
25:            
26:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
27:                              your contributions under the same license as the original.
28:            
29:                No additional restrictions : You may not apply legal terms or technological measures that
30:                                              legally restrict others from doing anything the license permits.
31:            
32:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
33:            
34:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
35:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
36:            
37:            **************************************************************************************************************
38:              Note:   This source code has been written using a tab stop and indentation setting
39:                      of 4 characters. To see everything lined up correctly, please set your
40:                      IDE or text editor to the same settings.
41:            ******************************************************************************************************/
42:            
43:             /**
44:             * @file
45:             * CBUS bootloader
46:             *
47:             *	Based on the Microchip bootloader 'canio.asm' tho which full acknowledgement is made.
48:             *	Relevant information is contained in the Microchip Application note AN247
49:             *
50:             *   This part of the CBUS firmware is distributed under the Microchip
51:             *   license which requires that it is only used on Microchip hardware.
52:             *   See page 15 of <http:\\ww1.microchip.com/downloads/en/AppNotes/00247a.pdf>
53:             *   for details of the Microchip licensing.  This bootloader is distributed with
54:             *   the CBUS software as a "system library" as defined in section 1 of the GNU Public
55:             *   license and is not licensed under GNU or Creative Commons.
56:             *   You must conform to Microchip license terms in respect of the bootloader.
57:             *
58:             * @details
59:             * Basic Operation:
60:             * The following is a CAN bootloader designed for PIC18F microcontrollers
61:             * with built-in CAN such as the PIC18F458. The bootloader is designed to
62:             * be simple, small, flexible, and portable. The bootloader resides within the 
63:             * bottom 2K bytes (0x0 ~ 0x07FF) of Flash memory. The processor's reset vector
64:             * points to the start of the bootloader. Upon reset the bootloader checks the
65:             * top address of EEPROM and if this is zero control is then passed to the user
66:             * application at address 0x800.
67:             * The user application should be compiled with option --CODEOFFSET=0x800 so that 
68:             * the compiler places its reset and interrupt vectors starting at 0x800.
69:             * If the top EEPROM address is non zero then control continues within the 
70:             * bootloader which awaits commands from the CAN interface.
71:             * The bootloader uses 29bit extended ids to carry the command and control
72:             * information.
73:             * 
74:             * 
75:             * Commands:
76:             * Put commands received from source (Master --> Slave)
77:             * The count (DLC) can vary.
78:             *                   RXB0EIDH RXB0EIDL RXB0D0 RXB0D1 RXB0D2 RXB0D3 RXB0D4 RXB0D5 RXB0D6 RXB0D7
79:             * XXXXXXXXXXX 0 0 8 XXXXXXXX XXXXXX00 ADDRL  ADDRH  ADDRU  RESVD  CTLBT  SPCMD  CPDTL  CPDTH
80:             * XXXXXXXXXXX 0 0 8 XXXXXXXX XXXXXX01 DATA0  DATA1  DATA2  DATA3  DATA4  DATA5  DATA6  DATA7
81:             *
82:             *
83:             * ADDRL - Bits 0 to 7 of the memory pointer.
84:             * ADDRH - Bits 8 - 15 of the memory pointer.
85:             * ADDRU - Bits 16 - 23 of the memory pointer.
86:             * RESVD - Reserved for future use.
87:             * CTLBT - Control bits. See MODE_ defines
88:             * SPCMD - Special command. See CMD_ defines
89:             * CPDTL - Bits 0 - 7 of 2s complement checksum
90:             * CPDTH - Bits 8 - 15 of 2s complement checksum
91:             * DATAX - General data.
92:             *
93:             * Control bits:
94:             * MODE_WRT_UNLCK  1  -Set this to allow write and erase operations to memory.
95:             * MODE_ERASE_ONLY 2  -Set this to only erase Program Memory on a put command. Must be on 64-byte
96:             *	boundary.
97:             * MODE_AUTO_ERASE 4  -Set this to automatically erase Program Memory while writing data.
98:             * MODE_AUTO_INC   8  -Set this to automatically increment the pointer after writing.
99:             * MODE_ACK       10  -Set this to generate an acknowledge after a 'put' (PG Mode only)
100:            *
101:            * Special Commands:
102:            * CMD_NOP			0x00	Do nothing, no response
103:            * CMD_RESET		0x01	Issue a soft reset after setting last EEPROM data to 0x00, no response
104:            * CMD_RST_CHKSM 	0x02	Reset the checksum counter and error status flags, no response
105:            * CMD_CHK_RUN		0x03	Check the checksum. reply with ok or nok.
106:            * CMD_BOOT_TEST 	0x04	Just sends a BOOT response message frame back to verify boot mode.
107:            * 
108:            * Responses:
109:            * RESPONSE_NOK     0x00
110:            * RESPONSE_OK      0x01
111:            * RESPONSE_BOOT    0x02
112:            * 
113:            * The control register set contains a pointer, some control bits and special command registers.
114:            * Control
115:            *   <PG><CD><ADDRL><ADDRH><ADDRU><_RES_><CTLBT><SPCMD><CPDTL><CPDTH>
116:            * Data
117:            *   <PG><CD><DATA0><DATA1><DATA2><DATA3><DATA4><DATA5><DATA6><DATA7>
118:            *  PG bit:	Put = 0, Get = 1
119:            *  CD bit:	Control = 0, Data = 1
120:            * 
121:            * Typical sequence:
122:            * -> CBUS RQNPN
123:            * -> CBUS BOOTM
124:            * -> Control, 0x000000 Boot test (AUTO_INC, AUTO_ERASE, UNLOCK)
125:            * <- OK
126:            * -> Control, 0x000800 Reset checksum (AUTO_INC, AUTO_ERASE, UNLOCK)
127:            * -> Put Data, data bytes
128:            * -> Put Data, data bytes
129:            * -> Control, 0x300000  (AUTO_INC, AUTO_ERASE, UNLOCK)
130:            * -> Put Data, data bytes
131:            * -> Control, 0xF00000  (AUTO_INC, AUTO_ERASE, UNLOCK)
132:            * -> Put Data, data bytes
133:            * -> Control, 0x000000 check run (AUTO_INC, AUTO_ERASE, UNLOCK) checksum
134:            * 
135:            * The user program must have the following vectors. 
136:            *
137:            * User code reset vector  0x0800
138:            * User code HPINT vector	0x0808
139:            * user code LPINT vector	0x0818
140:            * This would normally be achieved using XC8 option --codeoffset=0x800
141:            *
142:            * Checksum is 16 bit addition of all programmable bytes.
143:            * User sends 2s complement of addition at end of program in command 0x03 (16 bits only)
144:            *	
145:            * History for this file:
146:            *  30/10/09    Mike Bolton     - Modified Bootloader.asm version of the Microchip code 
147:            *  27/01/22    Ian Hogg        - ported to XC8 from Bootloader.asm for PIC18F26K80
148:            *  03/04/24    Ian Hogg        - updated to support PIC18F27Q83
149:            * 
150:            * 
151:            * Currently written for:
152:            *  XC8 compiler
153:            *     uses cbusdefs.h from cbusdefs 
154:            *     uses devincs.h from CBUSlib although this could probably be eliminated
155:            *     Must be compiled with options:
156:            *         XC8 linker -> MEMORY model -> ROM ranges 0-07FF
157:            *     application code packed with this bootloader must be compiled with options:
158:            *         XC8 global options -> Additional options --codeoffset=0x800 APP_START
159:            * 
160:            * This file used the following PIC peripherals:
161:            *  * CAN
162:            * 
163:            */
164:           
165:           #include <xc.h>
166:           #include <stdint.h>
167:           #include <hwsettings.h>
168:           #include <main.h>
169:           #include "vlcbdefs.h"
170:           
171:           #define BL_VERSION  1
172:           const char bl_version[] = { 'B','L','_','V','E','R','S','I','O','N','=', BL_TYPE_IanHogg, BL_VERSION};
173:           
174:           // #define STATS        // Uncomment to collect stats of numbers of each type of message received
175:           #define SELF_VERIFY     // uncomment to read back data to ensure it has written ok
176:           
177:           #include <bl_romops.h>
178:           
179:           #define	PIC_HIGH_INT_VECT	0x0008	//HP interrupt vector redirect. Change if target is different
180:           #define	PIC_LOW_INT_VECT	0x0018	//LP interrupt vector redirect. Change if target is different.
181:           #define	PIC_RESET_VECT      0x0000	//start of bootloader
182:           
183:           #define	APP_HIGH_INT_VECT	0x0808	//HP interrupt vector redirect. Change if target is different
184:           #define	APP_LOW_INT_VECT	0x0818	//LP interrupt vector redirect. Change if target is different.
185:           #define	APP_RESET_VECT      0x0800	//start of app
186:           
187:           /**
188:            * Even though this bootloader doesn't use interrupts we must ensure that the
189:            * interrupts are available in case the application wants to use them.
190:            * Here we redirect the interrupt vectors through to the start of App +0x0008 
191:            * and +0x0018 so that they reside at 0x0808 and 0x0818.
192:            */
193:           // Interrupt service routine vectors
194:           //#asm
195:               asm("PSECT HiVector,class=CODE,delta=1,abs");
196:               asm("ORG "  ___mkstr(PIC_HIGH_INT_VECT) );
197:               asm("goto "  ___mkstr(APP_HIGH_INT_VECT) );
0008  EF04     GOTO 0x808
198:                       
199:               asm("PSECT LoVector,class=CODE,delta=1,abs");
200:               asm("ORG "  ___mkstr(PIC_LOW_INT_VECT) );
201:               asm("goto "  ___mkstr(APP_LOW_INT_VECT) );
0018  EF0C     GOTO 0x818
202:           //#endasm
203:           
204:           #define CLK_MHZ         16
205:               
206:           #if defined(_18F66K80_FAMILY_)
207:           #define	CAN_CD_BIT      RXB0EIDLbits.RXB0EID0	//Received control  bit
208:           #define	CANTX_CD_BIT	TXB0EIDLbits.TXB0EID0	//Transmit control/data select bit
209:           #define	CAN_PG_BIT      RXB0EIDLbits.RXB0EID1	//Received PUT / GET
210:           
211:           #define FLASH_BLOCK_MASK 0x3F
212:           #define FLASH_BLOCK_SIZE 0x40
213:           
214:                       // Program memory < 0x00 0000 for PIC18F26K80
215:                       // Config memory = 0x30 0000 for PIC18F26K80
216:                       // EEPROM data = 0xF0 0000 for PIC18F26K80
217:           #define PROGRAM_ADDRESSU    (unsigned char)0x00
218:           #define EEPROM_ADDRESSU     (unsigned char)0xF0
219:           #define CONFIG_ADDRESSU     (unsigned char)0x30
220:           #define ADDRESSU_TYPE_MASK  (unsigned char)0xF0
221:           #define PROGRAM_LOWER_ADDRESSH (unsigned char)0x08    // reserve area below this for bootloader
222:           #endif
223:           #if defined(_18FXXQ83_FAMILY_)
224:           #define	CAN_CD_BIT      (rxFifoObj[RX_EIDL]&0x08)	//Received control  bit
225:           #define	CANTX_CD_BIT	(txFifoObj[TX_EIDL]&0x08)	//Transmit control/data select bit
226:           #define	CAN_SIDH	0b10000000	//Transmitted ID for target node/ data select bit
227:           #define	CAN_PG_BIT      (rxFifoObj[RX_EIDL]&0x10)	//Received PUT / GET
228:           
229:           #define FLASH_BLOCK_MASK 0xFF
230:           #define FLASH_BLOCK_SIZE 0x100
231:                       // Program memory < 0x00 0000 for PIC18F26K80
232:                       // Config memory = 0x30 0000 for PIC18F26K80
233:                       // EEPROM data = 0xF0 0000 for PIC18F26K80
234:           #define PROGRAM_ADDRESSU    (unsigned char)0x01
235:           #define EEPROM_ADDRESSU     (unsigned char)0x38
236:           #define CONFIG_ADDRESSU     (unsigned char)0x30
237:           #define ADDRESSU_TYPE_MASK  (unsigned char)0xFF
238:           #define PROGRAM_LOWER_ADDRESSH (unsigned char)0x08    // reserve area below this for bootloader
239:               
240:           #define CAN1_BUFFERS_BASE_ADDRESS           0x3800
241:           // Transmit FIFO
242:           #define CAN1_FIFO2_BUFFERS_BASE_ADDRESS     CAN1_BUFFERS_BASE_ADDRESS
243:           #define CAN1_FIFO2_PAYLOAD_SIZE     16
244:           #define CAN1_FIFO2_SIZE             32
245:           // Receive FIFO
246:           #define CAN1_FIFO3_BUFFERS_BASE_ADDRESS     (CAN1_FIFO2_BUFFERS_BASE_ADDRESS+(CAN1_FIFO2_PAYLOAD_SIZE*CAN1_FIFO2_SIZE))
247:           #define CAN1_FIFO3_PAYLOAD_SIZE     16
248:           #define CAN1_FIFO3_SIZE             32
249:               
250:           uint8_t* rxFifoObj;
251:           // RX Object offsets
252:           #define RX_SIDL 0
253:           #define RX_EIDL 1
254:           #define RX_EIDH 2
255:           #define RX_EIDU 3
256:           #define RX_DLC  4
257:           #define RX_D0   8
258:           #define RX_D1   9
259:           #define RX_D2   10
260:           #define RX_D3   11
261:           #define RX_D4   12
262:           #define RX_D5   13
263:           #define RX_D6   14
264:           #define RX_D7   15
265:           
266:           uint8_t* txFifoObj;
267:           // TX Object offsets
268:           #define TX_SIDL 0
269:           #define TX_EIDL 1
270:           #define TX_EIDH 2
271:           #define TX_EIDU 3
272:           #define TX_DLC  4
273:           #define TX_D0   8
274:           #define TX_D1   9
275:           #define TX_D2   10
276:           #define TX_D3   11
277:           #define TX_D4   12
278:           #define TX_D5   13
279:           #define TX_D6   14
280:           #define TX_D7   15
281:           
282:           #define TX_IDE  0x10
283:           
284:           /*******************************
285:            * These copied from MCC generated code
286:            ********************************/
287:           /**
288:            @ingroup  can_driver
289:            @enum     CAN_OP_MODES
290:            @brief    Defines the CAN operation modes that are available for the module to use.
291:           */
292:           enum CAN_OP_MODES
293:           {
294:               CAN_NORMAL_FD_MODE = 0x0,           /**< CAN FD Normal Operation Mode (Supported only in CAN FD mode) */
295:               CAN_DISABLE_MODE = 0x1,             /**< CAN Disable Operation Mode */               
296:               CAN_INTERNAL_LOOPBACK_MODE = 0x2,   /**< CAN Internal Loopback Operation Mode */
297:               CAN_LISTEN_ONLY_MODE = 0x3,         /**< CAN Listen only Operation Mode */
298:               CAN_CONFIGURATION_MODE = 0x4,       /**< CAN Configuration Operation Mode */
299:               CAN_EXTERNAL_LOOPBACK_MODE = 0x5,   /**< CAN External Loopback Operation Mode */
300:               CAN_NORMAL_2_0_MODE = 0x6,          /**< CAN 2.0 Operation Mode */
301:               CAN_RESTRICTED_OPERATION_MODE =0x7  /**< CAN Restricted Operation Mode */
302:           }; 
303:           
304:           /**
305:            @ingroup  can_driver
306:            @enum     CAN_OP_MODE_STATUS
307:            @brief    Defines the return status of CAN operation mode set API.
308:           */
309:           enum CAN_OP_MODE_STATUS
310:           {
311:               CAN_OP_MODE_REQUEST_SUCCESS,     /**< The requested operation mode set successfully */
312:               CAN_OP_MODE_REQUEST_FAIL,        /**< The requested operation mode set failure */
313:               CAN_OP_MODE_SYS_ERROR_OCCURED    /**< The system error occurred while setting operation mode. */
314:           };
315:           
316:           
317:           /**
318:            * @ingroup can_driver
319:            * @brief Sets the CAN1 Operation mode.
320:            * @pre CAN1_Initialize() function is already called.
321:            * @param [in] requestMode - CAN1 Operation mode as described in CAN_OP_MODES.
322:            */
323:           void CAN1_OperationModeSet(const enum CAN_OP_MODES requestMode);
324:           
325:           /**
326:            * @ingroup can_driver
327:            * @brief Gets the CAN1 Operation mode.
328:            * @pre CAN1_Initialize() function is already called.
329:            * @param None.
330:            * @return The present CAN1 Operation mode as described in CAN_OP_MODES.
331:            */
332:           enum CAN_OP_MODES CAN1_OperationModeGet(void);
333:           #endif
334:           
335:                       // transmit header
336:           // Set up ID
337:           // SID=0b100 00000000
338:           // EID= 0b00 00000000 00000100
339:           #if defined(_18F66K80_FAMILY_)
340:           #define	CAN_SIDH	0b10000000  //SID=0
341:           #define	CAN_SIDL	0b00001000  // IDE bit set for extended frame and EID top bit set
342:           #define	CAN_EIDH	0b00000000	
343:           #define	CAN_EIDL	0b00000100
344:           #endif
345:           #if defined(_18FXXQ83_FAMILY_)
346:           #define	CAN_TXO0	0b00000000
347:           #define	CAN_TXO1	0b00100100
348:           #define	CAN_TXO2	0b00000000	
349:           #define	CAN_TXO3	0b00000000
350:           #endif
351:                       // receive filter
352:           #define	CAN_RXF0SIDH	0b00000000
353:           #define	CAN_RXF0SIDL	0b00001000
354:           #define	CAN_RXF0EIDH	0b00000000
355:           #define	CAN_RXF0EIDL	0b00000111
356:                       // receive masks
357:           #define	CAN_RXM0SIDH	0b11111111
358:           #define	CAN_RXM0SIDL	0b11101011
359:           #define	CAN_RXM0EIDH	0b11111111
360:           #define	CAN_RXM0EIDL	0b11111000
361:           
362:           #define CAN_BRGCON1  (CLK_MHZ/4)-1  // Work out BRGCON value from clock MHz    
363:           #define	CAN_BRGCON2	0b10011110
364:           #define	CAN_BRGCON3	0b00000011
365:           #define	CAN_CIOCON	0b00100000	// CAN I/O control
366:           
367:           // Bootloader protocol defines
368:           #define	MODE_WRT_UNLCK	 0x01       // Unlock write and erase
369:           #define	MODE_ERASE_ONLY	 0x02       // Erase without write
370:           #define	MODE_AUTO_ERASE	 0x04       // Enable auto erase before write
371:           #define	MODE_AUTO_INC	 0x08       // Enable auto inc the address
372:           #define	MODE_ACK		 0x10       // Acknowledge mode
373:                       
374:                       // response codes
375:           #define RESPONSE_NOK    0x00
376:           #define RESPONSE_OK     0x01
377:           #define RESPONSE_BOOT   0x02
378:           
379:           #define READ_BYTES_QTY     8
380:           
381:                       // commands
382:           #define	CMD_NOP			0x00	
383:           #define	CMD_RESET		0x01	
384:           #define	CMD_RST_CHKSM	0x02	
385:           #define	CMD_CHK_RUN		0x03
386:           #define CMD_BOOT_TEST 	0x04	
387:                       
388:           
389:                       
390:           typedef union {
391:               struct {
392:                   unsigned char l;
393:                   unsigned char h;
394:                   unsigned char u;
395:               } ;
396:               uint24_t triple;
397:           } Integer24;
398:           
399:           //
400:           // Checksums
401:           //
402:           typedef union {
403:               struct {
404:                   unsigned char l;
405:                   unsigned char h;
406:               } ;
407:               uint16_t word;
408:           } Integer16;
409:           
410:           
411:           void canInit(void);
412:           void canSendMessage(uint8_t cdBit);
413:           
414:           
415:           typedef struct ControlFrame {
416:               Integer24 bootAddress;		// Address info	
417:               unsigned char _unused0;		//(Reserved)
418:               unsigned char bootControlBits;	// Boot Mode Control bits
419:               unsigned char bootSpecialCommand;  // Special boot commands
420:               Integer16 bootPCChecksum	;	// Chksum byte fromPC	
421:           } ControlFrame;
422:           /**
423:            * The Control Frame stores a copy of the last control frame received.
424:            * The bootAddress element provides the address of the start of the last 
425:            * requested section. The actual address being written or read is kept in the 
426:            * TBLPTR or NVMADR registers.
427:            */
428:           ControlFrame controlFrame;   // To keep a copy of the control frame
429:           unsigned char * controlFramePtr;
430:           
431:           typedef struct DataFrame {
432:               unsigned char data[8];
433:           }DataFrame;
434:           
435:           unsigned char frameLength;		
436:           Integer16 ourChecksum;	//16 bit checksum we're calculating
437:           unsigned char w;    // general purpose
438:           volatile unsigned char * bufferPtr;
439:           unsigned char addrL;
440:           unsigned char addrH;
441:           
442:           #ifdef STATS
443:           unsigned char flashFrames;
444:           unsigned char configFrames;
445:           unsigned char controlFrames;
446:           unsigned char eepromFrames;
447:           unsigned char dataFrames;
448:           unsigned char reset_chk_command;
449:           #endif
450:           
451:           /* TODOs
452:            Holding down PB on power up
453:            * overwrite self check
454:            */
455:               
456:           // make sure cbus.h is not included before here
457:           void main(void) {
458:               // Set bit rate as some apps use this to work out clock MHz
459:               clkMHz = CLK_MHZ;
035A  0E10     MOVLW 0x10
035C  6E35     MOVWF 0x35, ACCESS
460:           
461:               /*
462:                * The CAN baud rate pre-scaler is preset by the bootloader, so this code is written to be clock speed independent.
463:                * The global variable clkMHz is set by reading in CAN prescaler value from BRGCON or CiCFG for use by any other routines
464:                * that need to know the clock speed. Note that on the PIC32 the Peripheral bus prescaler setting will also need to be taken
465:                * into accounts when configuring time related values for peripherals that use pbclk.
466:                */
467:           #if defined(_18F66K80_FAMILY_)
468:               BRGCON1 = CAN_BRGCON1;  // Work out BRGCON value from clock MHz to 3
469:           
470:               // Turn off analogue
471:               ANCON0 = 0;
472:               ANCON1 = 0;
473:               // initialise the CAN peripheral
474:           #endif
475:           #if defined(_18FXXQ83_FAMILY_)
476:               ANSELA = 0;         // Turn off analogue
035E  0E00     MOVLW 0x0
0360  0104     MOVLB 0x4
0362  6F00     MOVWF s, BANKED
477:               ANSELB = 0;         // Turn off analogue
0364  0E00     MOVLW 0x0
0366  6F08     MOVWF 0x8, BANKED
478:           #endif
479:               // initialise the push button and LED ports
480:               SetPortDirections();  // make input
0368  0E28     MOVLW 0x28
036A  6F01     MOVWF ___rparam_used, BANKED
036C  9EC7     BCF 0xFC7, 7, ACCESS
036E  9CC7     BCF 0xFC7, 6, ACCESS
0370  86C6     BSF 0xFC6, 3, ACCESS
481:               
482:               // next check if the bootflag is set and go to the application if clear
483:           #if defined(_18F66K80_FAMILY_)
484:               EEADR = 0xFF;
485:               EEADRH = 0xFF;
486:           #endif
487:           #if defined(_18FXXQ83_FAMILY_)
488:               //Load NVMADR with the desired byte address
489:               NVMADRU = 0x38;
0372  0E38     MOVLW 0x38
0374  0100     MOVLB 0x0
0376  6F45     MOVWF NVMADRU, BANKED
490:               NVMADRH = 0x03;
0378  0E03     MOVLW 0x3
037A  6F44     MOVWF NVMADRH, BANKED
491:               NVMADRL = 0xFF;
037C  6943     SETF NVMADR, BANKED
492:           #endif
493:               // FLIM_SW == 0 when pressed
494:               if ((ee_read() == 0) && (FLiM_SW)) {  // read last byte of EEPROM and check FLiM switch
037E  EC3C     CALL 0x78, 0
0380  F000     NOP
0382  0900     IORLW 0x0
0384  B4D8     BTFSC 0xFD8, 2, ACCESS
0386  A6CE     BTFSS 0xFCE, 3, ACCESS
0388  D002     BRA 0x38E
495:           //#asm
496:                   asm("goto "  ___mkstr(APP_RESET_VECT) );
038A  EF00     GOTO 0x800
038C  F004     NOP
497:           //#endasm
498:               }
499:               
500:               // enable the 4x PLL
501:               clkMHz = 64;
038E  0E40     MOVLW 0x40
0390  6E35     MOVWF 0x35, ACCESS
502:           #if defined(_18F66K80_FAMILY_)
503:               OSCTUNEbits.PLLEN = 1; 
504:               BRGCON1 = (clkMHz/4 -1);    // adjust the CAN prescalar to 15
505:           #endif
506:           #if defined(_18FXXQ83_FAMILY_)
507:               OSCCON1bits.NOSC = 2;
0392  0100     MOVLB 0x0
0394  51AD     MOVF OSCCON1, W, BANKED
0396  0B8F     ANDLW 0x8F
0398  0920     IORLW 0x20
039A  6FAD     MOVWF OSCCON1, BANKED
508:           #endif
509:               
510:           #ifdef STATS
511:               flashFrames = 0;
512:               configFrames = 0;
513:               controlFrames = 0;
514:               eepromFrames = 0;
515:               dataFrames = 0;
516:               reset_chk_command = 0;
517:           #endif
518:               // by the time we get here we know the EEBOOT flag is set 
519:               controlFrame.bootSpecialCommand = CMD_NOP;
039C  0E00     MOVLW 0x0
039E  6E1C     MOVWF 0x1C, ACCESS
520:               controlFrame.bootControlBits = MODE_AUTO_ERASE | MODE_AUTO_INC | MODE_ACK;
03A0  0E1C     MOVLW 0x1C
03A2  6E1B     MOVWF 0x1B, ACCESS
521:               
522:               // Both LEDs on
523:               TRIS_LED1Y = 0; // Output
03A4  9CC7     BCF 0xFC7, 6, ACCESS
524:               TRIS_LED2G = 0; // Output
03A6  9EC7     BCF 0xFC7, 7, ACCESS
525:               
526:               LED1Y = LED_ON;
03A8  8CBF     BSF 0xFBF, 6, ACCESS
527:               LED2G = LED_ON;
03AA  8EBF     BSF 0xFBF, 7, ACCESS
528:               
529:               //Initialise the CAN peripheral ready for bootloading
530:               canInit();
03AC  EC0F     CALL 0x21E, 0
03AE  F001     NOP
531:               //Initialise the rom routines
532:               initRomops();
03B0  EC8E     CALL 0x11C, 0
03B2  F000     NOP
533:               
534:               ourChecksum.word = 0;
03B4  0E00     MOVLW 0x0
03B6  6E04     MOVWF __activetblptr, ACCESS
03B8  0E00     MOVLW 0x0
03BA  6E03     MOVWF __activetblptr, ACCESS
535:           #ifdef MODE_SELF_VERIFY
536:               errorStatus = NO_ERROR;
537:           #endif
538:               
539:               /******************************************
540:                * enter bootloading loop awaiting command
541:                *****************************************/
542:               while (1) {
543:                   CLRWDT();   // ensure watchdog is cleared whilst waiting
03BC  0004     CLRWDT
544:           #if defined(_18F66K80_FAMILY_)        
545:                   RXB0CONbits.RXFUL = 0;
546:                   // Wait for CAN frame matching filter
547:                   while(RXB0CONbits.RXFUL == 0)
548:                       ;
549:                   
550:                   frameLength = RXB0DLC & 0x0F;
551:           #endif
552:           #if defined(_18FXXQ83_FAMILY_)
553:                   while (! C1FIFOSTA3Lbits.TFNRFNIF)
554:                       ;
03BE  0101     MOVLB 0x1
03C0  A178     BTFSS WDTCON0, 0, BANKED
03C2  D7FD     BRA 0x3BE
555:                   rxFifoObj = (uint8_t*) C1FIFOUA3;   // Pointer to FIFO entry
03C4  C17C     MOVFF C1FIFOUA3, d
03C6  F509     NOP
03C8  C17D     MOVFF C1FIFOUA3H, index
03CA  F50A     NOP
556:                   frameLength = rxFifoObj[RX_DLC] & 0x0F;
03CC  EE20     LFSR 2, 0x4
03CE  F004     NOP
03D0  5009     MOVF 0x9, W, ACCESS
03D2  26D9     ADDWF 0xFD9, F, ACCESS
03D4  500A     MOVF 0xA, W, ACCESS
03D6  22DA     ADDWFC 0xFDA, F, ACCESS
03D8  50DF     MOVF 0xFDF, W, ACCESS
03DA  0B0F     ANDLW 0xF
03DC  6E10     MOVWF 0x10, ACCESS
557:           #endif
558:                   /****************************************
559:                    * We have received a frame, decode it
560:                    ***************************************/
561:                   // check CD bit first  *  CD bit:	Control = 0, Data = 1
562:                   if (CAN_CD_BIT) {
03DE  EE20     LFSR 2, 0x1
03E0  F001     NOP
03E2  5009     MOVF 0x9, W, ACCESS
03E4  26D9     ADDWF 0xFD9, F, ACCESS
03E6  500A     MOVF 0xA, W, ACCESS
03E8  22DA     ADDWFC 0xFDA, F, ACCESS
03EA  A6DF     BTFSS 0xFDF, 3, ACCESS
03EC  D17C     BRA 0x6E6
563:                       /******************
564:                        * Data frame
565:                        ******************/
566:           #ifdef STATS
567:                       dataFrames++;
568:           #endif
569:                       // get the address. Load both the EE and Flash/CONFIG addresses.
570:           #if defined(_18F66K80_FAMILY_) 
571:                       TBLPTRU = controlFrame.bootAddress.u & 0x1F;
572:                       TBLPTRH = controlFrame.bootAddress.h;
573:                       TBLPTRL = controlFrame.bootAddress.l;
574:                       EEADRH = TBLPTRH;
575:                       EEADR = TBLPTRL;
576:           #endif
577:           #if defined(_18FXXQ83_FAMILY_)
578:                       NVMADRU = controlFrame.bootAddress.u;
03EE  C519     MOVFF tableIndex, NVMADRU
03F0  F045     NOP
579:                       NVMADRH = controlFrame.bootAddress.h;
03F2  C518     MOVFF evIdx, NVMADRH
03F4  F044     NOP
580:                       NVMADRL = controlFrame.bootAddress.l;
03F6  C517     MOVFF tableIndex, NVMADR
03F8  F043     NOP
581:           #endif
582:                       
583:                       // check if we need to auto increment ready for next data packet
584:                       if (controlFrame.bootControlBits & MODE_AUTO_INC) {
03FA  A61B     BTFSS 0x1B, 3, ACCESS
03FC  D00A     BRA 0x412
585:                           controlFrame.bootAddress.triple += frameLength;
03FE  5010     MOVF 0x10, W, ACCESS
0400  6E30     MOVWF 0x30, ACCESS
0402  6A31     CLRF 0x31, ACCESS
0404  6A32     CLRF 0x32, ACCESS
0406  5030     MOVF 0x30, W, ACCESS
0408  2617     ADDWF 0x17, F, ACCESS
040A  5031     MOVF 0x31, W, ACCESS
040C  2218     ADDWFC 0x18, F, ACCESS
040E  5032     MOVF 0x32, W, ACCESS
0410  2219     ADDWFC 0x19, F, ACCESS
586:                       }
587:                       
588:                       // Now work out what type of memory we are accessing based upon top 4 bits of address
589:                       // This also
590:                       if ((controlFrame.bootAddress.u & ADDRESSU_TYPE_MASK) <= PROGRAM_ADDRESSU) { 
0412  0E02     MOVLW 0x2
0414  6019     CPFSLT 0x19, ACCESS
0416  D074     BRA 0x500
591:                           /************** FLASH ***************/
592:           #ifdef STATS
593:                           flashFrames++;
594:           #endif
595:                           // Program flash address
596:                           if (CAN_PG_BIT) {   
0418  EE20     LFSR 2, 0x1
041A  F001     NOP
041C  5009     MOVF 0x9, W, ACCESS
041E  26D9     ADDWF 0xFD9, F, ACCESS
0420  500A     MOVF 0xA, W, ACCESS
0422  22DA     ADDWFC 0xFDA, F, ACCESS
0424  A8DF     BTFSS 0xFDF, 4, ACCESS
0426  D02F     BRA 0x486
597:           #if defined(_18F66K80_FAMILY_) 
598:                               // read flash memory
599:                               for (w=0; w<= READ_BYTES_QTY; w++) {
600:                                   EECON1 = 0x80;  //Flash program space
601:                                   ((DataFrame *)(&TXB0D0))->data[w] = readFlashByte();
602:                                   TBLPTRL++;
603:                                   if (TBLPTRL==0) {
604:                                       TBLPTRH++;
605:                                       if (TBLPTRH==0) {
606:                                           TBLPTRU++;
607:                                       }
608:                                   }
609:                               }
610:                               TXB0DLC = READ_BYTES_QTY;
611:           #endif
612:           #if defined(_18FXXQ83_FAMILY_)
613:                               // read fash memory
614:                               // wait for buffer
615:                               while (! C1FIFOSTA2Lbits.TFNRFNIF)
0428  A16C     BTFSS MD1SRC, 0, BANKED
042A  D7FE     BRA 0x428
616:                                   ;
617:                               txFifoObj = (uint8_t*) C1FIFOUA2;
042C  C170     MOVFF C1FIFOUA2, i
042E  F507     NOP
0430  C171     MOVFF C1FIFOUA2H, index
0432  F508     NOP
618:                               for (w=0; w<= READ_BYTES_QTY; w++) {
0434  0E00     MOVLW 0x0
0436  6E0F     MOVWF 0xF, ACCESS
619:                                   txFifoObj[TX_D0+w] = readFlashByte();
0438  500F     MOVF 0xF, W, ACCESS
043A  2407     ADDWF 0x7, W, ACCESS
043C  6E30     MOVWF 0x30, ACCESS
043E  0E00     MOVLW 0x0
0440  2008     ADDWFC 0x8, W, ACCESS
0442  6E31     MOVWF 0x31, ACCESS
0444  0E08     MOVLW 0x8
0446  2430     ADDWF 0x30, W, ACCESS
0448  6ED9     MOVWF 0xFD9, ACCESS
044A  0E00     MOVLW 0x0
044C  2031     ADDWFC 0x31, W, ACCESS
044E  6EDA     MOVWF 0xFDA, ACCESS
0450  EC39     CALL 0x72, 0
0452  F000     NOP
0454  6EDF     MOVWF 0xFDF, ACCESS
620:                                   TBLPTRL++;
0456  2AF6     INCF 0xFF6, F, ACCESS
621:                                   if (TBLPTRL==0) {
0458  50F6     MOVF 0xFF6, W, ACCESS
045A  A4D8     BTFSS 0xFD8, 2, ACCESS
045C  D004     BRA 0x466
622:                                       TBLPTRH++;
045E  2AF7     INCF 0xFF7, F, ACCESS
623:                                       if (TBLPTRH==0) {
0460  50F7     MOVF 0xFF7, W, ACCESS
0462  B4D8     BTFSC 0xFD8, 2, ACCESS
624:                                           TBLPTRU++;
0464  2AF8     INCF 0xFF8, F, ACCESS
625:                                       }
626:                                   }
627:                               }
0466  2A0F     INCF 0xF, F, ACCESS
0468  0E08     MOVLW 0x8
046A  640F     CPFSGT 0xF, ACCESS
046C  D7E5     BRA 0x438
628:                               txFifoObj[TX_DLC] = TX_IDE | READ_BYTES_QTY;
046E  EE20     LFSR 2, 0x4
0470  F004     NOP
0472  5007     MOVF 0x7, W, ACCESS
0474  26D9     ADDWF 0xFD9, F, ACCESS
0476  5008     MOVF 0x8, W, ACCESS
0478  22DA     ADDWFC 0xFDA, F, ACCESS
047A  0E18     MOVLW 0x18
047C  6EDF     MOVWF 0xFDF, ACCESS
629:           #endif
630:                               canSendMessage(1);  // send with data
047E  0E01     MOVLW 0x1
0480  ECDB     CALL 0x1B6, 0
0482  F000     NOP
631:                           } else {
0484  D03D     BRA 0x500
632:                               // write flash memory
633:           #if defined(_18F66K80_FAMILY_)
634:                               if (TBLPTRH >= PROGRAM_LOWER_ADDRESSH)
635:           #endif
636:           #if defined(_18FXXQ83_FAMILY_)
637:                               if ((NVMADRU > 0) || (NVMADRH >=PROGRAM_LOWER_ADDRESSH))
0486  0100     MOVLB 0x0
0488  5145     MOVF NVMADRU, W, BANKED
048A  A4D8     BTFSS 0xFD8, 2, ACCESS
048C  D003     BRA 0x494
048E  0E07     MOVLW 0x7
0490  6544     CPFSGT NVMADRH, BANKED
0492  D036     BRA 0x500
638:           #endif
639:                               {
640:                                   /* The erase is done as part of flushFlash() */
641:                                   if ( controlFrame.bootControlBits & MODE_ERASE_ONLY) {
0494  A21B     BTFSS 0x1B, 1, ACCESS
0496  D003     BRA 0x49E
642:                                       eraseFlash();
0498  EC56     CALL 0xAC, 0
049A  F000     NOP
643:                                   } else {
049C  D031     BRA 0x500
644:                                       // do write
645:                                       /* Writing of flash is done in blocks. The underlying 
646:                                        * writeFlashByte function handles the handling of 
647:                                        * the block buffer.
648:                                        */
649:                                       for (w=0; w<frameLength; w++) {
049E  0E00     MOVLW 0x0
04A0  6E0F     MOVWF 0xF, ACCESS
04A2  D02A     BRA 0x4F8
650:           #if defined(_18F66K80_FAMILY_)
651:                                           writeFlashByte(((DataFrame*)&RXB0D0)->data[w]);
652:                                           ourChecksum.word += (((DataFrame*)&RXB0D0)->data[w]);
653:                                           TBLPTRL++;  // increment pointer
654:                                           if (TBLPTRL==0) {
655:                                               TBLPTRH++;
656:                                               if (TBLPTRH==0) {
657:                                                   TBLPTRU++;
658:                                               }
659:                                           }
660:           #endif
661:           #if defined(_18FXXQ83_FAMILY_)
662:                                           writeFlashByte(rxFifoObj[RX_D0+w]);
04A4  500F     MOVF 0xF, W, ACCESS
04A6  2409     ADDWF 0x9, W, ACCESS
04A8  6E30     MOVWF 0x30, ACCESS
04AA  0E00     MOVLW 0x0
04AC  200A     ADDWFC 0xA, W, ACCESS
04AE  6E31     MOVWF 0x31, ACCESS
04B0  0E08     MOVLW 0x8
04B2  2430     ADDWF 0x30, W, ACCESS
04B4  6ED9     MOVWF 0xFD9, ACCESS
04B6  0E00     MOVLW 0x0
04B8  2031     ADDWFC 0x31, W, ACCESS
04BA  6EDA     MOVWF 0xFDA, ACCESS
04BC  50DF     MOVF 0xFDF, W, ACCESS
04BE  EC50     CALL 0x2A0, 0
04C0  F001     NOP
663:                                           ourChecksum.word += rxFifoObj[RX_D0+w];
04C2  500F     MOVF 0xF, W, ACCESS
04C4  2409     ADDWF 0x9, W, ACCESS
04C6  6E30     MOVWF 0x30, ACCESS
04C8  0E00     MOVLW 0x0
04CA  200A     ADDWFC 0xA, W, ACCESS
04CC  6E31     MOVWF 0x31, ACCESS
04CE  0E08     MOVLW 0x8
04D0  2430     ADDWF 0x30, W, ACCESS
04D2  6ED9     MOVWF 0xFD9, ACCESS
04D4  0E00     MOVLW 0x0
04D6  2031     ADDWFC 0x31, W, ACCESS
04D8  6EDA     MOVWF 0xFDA, ACCESS
04DA  50DF     MOVF 0xFDF, W, ACCESS
04DC  6E32     MOVWF 0x32, ACCESS
04DE  5032     MOVF 0x32, W, ACCESS
04E0  2603     ADDWF __activetblptr, F, ACCESS
04E2  0E00     MOVLW 0x0
04E4  2204     ADDWFC __activetblptr, F, ACCESS
664:                                           NVMADRL++;  // increment pointer
04E6  2B43     INCF NVMADR, F, BANKED
665:                                           if (NVMADRL==0) {
04E8  5143     MOVF NVMADR, W, BANKED
04EA  A4D8     BTFSS 0xFD8, 2, ACCESS
04EC  D004     BRA 0x4F6
666:                                               NVMADRH++;
04EE  2B44     INCF NVMADRH, F, BANKED
667:                                               if (NVMADRH==0) {
04F0  5144     MOVF NVMADRH, W, BANKED
04F2  B4D8     BTFSC 0xFD8, 2, ACCESS
668:                                                   NVMADRU++;
04F4  2B45     INCF NVMADRU, F, BANKED
669:                                               }
670:                                           }
671:           #endif
672:                                           /* Verify is done within flushFlash */
673:                                       }
04F6  2A0F     INCF 0xF, F, ACCESS
04F8  5010     MOVF 0x10, W, ACCESS
04FA  5C0F     SUBWF 0xF, W, ACCESS
04FC  A0D8     BTFSS 0xFD8, 0, ACCESS
04FE  D7D2     BRA 0x4A4
674:                                   } 
675:                               }
676:           #ifdef MODE_SELF_VERIFY
677:                               else {
678:                                   errorStatus = ADDRESS_ERROR;
679:                               }
680:           #endif
681:                           }
682:                       } 
683:                       
684:                       if ((controlFrame.bootAddress.u & ADDRESSU_TYPE_MASK) == CONFIG_ADDRESSU) {
0500  0E30     MOVLW 0x30
0502  1819     XORWF 0x19, W, ACCESS
0504  A4D8     BTFSS 0xFD8, 2, ACCESS
0506  D066     BRA 0x5D4
685:                           /************** CONFIG ***************/
686:           #ifdef STATS
687:                           configFrames++;
688:           #endif
689:                           // Config address
690:                           if (CAN_PG_BIT) {
0508  EE20     LFSR 2, 0x1
050A  F001     NOP
050C  5009     MOVF 0x9, W, ACCESS
050E  26D9     ADDWF 0xFD9, F, ACCESS
0510  500A     MOVF 0xA, W, ACCESS
0512  22DA     ADDWFC 0xFDA, F, ACCESS
0514  A8DF     BTFSS 0xFDF, 4, ACCESS
0516  D030     BRA 0x578
691:                               // read CONFIG
692:                               // Note if we need more space this could be merged with read PGM
693:           #if defined(_18F66K80_FAMILY_)
694:                               for (w=0; w<= READ_BYTES_QTY; w++) {
695:                                   EECON1 = 0xC0;  //Flash configuration space
696:                                   ((DataFrame *)(&TXB0D0))->data[w] = readFlashByte();
697:                                   TBLPTRL++;
698:                                   if (TBLPTRL==0) {
699:                                        TBLPTRH++;
700:                                   }
701:                               }
702:                               TXB0DLC = READ_BYTES_QTY;
703:           #endif
704:           #if defined(_18FXXQ83_FAMILY_)
705:                               // wait for buffer
706:                               while (! C1FIFOSTA2Lbits.TFNRFNIF)
0518  0101     MOVLB 0x1
051A  A16C     BTFSS MD1SRC, 0, BANKED
051C  D7FD     BRA 0x518
707:                                   ;
708:                               txFifoObj = (uint8_t*) C1FIFOUA2;
051E  C170     MOVFF C1FIFOUA2, i
0520  F507     NOP
0522  C171     MOVFF C1FIFOUA2H, index
0524  F508     NOP
709:                               for (w=0; w<= READ_BYTES_QTY; w++) {
0526  0E00     MOVLW 0x0
0528  6E0F     MOVWF 0xF, ACCESS
710:                                   txFifoObj[TX_D0+w] = readFlashByte();
052A  500F     MOVF 0xF, W, ACCESS
052C  2407     ADDWF 0x7, W, ACCESS
052E  6E30     MOVWF 0x30, ACCESS
0530  0E00     MOVLW 0x0
0532  2008     ADDWFC 0x8, W, ACCESS
0534  6E31     MOVWF 0x31, ACCESS
0536  0E08     MOVLW 0x8
0538  2430     ADDWF 0x30, W, ACCESS
053A  6ED9     MOVWF 0xFD9, ACCESS
053C  0E00     MOVLW 0x0
053E  2031     ADDWFC 0x31, W, ACCESS
0540  6EDA     MOVWF 0xFDA, ACCESS
0542  EC39     CALL 0x72, 0
0544  F000     NOP
0546  6EDF     MOVWF 0xFDF, ACCESS
711:                                   TBLPTRL++;
0548  2AF6     INCF 0xFF6, F, ACCESS
712:                                   if (TBLPTRL==0) {
054A  50F6     MOVF 0xFF6, W, ACCESS
054C  A4D8     BTFSS 0xFD8, 2, ACCESS
054E  D004     BRA 0x558
713:                                       TBLPTRH++;
0550  2AF7     INCF 0xFF7, F, ACCESS
714:                                       if (TBLPTRH==0) {
0552  50F7     MOVF 0xFF7, W, ACCESS
0554  B4D8     BTFSC 0xFD8, 2, ACCESS
715:                                           TBLPTRU++;
0556  2AF8     INCF 0xFF8, F, ACCESS
716:                                       }
717:                                   }
718:                               }
0558  2A0F     INCF 0xF, F, ACCESS
055A  0E08     MOVLW 0x8
055C  640F     CPFSGT 0xF, ACCESS
055E  D7E5     BRA 0x52A
719:                               txFifoObj[TX_DLC] = TX_IDE | READ_BYTES_QTY;
0560  EE20     LFSR 2, 0x4
0562  F004     NOP
0564  5007     MOVF 0x7, W, ACCESS
0566  26D9     ADDWF 0xFD9, F, ACCESS
0568  5008     MOVF 0x8, W, ACCESS
056A  22DA     ADDWFC 0xFDA, F, ACCESS
056C  0E18     MOVLW 0x18
056E  6EDF     MOVWF 0xFDF, ACCESS
720:           #endif
721:                               canSendMessage(1);  // send with data
0570  0E01     MOVLW 0x1
0572  ECDB     CALL 0x1B6, 0
0574  F000     NOP
722:                           } else {
0576  D02E     BRA 0x5D4
723:                               // write CONFIG
724:                               for (w=0; w<frameLength; w++) {
0578  0E00     MOVLW 0x0
057A  6E0F     MOVWF 0xF, ACCESS
057C  D027     BRA 0x5CC
725:                                   // no need to erase config bytes
726:                                   CLRWDT();   // ensure watchdog is cleared whilst writing
057E  0004     CLRWDT
727:                                   
728:                                   /* Cannot perform SELF_VERIFY for CONFIG as FCU fills in
729:                                    * missing CONFIG values, such as 0x30004, with 0xFF but these are read back 
730:                                    * as 0x00. This means the verify always fails.
731:                                    */
732:           #if defined(_18F66K80_FAMILY_)
733:                                   // write config byte
734:                                   writeConfigByte(((DataFrame*)&RXB0D0)->data[w]);
735:                                   ourChecksum.word += (((DataFrame*)&RXB0D0)->data[w]);
736:                                   TBLPTRL++;
737:                                   if (TBLPTRL==0) {
738:                                        TBLPTRH++;
739:                                   }
740:           #endif
741:           #if defined(_18FXXQ83_FAMILY_)
742:                                   // write config byte
743:                                   writeConfigByte(rxFifoObj[RX_D0+w]);
0580  500F     MOVF 0xF, W, ACCESS
0582  2409     ADDWF 0x9, W, ACCESS
0584  6E30     MOVWF 0x30, ACCESS
0586  0E00     MOVLW 0x0
0588  200A     ADDWFC 0xA, W, ACCESS
058A  6E31     MOVWF 0x31, ACCESS
058C  0E08     MOVLW 0x8
058E  2430     ADDWF 0x30, W, ACCESS
0590  6ED9     MOVWF 0xFD9, ACCESS
0592  0E00     MOVLW 0x0
0594  2031     ADDWFC 0x31, W, ACCESS
0596  6EDA     MOVWF 0xFDA, ACCESS
0598  50DF     MOVF 0xFDF, W, ACCESS
059A  EC65     CALL 0xCA, 0
059C  F000     NOP
744:                                   ourChecksum.word += rxFifoObj[RX_D0+w];
059E  500F     MOVF 0xF, W, ACCESS
05A0  2409     ADDWF 0x9, W, ACCESS
05A2  6E30     MOVWF 0x30, ACCESS
05A4  0E00     MOVLW 0x0
05A6  200A     ADDWFC 0xA, W, ACCESS
05A8  6E31     MOVWF 0x31, ACCESS
05AA  0E08     MOVLW 0x8
05AC  2430     ADDWF 0x30, W, ACCESS
05AE  6ED9     MOVWF 0xFD9, ACCESS
05B0  0E00     MOVLW 0x0
05B2  2031     ADDWFC 0x31, W, ACCESS
05B4  6EDA     MOVWF 0xFDA, ACCESS
05B6  50DF     MOVF 0xFDF, W, ACCESS
05B8  6E32     MOVWF 0x32, ACCESS
05BA  5032     MOVF 0x32, W, ACCESS
05BC  2603     ADDWF __activetblptr, F, ACCESS
05BE  0E00     MOVLW 0x0
05C0  2204     ADDWFC __activetblptr, F, ACCESS
745:                                   TBLPTRL++;
05C2  2AF6     INCF 0xFF6, F, ACCESS
746:                                   if (TBLPTRL==0) {
05C4  50F6     MOVF 0xFF6, W, ACCESS
05C6  B4D8     BTFSC 0xFD8, 2, ACCESS
747:                                        TBLPTRH++;
05C8  2AF7     INCF 0xFF7, F, ACCESS
748:                                   }
749:           #endif
750:                               }
05CA  2A0F     INCF 0xF, F, ACCESS
05CC  5010     MOVF 0x10, W, ACCESS
05CE  5C0F     SUBWF 0xF, W, ACCESS
05D0  A0D8     BTFSS 0xFD8, 0, ACCESS
05D2  D7D5     BRA 0x57E
751:                           }
752:                       }
753:                       if ((controlFrame.bootAddress.u & ADDRESSU_TYPE_MASK) == EEPROM_ADDRESSU) {
05D4  0E38     MOVLW 0x38
05D6  1819     XORWF 0x19, W, ACCESS
05D8  A4D8     BTFSS 0xFD8, 2, ACCESS
05DA  D061     BRA 0x69E
754:                           /************** EEPROM ***************/
755:           #ifdef STATS
756:                           eepromFrames++;
757:           #endif
758:                           // EE address
759:                           if (CAN_PG_BIT) {
05DC  EE20     LFSR 2, 0x1
05DE  F001     NOP
05E0  5009     MOVF 0x9, W, ACCESS
05E2  26D9     ADDWF 0xFD9, F, ACCESS
05E4  500A     MOVF 0xA, W, ACCESS
05E6  22DA     ADDWFC 0xFDA, F, ACCESS
05E8  A8DF     BTFSS 0xFDF, 4, ACCESS
05EA  D02C     BRA 0x644
760:                               // read
761:           #if defined(_18F66K80_FAMILY_)
762:                               for (w=0; w<= READ_BYTES_QTY; w++) {
763:                                   ((DataFrame *)(&TXB0D0))->data[w] = ee_read();
764:                                   EEADR++;
765:                                   if (EEADR == 0) EEADRH++;
766:                               }
767:                               TXB0DLC = READ_BYTES_QTY;
768:           #endif
769:           #if defined(_18FXXQ83_FAMILY_)
770:                               while (! C1FIFOSTA2Lbits.TFNRFNIF)
05EC  0101     MOVLB 0x1
05EE  A16C     BTFSS MD1SRC, 0, BANKED
05F0  D7FD     BRA 0x5EC
771:                                   ;
772:                               txFifoObj = (uint8_t*) C1FIFOUA2;
05F2  C170     MOVFF C1FIFOUA2, i
05F4  F507     NOP
05F6  C171     MOVFF C1FIFOUA2H, index
05F8  F508     NOP
773:                               for (w=0; w<= READ_BYTES_QTY; w++) {
05FA  0E00     MOVLW 0x0
05FC  6E0F     MOVWF 0xF, ACCESS
774:                                   txFifoObj[TX_D0+w] = ee_read();
05FE  500F     MOVF 0xF, W, ACCESS
0600  2407     ADDWF 0x7, W, ACCESS
0602  6E30     MOVWF 0x30, ACCESS
0604  0E00     MOVLW 0x0
0606  2008     ADDWFC 0x8, W, ACCESS
0608  6E31     MOVWF 0x31, ACCESS
060A  0E08     MOVLW 0x8
060C  2430     ADDWF 0x30, W, ACCESS
060E  6ED9     MOVWF 0xFD9, ACCESS
0610  0E00     MOVLW 0x0
0612  2031     ADDWFC 0x31, W, ACCESS
0614  6EDA     MOVWF 0xFDA, ACCESS
0616  EC3C     CALL 0x78, 0
0618  F000     NOP
061A  6EDF     MOVWF 0xFDF, ACCESS
775:                                   NVMADRL++;
061C  2B43     INCF NVMADR, F, BANKED
776:                                   if (NVMADRL==0) {
061E  5143     MOVF NVMADR, W, BANKED
0620  B4D8     BTFSC 0xFD8, 2, ACCESS
777:                                        NVMADRH++;
0622  2B44     INCF NVMADRH, F, BANKED
778:                                   }
779:                               }
0624  2A0F     INCF 0xF, F, ACCESS
0626  0E08     MOVLW 0x8
0628  640F     CPFSGT 0xF, ACCESS
062A  D7E9     BRA 0x5FE
780:                               txFifoObj[TX_DLC] = TX_IDE | READ_BYTES_QTY;
062C  EE20     LFSR 2, 0x4
062E  F004     NOP
0630  5007     MOVF 0x7, W, ACCESS
0632  26D9     ADDWF 0xFD9, F, ACCESS
0634  5008     MOVF 0x8, W, ACCESS
0636  22DA     ADDWFC 0xFDA, F, ACCESS
0638  0E18     MOVLW 0x18
063A  6EDF     MOVWF 0xFDF, ACCESS
781:           #endif
782:                               canSendMessage(1);  // send with data
063C  0E01     MOVLW 0x1
063E  ECDB     CALL 0x1B6, 0
0640  F000     NOP
783:                           } else {
0642  D02D     BRA 0x69E
784:                               // do write
785:           #if defined(_18F66K80_FAMILY_)
786:                               for (w=0; w<frameLength; w++) {
787:                                   ee_write(((DataFrame*)&RXB0D0)->data[w]);
788:                                   ourChecksum.word += (((DataFrame*)&RXB0D0)->data[w]);
789:                                   EEADR++;
790:                                   if (EEADR == 0) EEADRH++;
791:                               }
792:           #endif
793:           #if defined(_18FXXQ83_FAMILY_)
794:                               for (w=0; w<frameLength; w++) {
0644  0E00     MOVLW 0x0
0646  6E0F     MOVWF 0xF, ACCESS
0648  D026     BRA 0x696
795:                                   ee_write(rxFifoObj[RX_D0+w]);
064A  500F     MOVF 0xF, W, ACCESS
064C  2409     ADDWF 0x9, W, ACCESS
064E  6E30     MOVWF 0x30, ACCESS
0650  0E00     MOVLW 0x0
0652  200A     ADDWFC 0xA, W, ACCESS
0654  6E31     MOVWF 0x31, ACCESS
0656  0E08     MOVLW 0x8
0658  2430     ADDWF 0x30, W, ACCESS
065A  6ED9     MOVWF 0xFD9, ACCESS
065C  0E00     MOVLW 0x0
065E  2031     ADDWFC 0x31, W, ACCESS
0660  6EDA     MOVWF 0xFDA, ACCESS
0662  50DF     MOVF 0xFDF, W, ACCESS
0664  ECA6     CALL 0x14C, 0
0666  F000     NOP
796:                                   ourChecksum.word += rxFifoObj[RX_D0+w];
0668  500F     MOVF 0xF, W, ACCESS
066A  2409     ADDWF 0x9, W, ACCESS
066C  6E30     MOVWF 0x30, ACCESS
066E  0E00     MOVLW 0x0
0670  200A     ADDWFC 0xA, W, ACCESS
0672  6E31     MOVWF 0x31, ACCESS
0674  0E08     MOVLW 0x8
0676  2430     ADDWF 0x30, W, ACCESS
0678  6ED9     MOVWF 0xFD9, ACCESS
067A  0E00     MOVLW 0x0
067C  2031     ADDWFC 0x31, W, ACCESS
067E  6EDA     MOVWF 0xFDA, ACCESS
0680  50DF     MOVF 0xFDF, W, ACCESS
0682  6E32     MOVWF 0x32, ACCESS
0684  5032     MOVF 0x32, W, ACCESS
0686  2603     ADDWF __activetblptr, F, ACCESS
0688  0E00     MOVLW 0x0
068A  2204     ADDWFC __activetblptr, F, ACCESS
797:                                   NVMADRL++;
068C  2B43     INCF NVMADR, F, BANKED
798:                                   if (NVMADRL==0) {
068E  5143     MOVF NVMADR, W, BANKED
0690  B4D8     BTFSC 0xFD8, 2, ACCESS
799:                                        NVMADRH++;
0692  2B44     INCF NVMADRH, F, BANKED
800:                                   }
801:                               }
0694  2A0F     INCF 0xF, F, ACCESS
0696  5010     MOVF 0x10, W, ACCESS
0698  5C0F     SUBWF 0xF, W, ACCESS
069A  A0D8     BTFSS 0xFD8, 0, ACCESS
069C  D7D6     BRA 0x64A
802:           #endif
803:                           }
804:                       }
805:                       
806:                       // check whether we have to send an ACK
807:                       if ((! CAN_PG_BIT) && (controlFrame.bootControlBits & MODE_ACK)) {
069E  EE20     LFSR 2, 0x1
06A0  F001     NOP
06A2  5009     MOVF 0x9, W, ACCESS
06A4  26D9     ADDWF 0xFD9, F, ACCESS
06A6  500A     MOVF 0xA, W, ACCESS
06A8  22DA     ADDWFC 0xFDA, F, ACCESS
06AA  A8DF     BTFSS 0xFDF, 4, ACCESS
06AC  A81B     BTFSS 0x1B, 4, ACCESS
06AE  D09C     BRA 0x7E8
808:                           // send an ack
809:           #if defined(_18F66K80_FAMILY_)
810:           #ifdef MODE_SELF_VERIFY
811:                           TXB0D0 = errorStatus ? RESPONSE_NOK : RESPONSE_OK;
812:           #else
813:                           TXB0D0 = RESPONSE_OK;
814:           #endif
815:                           TXB0DLC = 1;
816:           #endif
817:           #if defined(_18FXXQ83_FAMILY_)
818:                           while (! C1FIFOSTA2Lbits.TFNRFNIF)
06B0  0101     MOVLB 0x1
06B2  A16C     BTFSS MD1SRC, 0, BANKED
06B4  D7FD     BRA 0x6B0
819:                               ;
820:                           txFifoObj = (uint8_t*) C1FIFOUA2;
06B6  C170     MOVFF C1FIFOUA2, i
06B8  F507     NOP
06BA  C171     MOVFF C1FIFOUA2H, index
06BC  F508     NOP
821:           #ifdef MODE_SELF_VERIFY
822:                           txFifoObj[TX_D0] = errorStatus ? RESPONSE_NOK : RESPONSE_OK;
823:           #else
824:                           txFifoObj[TX_D0] = RESPONSE_OK;
06BE  EE20     LFSR 2, 0x8
06C0  F008     NOP
06C2  5007     MOVF 0x7, W, ACCESS
06C4  26D9     ADDWF 0xFD9, F, ACCESS
06C6  5008     MOVF 0x8, W, ACCESS
06C8  22DA     ADDWFC 0xFDA, F, ACCESS
06CA  0E01     MOVLW 0x1
06CC  6EDF     MOVWF 0xFDF, ACCESS
825:           #endif
826:                           txFifoObj[TX_DLC] = TX_IDE | 1;
06CE  EE20     LFSR 2, 0x4
06D0  F004     NOP
06D2  5007     MOVF 0x7, W, ACCESS
06D4  26D9     ADDWF 0xFD9, F, ACCESS
06D6  5008     MOVF 0x8, W, ACCESS
06D8  22DA     ADDWFC 0xFDA, F, ACCESS
06DA  0E11     MOVLW 0x11
06DC  6EDF     MOVWF 0xFDF, ACCESS
827:           #endif
828:                           canSendMessage(0);  // send with control
06DE  0E00     MOVLW 0x0
06E0  ECDB     CALL 0x1B6, 0
06E2  F000     NOP
06E4  D081     BRA 0x7E8
829:                       }
830:                       
831:                   } else {
832:                       /******************
833:                        * Control  frame
834:                        ******************/
835:           #ifdef STATS
836:                       controlFrames++;
837:           #endif
838:                       // we probably need to flush the Program Flash buffer. No harm done
839:                       // if we don't need to do it.
840:                       flushFlash();
06E6  ECBF     CALL 0x17E, 0
06E8  F000     NOP
841:                       //Copy the control frame info to save the programming address
842:                       controlFramePtr = (unsigned char*)&controlFrame;
06EA  0E17     MOVLW 0x17
06EC  6E05     MOVWF 0x5, ACCESS
06EE  0E05     MOVLW 0x5
06F0  6E06     MOVWF 0x6, ACCESS
843:           #if defined(_18F66K80_FAMILY_)
844:                       bufferPtr = &RXB0D0;
845:           #endif
846:           #if defined(_18FXXQ83_FAMILY_)
847:                       bufferPtr = &(rxFifoObj[RX_D0]);
06F2  0E08     MOVLW 0x8
06F4  2409     ADDWF 0x9, W, ACCESS
06F6  6E01     MOVWF ___rparam_used, ACCESS
06F8  0E00     MOVLW 0x0
06FA  200A     ADDWFC 0xA, W, ACCESS
06FC  6E02     MOVWF ___rparam_used, ACCESS
848:           #endif
849:                       for (w=0; w<frameLength; w++) {
06FE  0E00     MOVLW 0x0
0700  6E0F     MOVWF 0xF, ACCESS
0702  D00F     BRA 0x722
850:                           *controlFramePtr = *bufferPtr;
0704  C501     MOVFF __pcstackCOMRAM, FSR2
0706  F4D9     NOP
0708  C502     MOVFF i, FSR2H
070A  F4DA     NOP
070C  C505     MOVFF i, FSR1
070E  F4E1     NOP
0710  C506     MOVFF id, FSR1H
0712  F4E2     NOP
0714  C4DF     MOVFF INDF2, INDF1
0716  F4E7     NOP
851:                           controlFramePtr++;
0718  4A05     INFSNZ 0x5, F, ACCESS
071A  2A06     INCF 0x6, F, ACCESS
852:                           bufferPtr++;
071C  4A01     INFSNZ ___rparam_used, F, ACCESS
071E  2A02     INCF ___rparam_used, F, ACCESS
853:                       }
0720  2A0F     INCF 0xF, F, ACCESS
0722  5010     MOVF 0x10, W, ACCESS
0724  5C0F     SUBWF 0xF, W, ACCESS
0726  A0D8     BTFSS 0xFD8, 0, ACCESS
0728  D7ED     BRA 0x704
854:                   
855:                       /********************************************************* 
856:                        * This is the NOP command. No need to do anything.
857:                        */
858:                       //if (CMD_NOP) {
859:                       //    
860:                       //}
861:           
862:                   
863:                       /********************************************************* 
864:                        * This is the reset command. Used to run the application.
865:                        */
866:                       if (controlFrame.bootSpecialCommand == CMD_RESET) {
072A  041C     DECF 0x1C, W, ACCESS
072C  A4D8     BTFSS 0xFD8, 2, ACCESS
072E  D00C     BRA 0x748
867:                          // Clear the boot flag and enter the application
868:           #if defined(_18F66K80_FAMILY_)
869:                           EEADR = 0xFF;
870:                           EEADRH = 0xFF;
871:           #endif
872:           #if defined(_18FXXQ83_FAMILY_)
873:                           NVMADRU = 0x38;
0730  0E38     MOVLW 0x38
0732  0100     MOVLB 0x0
0734  6F45     MOVWF NVMADRU, BANKED
874:                           NVMADRH = 0x03;
0736  0E03     MOVLW 0x3
0738  6F44     MOVWF NVMADRH, BANKED
875:                           NVMADRL = 0xFF;
073A  6943     SETF NVMADR, BANKED
876:           #endif
877:                           ee_write(0);
073C  0E00     MOVLW 0x0
073E  ECA6     CALL 0x14C, 0
0740  F000     NOP
878:                           LED1Y = LED_OFF;
0742  9CBF     BCF 0xFBF, 6, ACCESS
879:                           LED2G = LED_OFF;
0744  9EBF     BCF 0xFBF, 7, ACCESS
880:                           RESET();
0746  00FF     RESET
881:                       }
882:                   
883:                       /*********************************************************
884:                        * This is the Reset checksum command. This routine 
885:                        * resets the internal checksum registers and error status. 
886:                        */
887:                       if (controlFrame.bootSpecialCommand == CMD_RST_CHKSM) {
0748  0E02     MOVLW 0x2
074A  181C     XORWF 0x1C, W, ACCESS
074C  A4D8     BTFSS 0xFD8, 2, ACCESS
074E  D004     BRA 0x758
888:           #ifdef STATS
889:                           reset_chk_command++;
890:           #endif
891:                           ourChecksum.word = 0;
0750  0E00     MOVLW 0x0
0752  6E04     MOVWF __activetblptr, ACCESS
0754  0E00     MOVLW 0x0
0756  6E03     MOVWF __activetblptr, ACCESS
892:           #ifdef MODE_SELF_VERIFY
893:                           errorStatus = NO_ERROR;
894:           #endif
895:                       }
896:                   
897:                       /************************************************************
898:                        * This is the Test and Run command. The checksum is
899:                        * verified, and the self-write verification bit is checked. 
900:                        * If both pass then OK is sent otherwise a NOK is sent.
901:                        * This only does VERIFY and does NOT run the application.
902:                        */
903:                       if (controlFrame.bootSpecialCommand == CMD_CHK_RUN) {
0758  0E03     MOVLW 0x3
075A  181C     XORWF 0x1C, W, ACCESS
075C  A4D8     BTFSS 0xFD8, 2, ACCESS
075E  D026     BRA 0x7AC
904:           #if defined(_18F66K80_FAMILY_)
905:           #ifdef MODE_SELF_VERIFY
906:                           TXB0D0 = (((ourChecksum.word + controlFrame.bootPCChecksum.word) != 0) || (errorStatus)) ? 
907:                               RESPONSE_NOK : RESPONSE_OK;
908:           #else
909:                           TXB0D0 = ((ourChecksum.word + controlFrame.bootPCChecksum.word) != 0) ? 
910:                               RESPONSE_NOK : RESPONSE_OK;
911:           #endif
912:                           TXB0DLC = 1;
913:           #endif
914:           #if defined(_18FXXQ83_FAMILY_)
915:                           while (! C1FIFOSTA2Lbits.TFNRFNIF)
0760  0101     MOVLB 0x1
0762  A16C     BTFSS MD1SRC, 0, BANKED
0764  D7FD     BRA 0x760
916:                               ;
917:                           txFifoObj = (uint8_t*) C1FIFOUA2;
0766  C170     MOVFF C1FIFOUA2, i
0768  F507     NOP
076A  C171     MOVFF C1FIFOUA2H, index
076C  F508     NOP
918:           #ifdef MODE_SELF_VERIFY
919:                           txFifoObj[TX_D0] = (((ourChecksum.word + controlFrame.bootPCChecksum.word) != 0) || (errorStatus)) ? 
920:                               RESPONSE_NOK : RESPONSE_OK;
921:           #else
922:                           txFifoObj[TX_D0] = ((ourChecksum.word + controlFrame.bootPCChecksum.word) != 0) ? 
076E  EE20     LFSR 2, 0x8
0770  F008     NOP
0772  5007     MOVF 0x7, W, ACCESS
0774  26D9     ADDWF 0xFD9, F, ACCESS
0776  5008     MOVF 0x8, W, ACCESS
0778  22DA     ADDWFC 0xFDA, F, ACCESS
077A  5003     MOVF __activetblptr, W, ACCESS
077C  241D     ADDWF 0x1D, W, ACCESS
077E  6E30     MOVWF 0x30, ACCESS
0780  5004     MOVF __activetblptr, W, ACCESS
0782  201E     ADDWFC 0x1E, W, ACCESS
0784  6E31     MOVWF 0x31, ACCESS
0786  5030     MOVF 0x30, W, ACCESS
0788  1031     IORWF 0x31, W, ACCESS
078A  A4D8     BTFSS 0xFD8, 2, ACCESS
078C  D002     BRA 0x792
078E  0E01     MOVLW 0x1
0790  D001     BRA 0x794
0792  0E00     MOVLW 0x0
0794  6EDF     MOVWF 0xFDF, ACCESS
923:                               RESPONSE_NOK : RESPONSE_OK;
924:           #endif
925:                           txFifoObj[TX_DLC] = TX_IDE | 1;
0796  EE20     LFSR 2, 0x4
0798  F004     NOP
079A  5007     MOVF 0x7, W, ACCESS
079C  26D9     ADDWF 0xFD9, F, ACCESS
079E  5008     MOVF 0x8, W, ACCESS
07A0  22DA     ADDWFC 0xFDA, F, ACCESS
07A2  0E11     MOVLW 0x11
07A4  6EDF     MOVWF 0xFDF, ACCESS
926:           #endif
927:                           canSendMessage(0);  // send with control
07A6  0E00     MOVLW 0x0
07A8  ECDB     CALL 0x1B6, 0
07AA  F000     NOP
928:                       }
929:                       
930:                       
931:                       /************************************************************
932:                        * test module is in BOOT mode
933:                        */
934:                       if (controlFrame.bootSpecialCommand == CMD_BOOT_TEST) {
07AC  0E04     MOVLW 0x4
07AE  181C     XORWF 0x1C, W, ACCESS
07B0  A4D8     BTFSS 0xFD8, 2, ACCESS
07B2  D01A     BRA 0x7E8
935:                           // A Good response :X80180004N02;
936:           #if defined(_18F66K80_FAMILY_)
937:                           TXB0D0 = RESPONSE_BOOT;
938:                           TXB0DLC = 1;
939:           #endif
940:           #if defined(_18FXXQ83_FAMILY_)
941:                           while (! C1FIFOSTA2Lbits.TFNRFNIF)
07B4  0101     MOVLB 0x1
07B6  A16C     BTFSS MD1SRC, 0, BANKED
07B8  D7FD     BRA 0x7B4
942:                               ;
943:                           txFifoObj = (uint8_t*) C1FIFOUA2;
07BA  C170     MOVFF C1FIFOUA2, i
07BC  F507     NOP
07BE  C171     MOVFF C1FIFOUA2H, index
07C0  F508     NOP
944:                           txFifoObj[TX_D0] = RESPONSE_BOOT;
07C2  EE20     LFSR 2, 0x8
07C4  F008     NOP
07C6  5007     MOVF 0x7, W, ACCESS
07C8  26D9     ADDWF 0xFD9, F, ACCESS
07CA  5008     MOVF 0x8, W, ACCESS
07CC  22DA     ADDWFC 0xFDA, F, ACCESS
07CE  0E02     MOVLW 0x2
07D0  6EDF     MOVWF 0xFDF, ACCESS
945:                           txFifoObj[TX_DLC] = TX_IDE | 1;
07D2  EE20     LFSR 2, 0x4
07D4  F004     NOP
07D6  5007     MOVF 0x7, W, ACCESS
07D8  26D9     ADDWF 0xFD9, F, ACCESS
07DA  5008     MOVF 0x8, W, ACCESS
07DC  22DA     ADDWFC 0xFDA, F, ACCESS
07DE  0E11     MOVLW 0x11
07E0  6EDF     MOVWF 0xFDF, ACCESS
946:           #endif
947:                           canSendMessage(0);  // send with control
07E2  0E00     MOVLW 0x0
07E4  ECDB     CALL 0x1B6, 0
07E6  F000     NOP
948:                       }
949:           
950:                   }
951:           #if defined(_18FXXQ83_FAMILY_)
952:                   // ready for next frame
953:                   C1FIFOCON3Hbits.UINC = 1;   // Indicate that we have got the message from FIFO
07E8  0101     MOVLB 0x1
07EA  8175     BSF CM2CON1, 0, BANKED
07EA  8175     BSF CM2CON1, 0, BANKED
954:           #endif
955:               }
956:           }
957:           
958:           
959:           
960:           void canSendMessage(uint8_t cdBit) {
01B6  6E1F     MOVWF 0x1F, ACCESS
961:           #if defined(_18F66K80_FAMILY_)
962:                // wait for TXREQ bit to be clear
963:               while (TXB0CONbits.TXREQ) {
964:                   ;
965:               }
966:           	TXB0SIDH = CAN_SIDH; 
967:           	TXB0SIDL = CAN_SIDL; 
968:           	TXB0EIDH = CAN_EIDH;
969:           	TXB0EIDL = CAN_EIDL;
970:               // set the CD in EID[0] bit correctly
971:           	if (cdBit) {
972:                   CANTX_CD_BIT = 1;
973:               } else {
974:                   CANTX_CD_BIT = 0;
975:               }
976:           #endif
977:           #if defined(_18FXXQ83_FAMILY_)
978:               txFifoObj[0] = CAN_TXO0;
01B8  C507     MOVFF i, FSR2
01BA  F4D9     NOP
01BC  C508     MOVFF index, FSR2H
01BE  F4DA     NOP
01C0  6ADF     CLRF 0xFDF, ACCESS
979:               txFifoObj[1] = CAN_TXO1;
01C2  EE20     LFSR 2, 0x1
01C4  F001     NOP
01C6  5007     MOVF 0x7, W, ACCESS
01C8  26D9     ADDWF 0xFD9, F, ACCESS
01CA  5008     MOVF 0x8, W, ACCESS
01CC  22DA     ADDWFC 0xFDA, F, ACCESS
01CE  0E24     MOVLW 0x24
01D0  6EDF     MOVWF 0xFDF, ACCESS
980:               txFifoObj[2] = CAN_TXO2;
01D2  EE20     LFSR 2, 0x2
01D4  F002     NOP
01D6  5007     MOVF 0x7, W, ACCESS
01D8  26D9     ADDWF 0xFD9, F, ACCESS
01DA  5008     MOVF 0x8, W, ACCESS
01DC  22DA     ADDWFC 0xFDA, F, ACCESS
01DE  6ADF     CLRF 0xFDF, ACCESS
981:               txFifoObj[3] = CAN_TXO3;
01E0  EE20     LFSR 2, 0x3
01E2  F003     NOP
01E4  5007     MOVF 0x7, W, ACCESS
01E6  26D9     ADDWF 0xFD9, F, ACCESS
01E8  5008     MOVF 0x8, W, ACCESS
01EA  22DA     ADDWFC 0xFDA, F, ACCESS
01EC  6ADF     CLRF 0xFDF, ACCESS
982:               // Set the CD bit in EID correctly
983:           	if (cdBit) {
01EE  501F     MOVF 0x1F, W, ACCESS
01F0  B4D8     BTFSC 0xFD8, 2, ACCESS
01F2  D009     BRA 0x206
984:                   txFifoObj[1] |= 0x08;
01F4  EE20     LFSR 2, 0x1
01F6  F001     NOP
01F8  5007     MOVF 0x7, W, ACCESS
01FA  26D9     ADDWF 0xFD9, F, ACCESS
01FC  5008     MOVF 0x8, W, ACCESS
01FE  22DA     ADDWFC 0xFDA, F, ACCESS
0200  0E00     MOVLW 0x0
0202  86DB     BSF 0xFDB, 3, ACCESS
985:               } else {
0204  D008     BRA 0x216
986:                   txFifoObj[1] &= 0xF7;
0206  EE20     LFSR 2, 0x1
0208  F001     NOP
020A  5007     MOVF 0x7, W, ACCESS
020C  26D9     ADDWF 0xFD9, F, ACCESS
020E  5008     MOVF 0x8, W, ACCESS
0210  22DA     ADDWFC 0xFDA, F, ACCESS
0212  0EF7     MOVLW 0xF7
0214  16DF     ANDWF 0xFDF, F, ACCESS
987:               }
988:           #endif
989:           	
990:               // request that the message is sent
991:           #if defined(_18F66K80_FAMILY_)
992:           	TXB0CONbits.TXREQ = 1;
993:           #endif
994:           #if defined(_18FXXQ83_FAMILY_)
995:               C1FIFOCON2H |= (_C1FIFOCON2H_TXREQ_MASK | _C1FIFOCON2H_UINC_MASK);
0216  0E03     MOVLW 0x3
0218  0101     MOVLB 0x1
021A  1369     IORWF 0x69, F, BANKED
996:           #endif
997:           }
021C  0012     RETURN 0
998:           
999:           #if defined(_18F66K80_FAMILY_)
1000:          void canInit(void) {
1001:              IPR5 = 0;    // CAN interrupts priority
1002:          
1003:              // Put module into Configuration mode.
1004:              CANCON = 0b10000000;
1005:              // Wait for config mode
1006:              while (CANSTATbits.OPMODE2 == 0)
1007:                  ;
1008:          
1009:              ECANCON = 0;          // ECAN legacy mode with no FIFOs
1010:           
1011:              /*  The CAN bit rates used for CBUS are calculated as follows:
1012:               *
1013:               * Sync segment is fixed at 1 Tq
1014:               * We are using propogation time of 7tq, phase 1 of 4Tq and phase2 of 4Tq.
1015:               * Total bit time is Sync + prop + phase 1 + phase 2
1016:               * or 16 * Tq in our case
1017:               * So, for 125kbits/s, bit time = 8us, we need Tq = 500ns
1018:               * To get 500nS, we set the CAN bit rate prescaler, in BRGCON1, to half the FOsc clock rate.
1019:               * For example, 16MHz oscillator using PLL, Fosc is 64MHz, Tosc is 15.625nS, so we use prescaler of 1:32 to give Tq of 500nS  (15.625 x 32)
1020:               * Having set Tq to 500nS, all other CAN timings are relative to Tq, so do not need changing with processor clock speed
1021:               */
1022:              BRGCON2 = CAN_BRGCON2; // freely programmable, sample once, phase 1 = 4xTq, prop time = 7xTq
1023:              BRGCON3 = CAN_BRGCON3; // Wake-up enabled, wake-up filter not used, phase 2 = 4xTq
1024:            
1025:              CIOCON    = CAN_CIOCON;    // TX drives Vdd when recessive, CAN capture to CCP1 disabled
1026:                    
1027:              //Initialise CAN registers
1028:              // Set filter 0
1029:          	RXF0SIDH = CAN_RXF0SIDH; 	
1030:          	RXF0SIDL = CAN_RXF0SIDL; 
1031:          	// Prevent filter 1 from causing a receive event
1032:              RXF1SIDL =	0xF3;		
1033:          	RXF0EIDH = CAN_RXF0EIDH;	
1034:          	RXF0EIDL = CAN_RXF0EIDL;
1035:              // Set mask
1036:          	RXM0SIDH = CAN_RXM0SIDH;	
1037:          	RXM0SIDL = CAN_RXM0SIDL;	
1038:          	RXM0EIDH = CAN_RXM0EIDH;			
1039:          	RXM0EIDL = CAN_RXM0EIDL;
1040:              // enable filter 0
1041:              RXFCON0 = 1;
1042:              // Note - BRGCON1 initialised first above
1043:          	BRGCON2 = CAN_BRGCON2;     		
1044:          	BRGCON3 = CAN_BRGCON3;			
1045:          
1046:              BIE0 = 0;                 // No Rx buffer interrupts
1047:              CANCON = 0;               // Set normal operation mode
1048:          }
1049:          #endif
1050:          #if defined(_18FXXQ83_FAMILY_)
1051:          void canInit(void)
1052:          {
1053:              // initialise the CAN peripheral
1054:              RB2PPS = 0x46;      // CANTX
021E  0E46     MOVLW 0x46
0220  0102     MOVLB 0x2
0222  6F0B     MOVWF 0xB, BANKED
1055:              CANRXPPS = 013 ;    // octal 1=PORTB 3 = port B3
0224  0E0B     MOVLW 0xB
0226  6F3D     MOVWF 0x3D, BANKED
1056:              TRISBbits.TRISB2 = 0;  // CAN TX output
0228  94C7     BCF 0xFC7, 2, ACCESS
1057:              TRISBbits.TRISB3 = 1;  // CAN RX input
022A  86C7     BSF 0xFC7, 3, ACCESS
1058:              IPR5 = 0;    // CAN interrupts priority
022C  0E00     MOVLW 0x0
022E  0103     MOVLB 0x3
0230  6F67     MOVWF PMD7, BANKED
1059:              /* Enable the CAN module */
1060:              C1CONHbits.ON = 1;
0232  0101     MOVLB 0x1
0234  8F01     BSF ___rparam_used, 7, BANKED
1061:              
1062:              // Put module into Configuration mode.
1063:              CAN1_OperationModeSet(CAN_CONFIGURATION_MODE);
0236  0E04     MOVLW 0x4
0238  EC48     CALL 0x90, 0
023A  F000     NOP
1064:                  
1065:              /* Initialize the C1FIFOBA with the start address of the CAN FIFO message object area. */
1066:              C1FIFOBA = CAN1_BUFFERS_BASE_ADDRESS;
023C  0E00     MOVLW 0x0
023E  6F4C     MOVWF ZCDCON, BANKED
0240  0E38     MOVLW 0x38
0242  6F4D     MOVWF 0x4D, BANKED
0244  0E00     MOVLW 0x0
0246  6F4E     MOVWF 0x4E, BANKED
0248  0E00     MOVLW 0x0
024A  6F4F     MOVWF 0x4F, BANKED
1067:          
1068:              C1CONL = 0x00;      // CLKSEL0 disabled; DeviceNet filter disabled
024C  0E00     MOVLW 0x0
024E  6F00     MOVWF s, BANKED
1069:              C1CONH = 0x87;      // ON enabled; SIDL disabled; BUSY disabled; WFT T11 Filter; WAKFIL enabled;
0250  0E87     MOVLW 0x87
0252  6F01     MOVWF ___rparam_used, BANKED
1070:              C1CONU = 0x10;      // TXQEN disabled; STEF disabled; SERRLOM disabled; RTXAT disabled;
0254  0E10     MOVLW 0x10
0256  6F02     MOVWF ___rparam_used, BANKED
1071:              C1CONT = 0x50;      // TXBWS=5; ABAT=0; REQOP=0
0258  0E50     MOVLW 0x50
025A  6F03     MOVWF __activetblptr, BANKED
1072:          
1073:              C1NBTCFGL = 0x00;   // SJW 1;
025C  0E00     MOVLW 0x0
025E  6F04     MOVWF __activetblptr, BANKED
1074:              C1NBTCFGH = 0x03;   // TSEG2 4;
0260  0E03     MOVLW 0x3
0262  6F05     MOVWF 0x5, BANKED
1075:              C1NBTCFGU = 0x02;   // TSEG1 3;
0264  0E02     MOVLW 0x2
0266  6F06     MOVWF 0x6, BANKED
1076:              C1NBTCFGT = 0x3F;   // BRP 15;
0268  0E3F     MOVLW 0x3F
026A  6F07     MOVWF 0x7, BANKED
1077:          
1078:          
1079:              /*
1080:               * FIFO2 used for transmit
1081:               * FIFO3 used for receive
1082:               */
1083:          
1084:              // Normal TX FIFO
1085:              C1FIFOCON2L = 0x80; // TXEN enabled; RTREN disabled; RXTSEN disabled; TXATIE disabled; RXOVIE disabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled;
026C  0E80     MOVLW 0x80
026E  6F68     MOVWF PMD8, BANKED
1086:              C1FIFOCON2H = 0x04; // FRESET enabled; TXREQ disabled; UINC disabled;
0270  0E04     MOVLW 0x4
0272  6F69     MOVWF 0x69, BANKED
1087:              C1FIFOCON2U = 0x60; // TXAT unlimited retransmission attempts; TXPRI 0 (low);
0274  0E60     MOVLW 0x60
0276  6F6A     MOVWF MD1CON0, BANKED
1088:              C1FIFOCON2T = (((CAN1_FIFO2_PAYLOAD_SIZE<32) ? (CAN1_FIFO2_PAYLOAD_SIZE/4)-2 :
0278  0E5F     MOVLW 0x5F
027A  6F6B     MOVWF MD1CON1, BANKED
1089:                                  (CAN1_FIFO2_PAYLOAD_SIZE==32) ? 5 :
1090:                                                          (CAN1_FIFO2_PAYLOAD_SIZE/16)+3) << 5) | (CAN1_FIFO2_SIZE-1);// PLSIZE 8; FSIZE 32;
1091:          
1092:              // Normal RX FIFO
1093:              C1FIFOCON3L = 0x08; // TXEN disabled; RTREN disabled; RXTSEN disabled; TXATIE disabled; RXOVIE disabled; TFERFFIE disabled; TFHRFHIE disabled; TFNRFNIE disabled;
027C  0E08     MOVLW 0x8
027E  6F74     MOVWF CM2CON0, BANKED
1094:              C1FIFOCON3H = 0x04; // FRESET enabled; TXREQ disabled; UINC disabled;
0280  0E04     MOVLW 0x4
0282  6F75     MOVWF CM2CON1, BANKED
1095:              C1FIFOCON3U = 0x00; // TXAT retransmission disabled; TXPRI 1;
0284  0E00     MOVLW 0x0
0286  6F76     MOVWF CM2NCH, BANKED
1096:              C1FIFOCON3T = (((CAN1_FIFO3_PAYLOAD_SIZE<32) ? (CAN1_FIFO3_PAYLOAD_SIZE/4)-2 :
0288  0E5F     MOVLW 0x5F
028A  6F77     MOVWF CM2PCH, BANKED
1097:                                  (CAN1_FIFO3_PAYLOAD_SIZE==32) ? 5 :
1098:                                                          (CAN1_FIFO3_PAYLOAD_SIZE/16)+3) << 5) | (CAN1_FIFO3_SIZE-1); // PLSIZE 8; FSIZE 32;
1099:          
1100:              // Filter 0 for All Extended messages
1101:              //C1FLTOBJ0L = 0b00000000;
1102:              //C1FLTOBJ0H = 0b00000000;
1103:              //C1FLTOBJ0U = 0b00000000;
1104:              C1FLTOBJ0T = 0b01000000;    // EXIDE set: allow extended ID only
028C  0E40     MOVLW 0x40
028E  6F8F     MOVWF SPI2TCNT, BANKED
1105:              // Set up a mask for just extended messages
1106:              //C1MASK0L = 0b00000000;
1107:              //C1MASK0H = 0b00000000;
1108:              //C1MASK0U = 0b00000000;
1109:              C1MASK0T = 0b01000000;      // MIDE set: filter on EXIDE
0290  0E40     MOVLW 0x40
0292  6F93     MOVWF SPI2CON2, BANKED
1110:          
1111:              C1FLTCON0L = 0x83;  // FLTEN0 enabled; F1BP FIFO 3 - the normal RX FIFO
0294  0E83     MOVLW 0x83
0296  6F80     MOVWF SPI1RXB, BANKED
1112:                  
1113:              /* Place CAN1 module in Normal Operation mode */
1114:              CAN1_OperationModeSet(CAN_NORMAL_2_0_MODE);    
0298  0E06     MOVLW 0x6
029A  EC48     CALL 0x90, 0
029C  F000     NOP
1115:          }
029E  0012     RETURN 0
1116:              /************************************
1117:           * Section copied from MCC generated code
1118:           *************************************/
1119:          void CAN1_OperationModeSet(const enum CAN_OP_MODES requestMode)
0090  6E1F     MOVWF 0x1F, ACCESS
1120:          {
1121:              C1CONTbits.REQOP = requestMode;
0092  0101     MOVLB 0x1
0094  5103     MOVF __activetblptr, W, BANKED
0096  181F     XORWF 0x1F, W, ACCESS
0098  0BF8     ANDLW 0xF8
009A  181F     XORWF 0x1F, W, ACCESS
009C  6F03     MOVWF __activetblptr, BANKED
1122:              while (C1CONUbits.OPMOD != requestMode)
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
009E  3902     SWAPF ___rparam_used, W, BANKED
1123:                  ;
1124:          }
1125:          
1126:          #endif
1127:          
---  C:/Users/ianwh/github/CBUS_PIC_Bootloader/bl_romops.c  ---------------------------------------------
1:             /* 
2:              romops.c - EEPROM and FLASH ROM routines 
3:             
4:             
5:              Original CANACC8 assembler version (c) Mike Bolton
6:              Modifications to EEPROM routines and conversion to C18 (c) Andrew Crosland
7:              FLASH routines by (c) Chuck Hoelzen
8:              Modifications, refinements & combine EEPROM and FLASH into one module (C) Pete Brownlow 2014-2017   software@upsys.co.uk
9:             
10:               This work is licensed under the:
11:                  Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
12:               To view a copy of this license, visit:
13:                  http://creativecommons.org/licenses/by-nc-sa/4.0/
14:               or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.
15:            
16:               License summary:
17:                You are free to:
18:                  Share, copy and redistribute the material in any medium or format
19:                  Adapt, remix, transform, and build upon the material
20:            
21:                The licensor cannot revoke these freedoms as long as you follow the license terms.
22:            
23:                Attribution : You must give appropriate credit, provide a link to the license,
24:                               and indicate if changes were made. You may do so in any reasonable manner,
25:                               but not in any way that suggests the licensor endorses you or your use.
26:            
27:                NonCommercial : You may not use the material for commercial purposes. **(see note below)
28:            
29:                ShareAlike : If you remix, transform, or build upon the material, you must distribute
30:                              your contributions under the same license as the original.
31:            
32:                No additional restrictions : You may not apply legal terms or technological measures that
33:                                              legally restrict others from doing anything the license permits.
34:            
35:               ** For commercial use, please contact the original copyright holder(s) to agree licensing terms
36:            
37:                This software is distributed in the hope that it will be useful, but WITHOUT ANY
38:                WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE
39:            
40:            **************************************************************************************************************
41:              Note:   This source code has been written using a tab stop and indentation setting
42:                      of 4 characters. To see everything lined up correctly, please set your
43:                      IDE or text editor to the same settings.
44:            ******************************************************************************************************
45:            	
46:             For library version number and revision history see CBUSLib.h
47:            
48:             Ported to XC8 from CBUSlib romops.c by Ian Hogg 31/1/2022
49:            
50:            */
51:            
52:            #include <xc.h>
53:            #include <bl_romops.h>
54:            
55:            #include <main.h>
56:            
57:            #include "GenericTypeDefs.h"
58:            
59:            #if defined(_18F66K80_FAMILY_)
60:            #define FLASH_BLOCK_SIZE    64
61:            #define FLASH_BLOCK_MASK    0x3F
62:            #define CONFIGU             0x30
63:            #endif
64:            #if defined(_18FXXQ83_FAMILY_)
65:            #define FLASH_BLOCK_SIZE    256
66:            #define FLASH_BLOCK_MASK    0xFF
67:            
68:            #define NVMCMD_READ             0x00
69:            #define NVMCMD_READ_POSTINC     0x01
70:            #define NVMCMD_READPAGE         0x02
71:            #define NVMCMD_WRITE            0x03
72:            #define NVMCMD_WRITE_POSTINC    0x04
73:            #define NVMCMD_WRITEPAGE        0x05
74:            #define NVMCMD_ERASEPAGE        0x06
75:            #define NVMCMD_NOP              0x07
76:            
77:            #endif
78:            
79:            #define FALSE 0
80:            #define TRUE 1
81:            
82:            #define BOOTLOADER_UPPER_ADDRESSH   0x08
83:            
84:            /**
85:             * bufferAddr is used to store the address in memory that the buffer represents.
86:             * This needs to be aligned to a block boundary.
87:             */
88:            static unsigned char bufferAddrL;
89:            static unsigned char bufferAddrH;
90:            #if defined(_18F66K80_FAMILY_)
91:            static unsigned char buffer[FLASH_BLOCK_SIZE];
92:            #define BLOCK(h, l)  (((int)h<<8)|(l&(~FLASH_BLOCK_MASK)))
93:            #endif
94:            #if defined(_18FXXQ83_FAMILY_)
95:            // On the Q series the NVM peripheral uses a fixed RAM buffer at 0x3700
96:            static unsigned char * buffer = (unsigned char *)0x3700;
97:            static unsigned char bufferAddrU;
98:            #define BLOCK(u, h, l)  (((int24_t)u<<16)|((int)h<<8)|(l&(~FLASH_BLOCK_MASK)))
99:            #endif
100:           
101:           
102:           
103:           
104:           #if defined(_18F66K80_FAMILY_)
105:           static unsigned char w;
106:           #endif
107:           static unsigned char addrL;
108:           static unsigned char addrH;
109:           #if defined(_18FXXQ83_FAMILY_)
110:           static unsigned char addrU;
111:           
112:           static uint16_t w;
113:           #endif
114:           
115:           #ifdef MODE_SELF_VERIFY
116:           unsigned char errorStatus;
117:           #endif
118:           
119:           void initRomops(void) {
120:               for (w=0; w<FLASH_BLOCK_SIZE; w++) {
011C  0E00     MOVLW 0x0
011E  6E0C     MOVWF 0xC, ACCESS
0120  0E00     MOVLW 0x0
0122  6E0B     MOVWF 0xB, ACCESS
121:                   buffer[w] = 0xFF;
0124  0E00     MOVLW 0x0
0126  240B     ADDWF 0xB, W, ACCESS
0128  6ED9     MOVWF 0xFD9, ACCESS
012A  0E37     MOVLW 0x37
012C  200C     ADDWFC 0xC, W, ACCESS
012E  6EDA     MOVWF 0xFDA, ACCESS
0130  0EFF     MOVLW 0xFF
0132  6EDF     MOVWF 0xFDF, ACCESS
122:               }
0134  4A0B     INFSNZ 0xB, F, ACCESS
0136  2A0C     INCF 0xC, F, ACCESS
0138  040C     DECF 0xC, W, ACCESS
013A  A0D8     BTFSS 0xFD8, 0, ACCESS
013C  D7F3     BRA 0x124
123:               bufferAddrL = 0;
013E  0E00     MOVLW 0x0
0140  6E16     MOVWF 0x16, ACCESS
124:               bufferAddrH = 0;
0142  0E00     MOVLW 0x0
0144  6E15     MOVWF 0x15, ACCESS
125:           #if defined(_18FXXQ83_FAMILY_)
126:               bufferAddrU = 0;
0146  0E00     MOVLW 0x0
0148  6E14     MOVWF 0x14, ACCESS
127:           #endif
128:           }
014A  0012     RETURN 0
129:           
130:           /**
131:            * Load a byte directly from Flash - either Program or Config - memory.
132:            * The address to be read must already be loaded into TBLPTR.
133:            */
134:           unsigned char readFlashByte(void) {
135:               asm("TBLRD*");
0072  0008     TBLRD*
136:               return TABLAT;
0074  50F5     MOVF 0xFF5, W, ACCESS
137:           }
0076  0012     RETURN 0
138:           
139:           /* 
140:            * Write a byte into the buffer. Writes to the TBLPTR or NVMADR address
141:            * It will flush the old buffer contents if this is for a different block.
142:            */
143:           void writeFlashByte(unsigned char value) {
02A0  6E2F     MOVWF 0x2F, ACCESS
144:               // check if this is the block we already have buffered or a different block
145:               
146:           #if defined(_18F66K80_FAMILY_)
147:               if (BLOCK(TBLPTRH, TBLPTRL) != BLOCK(bufferAddrH, bufferAddrL)) {
148:                   // different block
149:                   
150:                   addrL = TBLPTRL;    // preserve the TBLPTR
151:                   addrH = TBLPTRH;
152:                   
153:                   flushFlash();
154:                   
155:                   // record the start address of the block we have buffered
156:                   bufferAddrL = addrL & ~FLASH_BLOCK_MASK;
157:                   bufferAddrH = addrH;
158:                   //read the entire new block into buffer
159:                   for (w=0; w<FLASH_BLOCK_SIZE; w++) {
160:                       TBLPTRL = bufferAddrL + w;
161:                       TBLPTRH = bufferAddrH;
162:                       EECON1 = 0x80;  // Flash program space
163:                       buffer[w] = readFlashByte();
164:                   }
165:                   TBLPTRL = addrL;    // restore it
166:                   TBLPTRH = addrH;
167:               }
168:           
169:               // save to the buffer
170:               buffer[TBLPTRL & FLASH_BLOCK_MASK] = value;
171:           #endif
172:           #if defined(_18FXXQ83_FAMILY_)
173:               if (BLOCK(NVMADRU, NVMADRH, NVMADRL) != BLOCK(bufferAddrU, bufferAddrH, bufferAddrL)) {
02A2  5015     MOVF 0x15, W, ACCESS
02A4  6E20     MOVWF 0x20, ACCESS
02A6  6A1F     CLRF 0x1F, ACCESS
02A8  5014     MOVF 0x14, W, ACCESS
02AA  6E23     MOVWF 0x23, ACCESS
02AC  6A22     CLRF 0x22, ACCESS
02AE  6A21     CLRF 0x21, ACCESS
02B0  501F     MOVF 0x1F, W, ACCESS
02B2  1021     IORWF 0x21, W, ACCESS
02B4  6E24     MOVWF 0x24, ACCESS
02B6  5020     MOVF 0x20, W, ACCESS
02B8  1022     IORWF 0x22, W, ACCESS
02BA  6E25     MOVWF 0x25, ACCESS
02BC  0E00     MOVLW 0x0
02BE  BE20     BTFSC 0x20, 7, ACCESS
02C0  0EFF     MOVLW 0xFF
02C2  1023     IORWF 0x23, W, ACCESS
02C4  6E26     MOVWF 0x26, ACCESS
02C6  0100     MOVLB 0x0
02C8  5144     MOVF NVMADRH, W, BANKED
02CA  6E28     MOVWF 0x28, ACCESS
02CC  6A27     CLRF 0x27, ACCESS
02CE  5145     MOVF NVMADRU, W, BANKED
02D0  6E2B     MOVWF 0x2B, ACCESS
02D2  6A2A     CLRF 0x2A, ACCESS
02D4  6A29     CLRF 0x29, ACCESS
02D6  5027     MOVF 0x27, W, ACCESS
02D8  1029     IORWF 0x29, W, ACCESS
02DA  6E2C     MOVWF 0x2C, ACCESS
02DC  5028     MOVF 0x28, W, ACCESS
02DE  102A     IORWF 0x2A, W, ACCESS
02E0  6E2D     MOVWF 0x2D, ACCESS
02E2  0E00     MOVLW 0x0
02E4  BE28     BTFSC 0x28, 7, ACCESS
02E6  0EFF     MOVLW 0xFF
02E8  102B     IORWF 0x2B, W, ACCESS
02EA  6E2E     MOVWF 0x2E, ACCESS
02EC  5024     MOVF 0x24, W, ACCESS
02EE  182C     XORWF 0x2C, W, ACCESS
02F0  E107     BNZ 0x300
02F2  5025     MOVF 0x25, W, ACCESS
02F4  182D     XORWF 0x2D, W, ACCESS
02F6  E104     BNZ 0x300
02F8  5026     MOVF 0x26, W, ACCESS
02FA  182E     XORWF 0x2E, W, ACCESS
02FC  B4D8     BTFSC 0xFD8, 2, ACCESS
02FE  D024     BRA 0x348
174:                   // different block
175:                   addrL = NVMADRL;    // preserve the NVMADR as desired address
0300  C043     MOVFF NVMADR, hi
0302  F513     NOP
176:                   addrH = NVMADRH;
0304  C044     MOVFF NVMADRH, i
0306  F512     NOP
177:                   addrU = NVMADRU;
0308  C045     MOVFF NVMADRU, m
030A  F511     NOP
178:                   
179:                   flushFlash();       // erase and save old block
030C  ECBF     CALL 0x17E, 0
030E  F000     NOP
180:                   // record the start address of the new block we will buffer
181:                   bufferAddrL = addrL & ~FLASH_BLOCK_MASK;
0310  0E00     MOVLW 0x0
0312  6E16     MOVWF 0x16, ACCESS
182:                   bufferAddrH = addrH;
0314  C512     MOVFF i, lo
0316  F515     NOP
183:                   bufferAddrU = addrU;
0318  C511     MOVFF m, incomingCanId
031A  F514     NOP
184:                   
185:                   // ready?
186:                   while (NVMCON0bits.GO)
187:                       ;
031C  0100     MOVLB 0x0
031E  B140     BTFSC NVMCON0, 0, BANKED
0320  D7FD     BRA 0x31C
188:                   //Load NVMADR with the starting address of the new memory page
189:                   NVMADRU = bufferAddrU;
0322  C514     MOVFF incomingCanId, NVMADRU
0324  F045     NOP
190:                   NVMADRH = bufferAddrH;
0326  C515     MOVFF lo, NVMADRH
0328  F044     NOP
191:                   NVMADRL = bufferAddrL;
032A  C516     MOVFF i, NVMADR
032C  F043     NOP
192:                   NVMCON1bits.NVMCMD = NVMCMD_READPAGE;      //Set the page read command
032E  5141     MOVF NVMCON1, W, BANKED
0330  0BF8     ANDLW 0xF8
0332  0902     IORLW 0x2
0334  6F41     MOVWF NVMCON1, BANKED
193:                   NVMCON0bits.GO = 1;             //Start page read
0336  8140     BSF NVMCON0, 0, BANKED
194:                   NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
0338  0E07     MOVLW 0x7
033A  1341     IORWF NVMCON1, F, BANKED
195:                   // restore the pointer
196:                   NVMADRL = addrL;
033C  C513     MOVFF hi, NVMADR
033E  F043     NOP
197:                   NVMADRH = addrH;
0340  C512     MOVFF i, NVMADRH
0342  F044     NOP
198:                   NVMADRU = addrU;
0344  C511     MOVFF m, NVMADRU
0346  F045     NOP
199:               }
200:           
201:               // save to the buffer
202:               buffer[NVMADRL & FLASH_BLOCK_MASK] = value;
0348  0E00     MOVLW 0x0
034A  2543     ADDWF NVMADR, W, BANKED
034C  6ED9     MOVWF 0xFD9, ACCESS
034E  6ADA     CLRF 0xFDA, ACCESS
0350  0E37     MOVLW 0x37
0352  22DA     ADDWFC 0xFDA, F, ACCESS
0354  C52F     MOVFF tableIndex, INDF2
0356  F4DF     NOP
203:           #endif
204:           }
0358  0012     RETURN 0
205:           
206:           /**
207:            * Erase the blocked pointed to by TBLPTR
208:            */
209:           void eraseFlash(void) {
210:           #if defined(_18F66K80_FAMILY_)
211:               EECON1bits.EEPGD = 1;   // 1=Program memory, 0=EEPROM
212:               EECON1bits.CFGS = 0;    // 0=Program memory/EEPROM, 1=ConfigBits
213:               EECON1bits.WREN = 1;    // enable write to memory
214:               EECON1bits.FREE = 1;    // enable row erase operation
215:           
216:               // unlock
217:               EECON2 = 0x55;          // write 0x55
218:               EECON2 = 0xaa;          // write 0xaa
219:               EECON1bits.WR = 1;      // start erasing
220:               EECON1bits.WREN = 0;    // disable write to memory
221:           #endif
222:           #if defined(_18FXXQ83_FAMILY_)
223:               NVMCON1bits.NVMCMD = NVMCMD_ERASEPAGE;      //Set the page erase command
00AC  0100     MOVLB 0x0
00AE  5141     MOVF NVMCON1, W, BANKED
00B0  0BF8     ANDLW 0xF8
00B2  0906     IORLW 0x6
00B4  6F41     MOVWF NVMCON1, BANKED
224:               //Perform the unlock sequence 
225:               NVMLOCK = 0x55;
00B6  0E55     MOVLW 0x55
00B8  6F42     MOVWF NVMLOCK, BANKED
226:               NVMLOCK = 0xAA;
00BA  0EAA     MOVLW 0xAA
00BC  6F42     MOVWF NVMLOCK, BANKED
227:               NVMCON0bits.GO = 1;             //Start byte write
00BE  8140     BSF NVMCON0, 0, BANKED
228:               while (NVMCON0bits.GO)
229:                   ;
00C0  B140     BTFSC NVMCON0, 0, BANKED
00C2  D7FE     BRA 0xC0
230:               NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
00C4  0E07     MOVLW 0x7
00C6  1341     IORWF NVMCON1, F, BANKED
231:           #endif
232:           }
00C8  0012     RETURN 0
233:           
234:           /**
235:            * Flush the current buffer to Flash to the address of bufferAddr
236:            * Verify if required.
237:            * Corrupts TBLPTR
238:            * @return 
239:            */
240:           void flushFlash(void) {
241:           
242:           #if defined(_18F66K80_FAMILY_)
243:               // check we are not overwriting the bootloader itself
244:               if (bufferAddrH < BOOTLOADER_UPPER_ADDRESSH) return;
245:               TBLPTRL = bufferAddrL;
246:               TBLPTRH = bufferAddrH;
247:               eraseFlash();
248:           
249:               for (w=0; w<FLASH_BLOCK_SIZE; w++) {
250:                   TABLAT = buffer[w];
251:                   asm("TBLWT*+");
252:               }
253:               // Note from data sheet: 
254:               //   Before setting the WR bit, the Table
255:               //   Pointer address needs to be within the
256:               //   intended address range of the 64 bytes in
257:               //   the holding register.
258:               // So we put it back into the block here
259:               TBLPTR--;
260:               EECON1 = 0x84;   // Flash, program, enable write
261:               // unlock
262:               EECON2 = 0x55;
263:               EECON2 = 0xAA;
264:               EECON1bits.WR = TRUE;       // start writing 
265:               asm("nop");                 // needs a nop before testing the bit
266:               while (EECON1bits.WR)       // wait for write to complete
267:                   ;
268:               EECON1bits.WREN = FALSE;    // disable write to memory
269:           #endif
270:           #if defined(_18FXXQ83_FAMILY_)
271:               // check we are not overwriting the bootloader itself
272:               if ((bufferAddrH >= BOOTLOADER_UPPER_ADDRESSH) || (bufferAddrU != 0)) {
017E  0E08     MOVLW 0x8
0180  6015     CPFSLT 0x15, ACCESS
0182  D003     BRA 0x18A
0184  5014     MOVF 0x14, W, ACCESS
0186  B4D8     BTFSC 0xFD8, 2, ACCESS
0188  0012     RETURN 0
273:                   NVMADRL = bufferAddrL;
018A  C516     MOVFF i, NVMADR
018C  F043     NOP
274:                   NVMADRH = bufferAddrH;
018E  C515     MOVFF lo, NVMADRH
0190  F044     NOP
275:                   NVMADRU = bufferAddrU;
0192  C514     MOVFF incomingCanId, NVMADRU
0194  F045     NOP
276:                   eraseFlash();
0196  EC56     CALL 0xAC, 0
0198  F000     NOP
277:           
278:                   NVMCON1bits.NVMCMD = NVMCMD_WRITEPAGE;      //Set the page write command
019A  5141     MOVF NVMCON1, W, BANKED
019C  0BF8     ANDLW 0xF8
019E  0905     IORLW 0x5
01A0  6F41     MOVWF NVMCON1, BANKED
279:                   //Perform the unlock sequence 
280:                   NVMLOCK = 0x55;
01A2  0E55     MOVLW 0x55
01A4  6F42     MOVWF NVMLOCK, BANKED
281:                   NVMLOCK = 0xAA;
01A6  0EAA     MOVLW 0xAA
01A8  6F42     MOVWF NVMLOCK, BANKED
282:                   NVMCON0bits.GO = 1;             //Start byte write
01AA  8140     BSF NVMCON0, 0, BANKED
283:                   while (NVMCON0bits.GO)
284:                       ;
01AC  B140     BTFSC NVMCON0, 0, BANKED
01AE  D7FE     BRA 0x1AC
285:                   NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
01B0  0E07     MOVLW 0x7
01B2  1341     IORWF NVMCON1, F, BANKED
286:               }
287:           #endif
288:               
289:           
290:           #ifdef MODE_SELF_VERIFY
291:               // read back to verify
292:           #if defined(_18F66K80_FAMILY_)
293:               for (w=0; w<FLASH_BLOCK_SIZE; w++) {
294:                   TBLPTRL = bufferAddrL+w;
295:                   TBLPTRH = bufferAddrH;
296:                   EECON1 = 0x80;  // Flash Program space
297:                   if (buffer[w] != readFlashByte()) {
298:                       errorStatus = VERIFY_ERROR;
299:                   }
300:               }
301:           #endif
302:           #if defined(_18FXXQ83_FAMILY_)
303:               //Load NVMADR with the starting address of the memory page
304:               NVMADRU = bufferAddrU;
305:               NVMADRH = bufferAddrH;
306:               NVMADRL = bufferAddrL;
307:               NVMCON1bits.NVMCMD = NVMCMD_READPAGE;      //Set the page read command
308:               NVMCON0bits.GO = 1;             //Start page read
309:               while (NVMCON0bits.GO)
310:                   ;
311:               NVMCON1bits.NVMCMD = NVMCMD_NOP;      //Clear the NVM Command
312:           #endif
313:           #endif
314:           }
01B4  0012     RETURN 0
315:           
316:           /**
317:            * This writes directly to the Flash Config. It uses the TBLPTR as the address
318:            */
319:           void writeConfigByte(unsigned char value) {
00CA  6E1F     MOVWF 0x1F, ACCESS
320:           #if defined(_18F66K80_FAMILY_)
321:               TABLAT = value;
322:               asm("TBLWT*");
323:               EECON1 = 0xC4;   // Flash, Config, enable write
324:               // unlock
325:               EECON2 = 0x55;
326:               EECON2 = 0xAA;
327:               EECON1bits.WR = TRUE;       // start writing
328:               asm("nop");                 // needs a nop before testing the bit
329:               while (EECON1bits.WR)       // Wait for the write to complete
330:                   ;
331:               EECON1bits.WREN = FALSE;    // disable write to memory
332:               /* 
333:                * The following SELF_VERIFY code was originally written but FCU fills in
334:                * missing CONFIG values, such as 0x30004, with 0xFF but these are read back 
335:                * as 0x00 so many CONFIG bytes would fail verification but be correct.
336:                * 
337:               #ifdef MODE_SELF_VERIFY
338:                   EECON1 = 0xC0;  // Flash Configuration space
339:                   if (readFlashByte() != value) {
340:                       errorStatus = VERIFY_ERROR;
341:                   }
342:               #endif
343:                */
344:           #endif
345:           #if defined(_18FXXQ83_FAMILY_)
346:               // ready?
347:               while (NVMCON0bits.GO)
00CC  0100     MOVLB 0x0
00CE  B140     BTFSC NVMCON0, 0, BANKED
00D0  D7FD     BRA 0xCC
348:                   ;
349:               NVMDATL = value;
00D2  C51F     MOVFF data3, NVMDAT
00D4  F046     NOP
350:               NVMDATH = 0;
00D6  0E00     MOVLW 0x0
00D8  6F47     MOVWF NVMDATH, BANKED
351:               NVMCON1bits.NVMCMD = NVMCMD_WRITE;
00DA  5141     MOVF NVMCON1, W, BANKED
00DC  0BF8     ANDLW 0xF8
00DE  0903     IORLW 0x3
00E0  6F41     MOVWF NVMCON1, BANKED
352:               //Perform the unlock sequence 
353:               NVMLOCK = 0x55;
00E2  0E55     MOVLW 0x55
00E4  6F42     MOVWF NVMLOCK, BANKED
354:               NVMLOCK = 0xAA;
00E6  0EAA     MOVLW 0xAA
00E8  6F42     MOVWF NVMLOCK, BANKED
355:               NVMCON0bits.GO = 1;
00EA  8140     BSF NVMCON0, 0, BANKED
356:               NVMCON1bits.NVMCMD = NVMCMD_NOP;
00EC  0E07     MOVLW 0x7
00EE  1341     IORWF NVMCON1, F, BANKED
357:           #endif
358:           }
00F0  0012     RETURN 0
359:           
360:           /*****************************
361:            *
362:            *  EE ROUTINES
363:            *
364:            ******************************/
365:           /**
366:            * Write one byte to data EEPROM.
367:            * We verify at end and try again if necessary.
368:            * The address to be written is passed in TBLPTR
369:            * @param data the data to be written
370:            */
371:           void ee_write(unsigned char data) {
014C  6E1F     MOVWF 0x1F, ACCESS
372:               do {
373:           #if defined(_18F66K80_FAMILY_)
374:                   EEDATA = data;
375:                   EECON1bits.EEPGD = 0;       /* Point to DATA memory */
376:                   EECON1bits.CFGS = 0;        /* Access program FLASH/Data EEPROM memory */
377:                   EECON1bits.WREN = 1;        /* Enable writes */
378:           
379:                   EECON2 = 0x55;
380:                   EECON2 = 0xAA;
381:                   EECON1bits.WR = 1;
382:           
383:                   while (EECON1bits.WR)
384:                       ;
385:                   while (!EEIF)
386:                       ;
387:                   EEIF = 0;
388:                   EECON1bits.WREN = 0;		/* Disable writes */
389:           #endif
390:           #if defined(_18FXXQ83_FAMILY_)
391:                   //Load NVMDAT with the desired value
392:                   NVMADRU = 0x38;
014E  0E38     MOVLW 0x38
0150  0100     MOVLB 0x0
0152  6F45     MOVWF NVMADRU, BANKED
393:                   NVMDATL = data;
0154  C51F     MOVFF data3, NVMDAT
0156  F046     NOP
394:                   //Set the byte write command
395:                   NVMCON1bits.NVMCMD = NVMCMD_WRITE;
0158  5141     MOVF NVMCON1, W, BANKED
015A  0BF8     ANDLW 0xF8
015C  0903     IORLW 0x3
015E  6F41     MOVWF NVMCON1, BANKED
396:                   //Perform the unlock sequence 
397:                   NVMLOCK = 0x55;
0160  0E55     MOVLW 0x55
0162  6F42     MOVWF NVMLOCK, BANKED
398:                   NVMLOCK = 0xAA;
0164  0EAA     MOVLW 0xAA
0166  6F42     MOVWF NVMLOCK, BANKED
399:                   //Start byte write
400:                   NVMCON0bits.GO = 1;
0168  8140     BSF NVMCON0, 0, BANKED
401:                   while (NVMCON0bits.GO)
402:                       ;
016A  B140     BTFSC NVMCON0, 0, BANKED
016C  D7FE     BRA 0x16A
403:                   //Clear the NVM Command
404:                   NVMCON1bits.NVMCMD = NVMCMD_NOP;
016E  0E07     MOVLW 0x7
0170  1341     IORWF NVMCON1, F, BANKED
405:           #endif
406:                   
407:               } while (ee_read() != data);    //repeat if no match. This makes SELF_VERIFY unnecessary here
0172  EC3C     CALL 0x78, 0
0172  EC3C     CALL 0x78, 0
0172  EC3C     CALL 0x78, 0
0172  EC3C     CALL 0x78, 0
0172  EC3C     CALL 0x78, 0
0172  EC3C     CALL 0x78, 0
408:           }
409:           
410:           /**
411:            * Read a byte from data EEPROM.
412:            * The address to be read is passed in TBLPTR
413:            * @return the byte from EEPROM
414:            */
415:           unsigned char ee_read(void) {
416:           #if defined(_18F66K80_FAMILY_)
417:               while (EECON1bits.WR)       // Errata says this is required
418:                   ;
419:               EECON1bits.EEPGD = 0;    	/* Point to DATA memory */
420:               EECON1bits.CFGS = 0;    	/* Access program FLASH/Data EEPROM memory */
421:               EECON1bits.RD = 1;			/* EEPROM Read */
422:               while (EECON1bits.RD)
423:                   ;
424:               asm("NOP");                 /* data available after a NOP */
425:               return EEDATA;
426:           #endif
427:           #if defined(_18FXXQ83_FAMILY_)
428:               NVMADRU = 0x38;
0078  0E38     MOVLW 0x38
007A  0100     MOVLB 0x0
007C  6F45     MOVWF NVMADRU, BANKED
429:               
430:               //Set the byte read command
431:               NVMCON1bits.NVMCMD = NVMCMD_READ;
007E  0EF8     MOVLW 0xF8
0080  1741     ANDWF NVMCON1, F, BANKED
432:               //Start byte read
433:               NVMCON0bits.GO = 1;
0082  8140     BSF NVMCON0, 0, BANKED
434:               while (NVMCON0bits.GO)
435:                   ;
0084  B140     BTFSC NVMCON0, 0, BANKED
0086  D7FE     BRA 0x84
436:               NVMCON1bits.NVMCMD = NVMCMD_NOP;
0088  0E07     MOVLW 0x7
008A  1341     IORWF NVMCON1, F, BANKED
437:               return NVMDATL;
008C  5146     MOVF NVMDAT, W, BANKED
438:           #endif
439:           }
008E  0012     RETURN 0
---  C:/Users/ianwh/AppData/Local/Temp/xcAs101k/driver_tmp_1.s  -----------------------------------------
00F2  0E70     MOVLW 0x70
00F4  6EF6     MOVWF 0xFF6, ACCESS
00F6  0E00     MOVLW 0x0
00F8  6EF7     MOVWF 0xFF7, ACCESS
00FA  0E00     MOVLW 0x0
00FC  6EF8     MOVWF 0xFF8, ACCESS
00FE  0009     TBLRD*+
0100  C4F5     MOVFF TABLAT, learn
0104  0009     TBLRD*+
0106  C4F5     MOVFF TABLAT, nodeNumber
010A  EE01     LFSR 0, 0x501
010E  0E1E     MOVLW 0x1E
0110  6AEE     CLRF 0xFEE, ACCESS
0112  06E8     DECF 0xFE8, F, ACCESS
0114  E1FD     BNZ 0x110
0116  0100     MOVLB 0x0
0118  EFAD     GOTO 0x35A
